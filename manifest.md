# Directory Structure

- ğŸ“ **./**
  - ğŸ“„ **CLAUDE.md**

    ğŸ“„ *File Path*: `.\CLAUDE.md`
    *Size*: 7660 bytes | *Modified*: 2026-01-17 08:48:38

    ```
    # Harbor - Decentralized P2P Chat Application
    
    ## Project Overview
    A Tauri-based decentralized chat application with local-first data storage, peer-to-peer communication via libp2p, and permission-based content sharing.
    
    ## Tech Stack
    - **Desktop Framework**: Tauri (Rust backend + React frontend)
    - **Frontend**: React + TypeScript + Tailwind CSS + Zustand
    - **P2P Networking**: rust-libp2p with mDNS, Kademlia DHT, NAT traversal
    - **Database**: SQLite with event-sourced schema
    - **State Management**: Zustand stores
    
    ## Project Structure
    ```
    D:\apps\chat-app\
    â”œâ”€â”€ src-tauri/           # Rust backend
    â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”œâ”€â”€ commands/    # Tauri command handlers
    â”‚   â”‚   â”œâ”€â”€ services/    # Business logic (identity, posts)
    â”‚   â”‚   â”œâ”€â”€ p2p/         # libp2p networking
    â”‚   â”‚   â”œâ”€â”€ db/          # SQLite repositories
    â”‚   â”‚   â””â”€â”€ models/      # Data models
    â”‚   â””â”€â”€ Cargo.toml
    â”œâ”€â”€ src/                 # React frontend
    â”‚   â”œâ”€â”€ components/      # Reusable UI components
    â”‚   â”‚   â”œâ”€â”€ icons/       # SVG icon components
    â”‚   â”‚   â””â”€â”€ layout/      # MainLayout.tsx
    â”‚   â”œâ”€â”€ pages/           # Page components
    â”‚   â”‚   â”œâ”€â”€ Chat.tsx     # Messaging (uses mock peers)
    â”‚   â”‚   â”œâ”€â”€ Wall.tsx     # Personal journal/posts
    â”‚   â”‚   â”œâ”€â”€ Feed.tsx     # Aggregated feed from contacts
    â”‚   â”‚   â”œâ”€â”€ Network.tsx  # P2P network & contacts
    â”‚   â”‚   â””â”€â”€ Settings.tsx # Profile, security, privacy
    â”‚   â”œâ”€â”€ stores/          # Zustand state management
    â”‚   â”‚   â”œâ”€â”€ identity.ts  # User identity state
    â”‚   â”‚   â”œâ”€â”€ network.ts   # Network connection state
    â”‚   â”‚   â”œâ”€â”€ settings.ts  # User settings (persisted)
    â”‚   â”‚   â””â”€â”€ mockPeers.ts # Mock peer data for testing
    â”‚   â””â”€â”€ services/        # Frontend API services
    â”œâ”€â”€ mock-peer/           # Standalone mock peer server
    â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”œâ”€â”€ main.rs      # Mock peer server entry point
    â”‚   â”‚   â””â”€â”€ protocols.rs # Protocol type definitions
    â”‚   â”œâ”€â”€ Cargo.toml
    â”‚   â””â”€â”€ README.md
    â””â”€â”€ package.json
    ```
    
    ## Implementation Status
    
    ### Completed (Phases 1-7 + UI Polish)
    - Identity system with Ed25519 keypairs and encrypted storage
    - P2P networking with libp2p (mDNS, Kademlia, NAT traversal)
    - SQLite database with event-sourced schema
    - Full UI implementation with dark theme design system
    - All pages functional: Chat, Wall (Journal), Feed, Network, Settings
    
    ### Key Features Implemented
    1. **Identity**: Create/unlock with passphrase, Ed25519 + X25519 keys
    2. **Networking**: Start/stop network, peer discovery, connection status
    3. **Messaging**: Conversations with mock auto-replies for testing
    4. **Journal (Wall)**: Create posts, like, share functionality
    5. **Feed**: Chronological aggregation from all mock peers
    6. **Settings**: Profile editing, security (passphrase change, backup/recovery, delete account), network settings, privacy controls
    
    ## Mock System for Testing
    
    ### Mock Peers (`src/stores/mockPeers.ts`)
    6 mock peers with unique identities and wall posts:
    - Alice Chen (online) - Full-stack developer
    - Bob Wilson (online) - Systems engineer
    - Carol Davis (offline) - UX designer
    - David Miller (online) - Privacy advocate
    - Eva Martinez (online) - Cryptography researcher
    - Frank Johnson (offline) - DevOps engineer
    
    ### Auto-Reply System
    - Online peers automatically reply to messages (1-3 second delay)
    - Contextual responses based on keywords (hello, harbor, p2p, thanks, etc.)
    - Offline peers don't respond
    
    ### Feed Aggregation
    - `getAllFeedPosts()` collects posts from all mock peers
    - Sorted chronologically (most recent first)
    - Each post includes author info and avatar gradient
    
    ## UI Design System
    CSS custom properties in `src/index.css`:
    - `--harbor-bg-primary`, `--harbor-bg-elevated`
    - `--harbor-text-primary`, `--harbor-text-secondary`, `--harbor-text-tertiary`
    - `--harbor-primary`, `--harbor-accent`, `--harbor-success`, `--harbor-error`, `--harbor-warning`
    - `--harbor-border-subtle`, `--harbor-surface-1`, `--harbor-surface-2`
    
    ## Key Files to Know
    
    ### Frontend
    - `src/stores/mockPeers.ts` - Mock peer data, conversations, auto-reply logic
    - `src/stores/identity.ts` - Identity state management
    - `src/pages/Chat.tsx` - Messaging with mock peers
    - `src/pages/Feed.tsx` - Aggregated feed from mock peers
    - `src/pages/Settings.tsx` - All settings with modals for delete/recovery
    - `src/components/layout/MainLayout.tsx` - Sidebar navigation
    
    ### Backend (Rust)
    - `src-tauri/src/commands/network.rs` - Network start/stop commands
    - `src-tauri/src/p2p/network.rs` - NetworkService with libp2p swarm
    - `src-tauri/src/services/identity.rs` - Identity management
    
    ## Recent Changes (Latest Session)
    1. Added human-friendly peer names to Network page (adjective + animal)
    2. Implemented account recovery (export/import backup) and delete account flows
    3. Created mock peers store with 6 peers and their walls
    4. Feed now aggregates posts from all mock peers chronologically
    5. Chat now uses mock peers store with auto-reply for online peers
    6. Renamed "My Wall" to "Journal", "Lock Wallet" to "Lock Account"
    7. Fixed network state management error (Arc<IdentityService>)
    
    ### UI Improvements (Current Session)
    8. Added react-hot-toast for styled toast notifications (replaced all alert() calls)
    9. Implemented like limit (one per post) for Wall and Feed
    10. Implemented image and video upload for Wall posts
    11. Wall posts now persist in Zustand store
    12. Feed save functionality persists in Zustand store
    13. Fixed Network page: "P2P" renamed to "Peer-to-Peer", fixed NaN stats display
    14. Implemented Settings functionality:
        - Profile photo upload
        - Copy unique ID with toast feedback
        - Save profile changes
        - Passphrase change (simulated)
        - Export backup (creates JSON file)
        - Recover account with explanation modal
        - Delete account with confirmation
    15. Online status toggle now affects profile indicator in sidebar
    16. Created settings store with persistence (localStorage)
    
    ## Mock Peer Server (for P2P Testing)
    
    The `mock-peer/` directory contains a standalone Rust binary that implements the same libp2p protocols as Harbor. Use this to test real P2P connectivity.
    
    ### Building and Running
    ```bash
    cd mock-peer
    cargo build --release
    cargo run --release -- --name "Test Peer" --bio "For testing" --port 9000
    ```
    
    ### What It Does
    - Announces itself via mDNS on the local network
    - Responds to identity exchange requests with a signed identity
    - Acknowledges incoming messages
    - Logs auto-reply content (doesn't actually send replies back yet)
    
    ### Protocols Implemented
    - `/harbor/identity/1.0.0` - Identity exchange
    - `/harbor/messaging/1.0.0` - Messaging
    
    ## Known Issues / Future Work
    - Network stats show 0s when network starts (need to populate from actual Rust backend)
    - Mock peer server logs replies but doesn't send them back through the messaging protocol yet
    
    ## Commands
    ```bash
    # Development
    npm run dev          # Start Vite dev server
    npm run tauri dev    # Start Tauri app in dev mode
    
    # Build
    npm run build        # Build frontend
    npm run tauri build  # Build full app
    
    # Type check
    npx tsc --noEmit
    
    # Mock peer server (for P2P testing)
    cd mock-peer && cargo run --release -- --name "Mock Peer"
    ```
    
    ## Plan File Location
    Detailed implementation plan: `C:\Users\richa\.claude\plans\cached-sparking-backus.md`
    ```

  - ğŸ“„ **LICENSE**

    ğŸ“„ *File Path*: `.\LICENSE`
    *Size*: 1076 bytes | *Modified*: 2026-01-16 19:02:28

    ```
    MIT License
    
    Copyright (c) 2025 Harbor Contributors
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    ```

  - ğŸ“„ **README.md**

    ğŸ“„ *File Path*: `.\README.md`
    *Size*: 9925 bytes | *Modified*: 2026-01-17 04:54:49

    ```
    # Harbor
    
    A decentralized peer-to-peer chat application with local-first data storage, end-to-end encryption, and permission-based content sharing.
    
    ## Features
    
    - **Decentralized Identity**: Ed25519 keypairs for signing, X25519 for key agreement
    - **Local-First**: All data stored locally in SQLite, you own your data
    - **P2P Networking**: Direct peer connections via libp2p (mDNS, Kademlia DHT, NAT traversal)
    - **End-to-End Encryption**: AES-256-GCM with HKDF-derived conversation keys
    - **Permission System**: Signed capability grants for content access (Chat, WallRead, Call)
    - **Event Sourcing**: Append-only logs with lamport clocks for conflict-free sync
    - **Voice Calling**: WebRTC signaling through libp2p (best-effort, works on LAN/most NATs)
    
    ## Quick Start
    
    ### Prerequisites
    
    - [Node.js](https://nodejs.org/) (v18+)
    - [Rust](https://rustup.rs/) (stable)
    - [Tauri Prerequisites](https://tauri.app/v1/guides/getting-started/prerequisites)
      - Windows: Microsoft Visual Studio C++ Build Tools
      - macOS: Xcode Command Line Tools
      - Linux: `sudo apt install libwebkit2gtk-4.0-dev build-essential curl wget libssl-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev`
    
    ### Installation
    
    ```bash
    # Clone the repository
    git clone https://github.com/Bakobiibizo/harbor.git
    cd harbor
    
    # Install frontend dependencies
    npm install
    
    # Run in development mode
    npm run tauri dev
    ```
    
    ### Building for Production
    
    ```bash
    # Build the application
    npm run tauri build
    
    # The executable will be in src-tauri/target/release/
    ```
    
    ## Usage Guide
    
    ### First Launch - Create Your Identity
    
    1. When you first open Harbor, you'll be prompted to create an identity
    2. Enter a **Display Name** (how others will see you)
    3. Optionally add a **Bio**
    4. Create a **Passphrase** (at least 8 characters) - this encrypts your private keys
    5. **Important**: Store your passphrase safely! If you lose it, you cannot recover your identity
    
    ### Unlocking Your Identity
    
    - On subsequent launches, enter your passphrase to unlock
    - Your identity remains encrypted on disk when locked
    
    ### Starting the Network
    
    1. Go to the **Network** tab
    2. Click **Start Network** to connect to the P2P network
    3. Peers on your local network running Harbor will be discovered automatically via mDNS
    4. The status indicator shows your connection state
    
    ### Managing Contacts
    
    1. In the **Network** tab, you'll see discovered peers
    2. Click the checkmark to add a peer as a contact
    3. You can search for peers by their Peer ID
    4. Use the **Contacts** tab to manage your contact list
    
    ### Direct Messaging
    
    1. Go to the **Messages** tab
    2. Select a contact to open a conversation
    3. Messages are end-to-end encrypted using derived conversation keys
    4. Click the phone icon to initiate a voice call (if supported)
    
    ### Posting to Your Wall
    
    1. Go to the **My Wall** tab
    2. Use the composer at the top to create a post
    3. You can add images and videos to your posts
    4. Posts are stored locally and shared with contacts who have permission
    
    ### Viewing Your Feed
    
    1. Go to the **Feed** tab
    2. See posts from contacts who have granted you WallRead permission
    3. Like and comment on posts (when implemented)
    
    ### Settings
    
    Access settings to:
    - **Profile**: Update your display name, bio, and avatar
    - **Security**: Change passphrase, export/import identity
    - **Network**: Configure auto-start and mDNS discovery
    - **Privacy**: Control post visibility and read receipts
    
    ## Architecture
    
    ### Frontend (React + TypeScript)
    
    ```
    src/
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ common/          # Button, Input, etc.
    â”‚   â”œâ”€â”€ icons/           # SVG icon components
    â”‚   â”œâ”€â”€ layout/          # MainLayout with sidebar
    â”‚   â””â”€â”€ onboarding/      # CreateIdentity, UnlockIdentity
    â”œâ”€â”€ pages/
    â”‚   â”œâ”€â”€ Chat.tsx         # Direct messaging
    â”‚   â”œâ”€â”€ Wall.tsx         # Your posts
    â”‚   â”œâ”€â”€ Feed.tsx         # Posts from contacts
    â”‚   â”œâ”€â”€ Network.tsx      # Peer discovery & contacts
    â”‚   â””â”€â”€ Settings.tsx     # App configuration
    â”œâ”€â”€ services/            # Tauri command wrappers
    â”‚   â”œâ”€â”€ identity.ts
    â”‚   â”œâ”€â”€ network.ts
    â”‚   â”œâ”€â”€ contacts.ts
    â”‚   â”œâ”€â”€ permissions.ts
    â”‚   â”œâ”€â”€ messaging.ts
    â”‚   â”œâ”€â”€ posts.ts
    â”‚   â”œâ”€â”€ feed.ts
    â”‚   â””â”€â”€ calling.ts
    â”œâ”€â”€ stores/              # Zustand state management
    â”‚   â”œâ”€â”€ identity.ts
    â”‚   â””â”€â”€ network.ts
    â”œâ”€â”€ types/               # TypeScript interfaces
    â””â”€â”€ styles/
        â””â”€â”€ design-system.css  # CSS custom properties
    ```
    
    ### Backend (Rust + Tauri)
    
    ```
    src-tauri/src/
    â”œâ”€â”€ commands/            # Tauri command handlers
    â”‚   â”œâ”€â”€ identity.rs
    â”‚   â”œâ”€â”€ network.rs
    â”‚   â”œâ”€â”€ contacts.rs
    â”‚   â”œâ”€â”€ permissions.rs
    â”‚   â”œâ”€â”€ messaging.rs
    â”‚   â”œâ”€â”€ posts.rs
    â”‚   â”œâ”€â”€ feed.rs
    â”‚   â””â”€â”€ calling.rs
    â”œâ”€â”€ services/            # Business logic
    â”‚   â”œâ”€â”€ identity_service.rs    # Key management
    â”‚   â”œâ”€â”€ crypto_service.rs      # Encryption/signing
    â”‚   â”œâ”€â”€ contacts_service.rs    # Contact management
    â”‚   â”œâ”€â”€ permissions_service.rs # Capability grants
    â”‚   â”œâ”€â”€ messaging_service.rs   # Direct messages
    â”‚   â”œâ”€â”€ posts_service.rs       # Wall posts
    â”‚   â”œâ”€â”€ feed_service.rs        # Feed aggregation
    â”‚   â”œâ”€â”€ content_sync_service.rs # P2P sync
    â”‚   â””â”€â”€ calling_service.rs     # Voice calls
    â”œâ”€â”€ db/
    â”‚   â”œâ”€â”€ mod.rs           # Database initialization
    â”‚   â”œâ”€â”€ migrations/      # SQL migrations
    â”‚   â””â”€â”€ repositories/    # Data access layer
    â”œâ”€â”€ models/              # Data structures
    â””â”€â”€ p2p/
        â”œâ”€â”€ network.rs       # libp2p swarm
        â””â”€â”€ protocols/       # Request-response protocols
    ```
    
    ### Database Schema (SQLite)
    
    - `local_identity` - Your encrypted keypairs and profile
    - `contacts` - Peer information and trust levels
    - `permission_events` - Grant/revoke events (event sourced)
    - `permissions_current` - Materialized permission state
    - `message_events` - Message lifecycle events
    - `messages` - Materialized messages for UI
    - `post_events` - Post lifecycle events
    - `posts` - Materialized posts
    - `post_media` - Media metadata (files stored on disk)
    - `call_history` - Voice call records
    - `sync_state` - Per-peer sync progress
    - `sync_queue` - Offline message queue
    - `lamport_clock` - Logical clock for ordering
    
    ## Security Model
    
    ### Cryptography
    
    | Purpose | Algorithm | Notes |
    |---------|-----------|-------|
    | Identity signing | Ed25519 | All messages signed |
    | Key agreement | X25519 | Derived from Ed25519 |
    | Conversation encryption | AES-256-GCM | HKDF-derived keys |
    | Key encryption | Argon2id + AES-GCM | Passphrase-based |
    | Content hashing | SHA-256 | Media content-addressing |
    
    ### Permission System
    
    Permissions are signed, portable capability grants:
    
    ```rust
    struct PermissionGrant {
        grant_id: Uuid,
        issuer_peer_id: PeerId,      // Who grants
        subject_peer_id: PeerId,     // Who receives
        capability: Capability,       // Chat, WallRead, Call
        issued_at: u64,
        expires_at: Option<u64>,
        signature: Vec<u8>,          // Ed25519 signature
    }
    ```
    
    ### Protected Against
    - MITM attacks (Noise protocol transport + E2E encryption)
    - Message spoofing (all content signed with Ed25519)
    - Replay attacks (nonce tracking, lamport clocks, message IDs)
    - Unauthorized access (permission grants verified on every request)
    
    ### Known Limitations (MVP)
    - No forward secrecy (no double-ratchet yet - compromise exposes history)
    - No HSM/secure enclave integration
    - Connection patterns visible (metadata leakage)
    - Voice calls may not work behind strict NATs (no TURN server)
    
    ## Protocol Messages (CBOR)
    
    ### Identity Exchange
    - `IdentityRequest` / `IdentityResponse` - Exchange peer info
    
    ### Permissions
    - `PermissionRequest` - Request capability from peer
    - `PermissionGrant` - Grant capability to peer
    - `PermissionRevoke` - Revoke previously granted capability
    
    ### Messaging
    - `DirectMessage` - Encrypted message with signature
    - `MessageAck` - Delivery/read receipt
    
    ### Content Sync
    - `ContentManifestRequest/Response` - List available posts
    - `ContentFetchRequest` - Request specific post
    - `MediaChunkRequest/Response` - Transfer media files
    
    ### Voice Calling
    - `SignalingOffer/Answer` - WebRTC SDP exchange
    - `SignalingIce` - ICE candidate exchange
    - `SignalingHangup` - End call
    
    ## Development
    
    ### Running Tests
    
    ```bash
    # Rust tests
    cd src-tauri && cargo test
    
    # TypeScript type check
    npm run typecheck
    ```
    
    ### Code Structure
    
    The codebase follows these patterns:
    - **Event Sourcing**: All state changes are events with lamport clocks
    - **CQRS**: Events stored separately from materialized views
    - **Repository Pattern**: Data access abstracted behind repositories
    - **Service Layer**: Business logic in services, commands are thin wrappers
    
    ## Roadmap
    
    ### Completed (Phases 1-8)
    - [x] Identity system with encrypted key storage
    - [x] P2P networking with libp2p
    - [x] Contact management
    - [x] Permission grants/revokes
    - [x] Direct messaging (encrypted)
    - [x] Wall/blog posts with media
    - [x] Feed aggregation
    - [x] Voice calling (signaling)
    - [x] Modern, polished UI
    
    ### Future (Stretch Goals)
    - [ ] Double-ratchet for forward secrecy
    - [ ] Video calling + screen sharing
    - [ ] Group chats
    - [ ] Mobile app (iOS/Android via Tauri)
    - [ ] TURN server for better NAT traversal
    - [ ] Profile photo uploads
    - [ ] Read receipts
    - [ ] Typing indicators
    
    ## Contributing
    
    Contributions are welcome! Please open an issue or PR.
    
    ## License
    
    MIT License - see [LICENSE](LICENSE)
    ```

  - ğŸ“„ **index.html**

    ğŸ“„ *File Path*: `.\index.html`
    *Size*: 390 bytes | *Modified*: 2026-01-16 17:05:55

    ```
    <!doctype html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Tauri + React + Typescript</title>
      </head>
    
      <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
      </body>
    </html>
    ```

  - ğŸ“ **mock-peer/**
    - ğŸ“„ **Cargo.toml**

      ğŸ“„ *File Path*: `.\mock-peer\Cargo.toml`
      *Size*: 1046 bytes | *Modified*: 2026-01-17 08:44:30

      ```
      [package]
      name = "harbor-mock-peer"
      version = "0.1.0"
      edition = "2021"
      description = "Mock peer server for testing Harbor P2P connectivity"
      
      [[bin]]
      name = "mock-peer"
      path = "src/main.rs"
      
      [dependencies]
      # Async runtime
      tokio = { version = "1", features = ["full"] }
      futures = "0.3"
      
      # libp2p with same features as Harbor
      libp2p = { version = "0.54", features = [
          "tokio",
          "tcp",
          "noise",
          "yamux",
          "kad",
          "mdns",
          "identify",
          "ping",
          "request-response",
          "cbor",
          "macros",
          "serde",
      ] }
      
      # Serialization
      serde = { version = "1.0", features = ["derive"] }
      ciborium = "0.2"
      hex = "0.4"
      sha2 = "0.10"
      async-trait = "0.1"
      
      # Cryptography
      ed25519-dalek = { version = "2.1", features = ["rand_core"] }
      x25519-dalek = { version = "2.0", features = ["static_secrets"] }
      rand = "0.8"
      
      # CLI
      clap = { version = "4", features = ["derive"] }
      
      # Logging
      tracing = "0.1"
      tracing-subscriber = { version = "0.3", features = ["env-filter"] }
      
      # Time
      chrono = "0.4"
      ```

    - ğŸ“„ **README.md**

      ğŸ“„ *File Path*: `.\mock-peer\README.md`
      *Size*: 3178 bytes | *Modified*: 2026-01-17 08:47:50

      ```
      # Harbor Mock Peer Server
      
      A standalone mock peer server that uses the same libp2p protocols as Harbor for testing P2P connectivity.
      
      ## Features
      
      - **mDNS Discovery**: Automatically announces itself on the local network
      - **Identity Exchange**: Responds to identity requests with a valid signed identity
      - **Messaging**: Receives messages and sends acknowledgments
      - **Auto-Reply**: Generates contextual responses to incoming messages
      
      ## Building
      
      ```bash
      cd mock-peer
      cargo build --release
      ```
      
      ## Usage
      
      ```bash
      # Run with default settings
      cargo run --release
      
      # Run with custom name and bio
      cargo run --release -- --name "Alice" --bio "Test peer for Harbor"
      
      # Run on a specific port
      cargo run --release -- --port 9000
      ```
      
      ### Command Line Options
      
      | Option | Short | Default | Description |
      |--------|-------|---------|-------------|
      | `--name` | `-n` | "Mock Peer" | Display name for the peer |
      | `--bio` | `-b` | "A mock peer for testing Harbor P2P" | Bio/description |
      | `--port` | `-p` | 0 (random) | TCP port to listen on |
      
      ## How It Works
      
      1. **Startup**: Generates a new Ed25519 keypair and derives the libp2p Peer ID
      2. **Discovery**: Announces via mDNS so Harbor instances can discover it
      3. **Connection**: Accepts incoming connections from Harbor clients
      4. **Identity Exchange**: When Harbor requests identity, responds with signed identity info
      5. **Messaging**: Acknowledges received messages and logs auto-reply content
      
      ## Protocol Compatibility
      
      This server implements the same protocols as Harbor:
      
      - `/harbor/1.0.0` - Identify protocol
      - `/harbor/identity/1.0.0` - Identity exchange (request/response)
      - `/harbor/messaging/1.0.0` - Messaging (request/response)
      
      ## Testing Workflow
      
      1. Start the mock peer server:
         ```bash
         cargo run --release -- --name "Test Peer" --port 9000
         ```
      
      2. Start Harbor application and enable networking
      
      3. The mock peer should appear in Harbor's Network page
      
      4. Try sending a message to the mock peer from Harbor's Chat page
      
      ## Logging
      
      Set the `RUST_LOG` environment variable to control log verbosity:
      
      ```bash
      # Show all logs
      RUST_LOG=debug cargo run
      
      # Show only info and above
      RUST_LOG=info cargo run
      
      # Show libp2p mDNS debug info
      RUST_LOG=libp2p_mdns=debug cargo run
      ```
      
      ## Example Output
      
      ```
      2024-01-15T10:30:00 INFO harbor_mock_peer: Starting Harbor Mock Peer Server
      2024-01-15T10:30:00 INFO harbor_mock_peer: Name: Mock Peer
      2024-01-15T10:30:00 INFO harbor_mock_peer: Bio: A mock peer for testing Harbor P2P
      2024-01-15T10:30:00 INFO harbor_mock_peer: Peer ID: 12D3KooWExample...
      2024-01-15T10:30:00 INFO harbor_mock_peer: Listening on /ip4/0.0.0.0/tcp/52431/p2p/12D3KooWExample...
      2024-01-15T10:30:00 INFO harbor_mock_peer: Mock peer is running. Press Ctrl+C to stop.
      2024-01-15T10:30:05 INFO harbor_mock_peer: mDNS discovered peer: 12D3KooWHarbor...
      2024-01-15T10:30:06 INFO harbor_mock_peer: Connected to peer: 12D3KooWHarbor...
      2024-01-15T10:30:07 INFO harbor_mock_peer: Identity request from 12D3KooWHarbor...
      2024-01-15T10:30:07 INFO harbor_mock_peer: Sending identity response: name=Mock Peer
      ```
      ```

    - ğŸ“ **src/**
      - ğŸ“„ **main.rs**

        ğŸ“„ *File Path*: `.\mock-peer\src\main.rs`
        *Size*: 15038 bytes | *Modified*: 2026-01-17 08:46:46

        ```
        //! Harbor Mock Peer Server
        //!
        //! A standalone mock peer that uses the same libp2p protocols as Harbor
        //! for testing P2P connectivity. It will:
        //! - Announce itself via mDNS on the local network
        //! - Respond to identity exchange requests
        //! - Auto-reply to messages with contextual responses
        
        mod protocols;
        
        use clap::Parser;
        use futures::StreamExt;
        use libp2p::{
            identify, mdns, noise, ping,
            request_response::{self, ProtocolSupport},
            swarm::{NetworkBehaviour, SwarmEvent},
            tcp, yamux, Multiaddr, PeerId, StreamProtocol, Swarm,
        };
        use std::time::Duration;
        use tracing::{info, warn, error, debug};
        
        use protocols::{
            IdentityRequest, IdentityResponse,
            MessagingRequest, MessagingResponse,
        };
        
        /// Protocol strings (must match Harbor)
        const IDENTITY_PROTOCOL: &str = "/harbor/identity/1.0.0";
        const MESSAGING_PROTOCOL: &str = "/harbor/messaging/1.0.0";
        
        /// Mock peer command line arguments
        #[derive(Parser, Debug)]
        #[command(author, version, about, long_about = None)]
        struct Args {
            /// Display name for the mock peer
            #[arg(short, long, default_value = "Mock Peer")]
            name: String,
        
            /// Bio/description
            #[arg(short, long, default_value = "A mock peer for testing Harbor P2P")]
            bio: String,
        
            /// TCP port to listen on (0 = random)
            #[arg(short, long, default_value_t = 0)]
            port: u16,
        }
        
        /// Combined network behaviour for the mock peer
        #[derive(NetworkBehaviour)]
        struct MockPeerBehaviour {
            ping: ping::Behaviour,
            identify: identify::Behaviour,
            mdns: mdns::tokio::Behaviour,
            identity_exchange: request_response::cbor::Behaviour<IdentityRequest, IdentityResponse>,
            messaging: request_response::cbor::Behaviour<MessagingRequest, MessagingResponse>,
        }
        
        /// Mock peer state
        struct MockPeer {
            /// Display name
            name: String,
            /// Bio
            bio: String,
            /// Ed25519 signing keypair
            signing_key: ed25519_dalek::SigningKey,
            /// X25519 public key
            x25519_public: [u8; 32],
            /// libp2p peer ID
            peer_id: PeerId,
            /// Message counter for auto-replies
            message_counter: u64,
        }
        
        impl MockPeer {
            fn new(name: String, bio: String, keypair: &libp2p::identity::Keypair) -> Self {
                // Extract Ed25519 key for signing
                let ed25519_keypair = keypair.clone().try_into_ed25519().unwrap();
                let signing_key = ed25519_dalek::SigningKey::from_bytes(
                    &ed25519_keypair.secret().as_ref()[..32].try_into().unwrap()
                );
        
                // Generate X25519 key from Ed25519 (deterministic)
                let x25519_secret = x25519_dalek::StaticSecret::from(
                    *signing_key.as_bytes()
                );
                let x25519_public = x25519_dalek::PublicKey::from(&x25519_secret);
        
                Self {
                    name,
                    bio,
                    signing_key,
                    x25519_public: x25519_public.to_bytes(),
                    peer_id: keypair.public().to_peer_id(),
                    message_counter: 0,
                }
            }
        
            /// Create identity response for this peer
            fn create_identity_response(&self) -> IdentityResponse {
                use ed25519_dalek::Signer;
        
                let timestamp = chrono::Utc::now().timestamp();
                let public_key = self.signing_key.verifying_key().to_bytes().to_vec();
        
                // Create response without signature first
                let mut response = IdentityResponse {
                    peer_id: self.peer_id.to_string(),
                    public_key: public_key.clone(),
                    x25519_public: self.x25519_public.to_vec(),
                    display_name: self.name.clone(),
                    avatar_hash: None,
                    bio: Some(self.bio.clone()),
                    timestamp,
                    signature: vec![],
                };
        
                // Sign the response
                let sign_data = format!(
                    "{}:{}:{}:{}:{}:{:?}:{}",
                    response.peer_id,
                    hex::encode(&response.public_key),
                    hex::encode(&response.x25519_public),
                    response.display_name,
                    response.avatar_hash.as_deref().unwrap_or(""),
                    response.bio,
                    response.timestamp,
                );
        
                let signature = self.signing_key.sign(sign_data.as_bytes());
                response.signature = signature.to_bytes().to_vec();
        
                response
            }
        
            /// Generate an auto-reply message based on content
            fn generate_reply(&mut self, sender_name: &str, _content: &str) -> String {
                self.message_counter += 1;
        
                // Cycle through different responses
                let responses = [
                    format!("Hey! This is {} - a mock peer for testing. Your message was received successfully!", self.name),
                    format!("Thanks for testing Harbor's P2P messaging! Connection verified. - {}", self.name),
                    format!("Message received loud and clear! The decentralized future is here. - {}", self.name),
                    format!("Hello from the mock peer server! Everything is working as expected."),
                    format!("Great to connect with you, {}! Harbor's P2P is functioning properly.", sender_name),
                ];
        
                responses[self.message_counter as usize % responses.len()].clone()
            }
        }
        
        #[tokio::main]
        async fn main() -> Result<(), Box<dyn std::error::Error>> {
            // Initialize logging
            tracing_subscriber::fmt()
                .with_env_filter(
                    tracing_subscriber::EnvFilter::from_default_env()
                        .add_directive("harbor_mock_peer=info".parse()?)
                        .add_directive("libp2p_mdns=info".parse()?)
                        .add_directive("libp2p_identify=debug".parse()?)
                )
                .init();
        
            let args = Args::parse();
        
            info!("Starting Harbor Mock Peer Server");
            info!("Name: {}", args.name);
            info!("Bio: {}", args.bio);
        
            // Generate a new keypair for this peer
            let keypair = libp2p::identity::Keypair::generate_ed25519();
            let peer_id = keypair.public().to_peer_id();
        
            info!("Peer ID: {}", peer_id);
        
            // Create mock peer state
            let mock_peer = MockPeer::new(args.name.clone(), args.bio.clone(), &keypair);
        
            // Build the swarm
            let mut swarm = build_swarm(keypair.clone())?;
        
            // Listen on TCP
            let listen_addr: Multiaddr = format!("/ip4/0.0.0.0/tcp/{}", args.port).parse()?;
            swarm.listen_on(listen_addr)?;
        
            info!("Mock peer is running. Press Ctrl+C to stop.");
            info!("Other Harbor instances on the local network will discover this peer via mDNS.");
        
            // Store mock peer in a cell for mutation
            let mut mock_peer = mock_peer;
        
            // Main event loop
            loop {
                match swarm.select_next_some().await {
                    SwarmEvent::NewListenAddr { address, .. } => {
                        info!("Listening on {}/p2p/{}", address, peer_id);
                    }
        
                    SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
                        info!("Connected to peer: {} via {:?}", peer_id, endpoint);
                    }
        
                    SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                        info!("Disconnected from peer: {} (cause: {:?})", peer_id, cause);
                    }
        
                    SwarmEvent::Behaviour(MockPeerBehaviourEvent::Mdns(event)) => {
                        match event {
                            mdns::Event::Discovered(peers) => {
                                for (peer_id, addr) in peers {
                                    info!("mDNS discovered peer: {} at {}", peer_id, addr);
                                    // Add to Kademlia-like tracking (we could dial them)
                                }
                            }
                            mdns::Event::Expired(peers) => {
                                for (peer_id, _) in peers {
                                    debug!("mDNS peer expired: {}", peer_id);
                                }
                            }
                        }
                    }
        
                    SwarmEvent::Behaviour(MockPeerBehaviourEvent::Ping(event)) => {
                        debug!("Ping: {:?}", event);
                    }
        
                    SwarmEvent::Behaviour(MockPeerBehaviourEvent::Identify(event)) => {
                        match event {
                            identify::Event::Received { peer_id, info, .. } => {
                                info!(
                                    "Identified peer {}: {} ({})",
                                    peer_id,
                                    info.agent_version,
                                    info.protocol_version
                                );
                            }
                            identify::Event::Sent { peer_id, .. } => {
                                debug!("Sent identify to {}", peer_id);
                            }
                            _ => {}
                        }
                    }
        
                    SwarmEvent::Behaviour(MockPeerBehaviourEvent::IdentityExchange(event)) => {
                        match event {
                            request_response::Event::Message { peer, message } => {
                                match message {
                                    request_response::Message::Request { request, channel, .. } => {
                                        info!("Identity request from {}: {:?}", peer, request.requester_peer_id);
        
                                        // Create and send response
                                        let response = mock_peer.create_identity_response();
                                        info!("Sending identity response: name={}", response.display_name);
        
                                        if let Err(e) = swarm.behaviour_mut().identity_exchange.send_response(channel, response) {
                                            error!("Failed to send identity response: {:?}", e);
                                        }
                                    }
                                    request_response::Message::Response { response, .. } => {
                                        info!("Received identity response from {}: {}", peer, response.display_name);
                                    }
                                }
                            }
                            request_response::Event::OutboundFailure { peer, error, .. } => {
                                warn!("Identity exchange outbound failure to {}: {:?}", peer, error);
                            }
                            request_response::Event::InboundFailure { peer, error, .. } => {
                                warn!("Identity exchange inbound failure from {}: {:?}", peer, error);
                            }
                            request_response::Event::ResponseSent { peer, .. } => {
                                debug!("Identity response sent to {}", peer);
                            }
                        }
                    }
        
                    SwarmEvent::Behaviour(MockPeerBehaviourEvent::Messaging(event)) => {
                        match event {
                            request_response::Event::Message { peer, message } => {
                                match message {
                                    request_response::Message::Request { request, channel, .. } => {
                                        info!(
                                            "Message from {}: type={}, payload_len={}",
                                            peer, request.message_type, request.payload.len()
                                        );
        
                                        // Generate auto-reply
                                        let reply_content = mock_peer.generate_reply(
                                            &peer.to_string(),
                                            "(encrypted content)",
                                        );
                                        info!("Auto-reply: {}", reply_content);
        
                                        // Send success response
                                        let response = MessagingResponse {
                                            success: true,
                                            message_id: Some(format!("mock-{}", mock_peer.message_counter)),
                                            error: None,
                                        };
        
                                        if let Err(e) = swarm.behaviour_mut().messaging.send_response(channel, response) {
                                            error!("Failed to send messaging response: {:?}", e);
                                        }
                                    }
                                    request_response::Message::Response { response, .. } => {
                                        info!("Messaging response from {}: success={}", peer, response.success);
                                    }
                                }
                            }
                            request_response::Event::OutboundFailure { peer, error, .. } => {
                                warn!("Messaging outbound failure to {}: {:?}", peer, error);
                            }
                            request_response::Event::InboundFailure { peer, error, .. } => {
                                warn!("Messaging inbound failure from {}: {:?}", peer, error);
                            }
                            request_response::Event::ResponseSent { peer, .. } => {
                                debug!("Messaging response sent to {}", peer);
                            }
                        }
                    }
        
                    _ => {}
                }
            }
        }
        
        /// Build the libp2p swarm with all required behaviours
        fn build_swarm(
            keypair: libp2p::identity::Keypair,
        ) -> Result<Swarm<MockPeerBehaviour>, Box<dyn std::error::Error>> {
            let peer_id = keypair.public().to_peer_id();
        
            let swarm = libp2p::SwarmBuilder::with_existing_identity(keypair)
                .with_tokio()
                .with_tcp(
                    tcp::Config::default().nodelay(true),
                    noise::Config::new,
                    yamux::Config::default,
                )?
                .with_behaviour(|keypair| {
                    // Ping for connection liveness
                    let ping = ping::Behaviour::new(ping::Config::new().with_interval(Duration::from_secs(15)));
        
                    // Identify for peer info exchange
                    let identify = identify::Behaviour::new(identify::Config::new(
                        "/harbor/1.0.0".to_string(),
                        keypair.public(),
                    ));
        
                    // mDNS for local discovery
                    let mdns = mdns::tokio::Behaviour::new(
                        mdns::Config::default(),
                        peer_id,
                    )?;
        
                    // Identity exchange protocol (using built-in CBOR codec)
                    let identity_exchange = request_response::cbor::Behaviour::new(
                        [(StreamProtocol::new(IDENTITY_PROTOCOL), ProtocolSupport::Full)],
                        request_response::Config::default(),
                    );
        
                    // Messaging protocol (using built-in CBOR codec)
                    let messaging = request_response::cbor::Behaviour::new(
                        [(StreamProtocol::new(MESSAGING_PROTOCOL), ProtocolSupport::Full)],
                        request_response::Config::default(),
                    );
        
                    Ok(MockPeerBehaviour {
                        ping,
                        identify,
                        mdns,
                        identity_exchange,
                        messaging,
                    })
                })?
                .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
                .build();
        
            Ok(swarm)
        }
        ```

      - ğŸ“„ **protocols.rs**

        ğŸ“„ *File Path*: `.\mock-peer\src\protocols.rs`
        *Size*: 2037 bytes | *Modified*: 2026-01-17 08:47:00

        ```
        //! Protocol definitions for Harbor P2P communication
        //!
        //! These must match the protocol definitions in the main Harbor app's behaviour.rs
        
        use serde::{Deserialize, Serialize};
        
        // ============================================================================
        // Identity Exchange Protocol
        // ============================================================================
        
        /// Request for identity information from a peer
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct IdentityRequest {
            /// The peer ID of the requester
            pub requester_peer_id: String,
            /// Timestamp of the request
            pub timestamp: i64,
            /// Signature over (requester_peer_id, timestamp) using requester's Ed25519 key
            pub signature: Vec<u8>,
        }
        
        /// Response containing identity information
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct IdentityResponse {
            /// The peer ID (derived from public key)
            pub peer_id: String,
            /// Ed25519 public key
            pub public_key: Vec<u8>,
            /// X25519 public key for key agreement
            pub x25519_public: Vec<u8>,
            /// Display name
            pub display_name: String,
            /// Avatar hash (SHA-256 of avatar image)
            pub avatar_hash: Option<String>,
            /// Bio/description
            pub bio: Option<String>,
            /// Timestamp
            pub timestamp: i64,
            /// Signature over all fields above
            pub signature: Vec<u8>,
        }
        
        // ============================================================================
        // Messaging Protocol
        // ============================================================================
        
        /// Messaging request (matches Harbor's MessagingRequest)
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct MessagingRequest {
            pub message_type: String,
            pub payload: Vec<u8>,
        }
        
        /// Messaging response (matches Harbor's MessagingResponse)
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct MessagingResponse {
            pub success: bool,
            pub message_id: Option<String>,
            pub error: Option<String>,
        }
        ```

  - ğŸ“„ **package.json**

    ğŸ“„ *File Path*: `.\package.json`
    *Size*: 750 bytes | *Modified*: 2026-01-17 06:54:27

    ```
    {
      "name": "harbor",
      "private": true,
      "version": "0.1.0",
      "type": "module",
      "scripts": {
        "dev": "vite",
        "build": "tsc && vite build",
        "preview": "vite preview",
        "tauri": "tauri"
      },
      "dependencies": {
        "react": "^19.1.0",
        "react-dom": "^19.1.0",
        "react-hot-toast": "^2.4.1",
        "react-router-dom": "^7.2.0",
        "@tauri-apps/api": "^2",
        "@tauri-apps/plugin-opener": "^2",
        "zustand": "^5.0.0"
      },
      "devDependencies": {
        "@types/react": "^19.1.8",
        "@types/react-dom": "^19.1.6",
        "@vitejs/plugin-react": "^4.6.0",
        "typescript": "~5.8.3",
        "vite": "^7.0.4",
        "@tauri-apps/cli": "^2",
        "tailwindcss": "^4.1.4",
        "@tailwindcss/vite": "^4.1.4"
      }
    }
    ```

  - ğŸ“ **public/**
    - ğŸ“„ **tauri.svg**

      ğŸ“„ *File Path*: `.\public\tauri.svg`
      *Size*: 2605 bytes | *Modified*: 2026-01-16 17:05:55

      ```
      <svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
      <ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
      <path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
      <path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
      </svg>
      ```

    - ğŸ“„ **vite.svg**

      ğŸ“„ *File Path*: `.\public\vite.svg`
      *Size*: 1497 bytes | *Modified*: 2026-01-16 17:05:55

      ```
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
      ```

  - ğŸ“„ **run-alice.bat**

    ğŸ“„ *File Path*: `.\run-alice.bat`
    *Size*: 295 bytes | *Modified*: 2026-01-17 12:38:47

    ```
    @echo off
    REM Launch Harbor instance as "Alice" (dev mode)
    REM This uses the default data directory
    
    set HARBOR_PROFILE=Alice
    set HARBOR_DATA_DIR=%USERPROFILE%\.harbor-alice
    
    echo Starting Harbor as Alice (dev mode)...
    echo Data directory: %HARBOR_DATA_DIR%
    echo.
    
    npm run tauri dev
    ```

  - ğŸ“„ **run-bob-dev.bat**

    ğŸ“„ *File Path*: `.\run-bob-dev.bat`
    *Size*: 576 bytes | *Modified*: 2026-01-18 00:08:04

    ```
    @echo off
    REM Launch Harbor instance as "Bob" in dev mode
    REM Uses a separate Vite port (1421) so it can run alongside Alice (1420)
    
    set HARBOR_PROFILE=Bob
    set HARBOR_DATA_DIR=%USERPROFILE%\.harbor-bob
    set RUST_BACKTRACE=1
    set RUST_LOG=harbor_lib=debug
    set VITE_PORT=1421
    
    echo Starting Harbor as Bob (dev mode)...
    echo Data directory: %HARBOR_DATA_DIR%
    echo Vite port: %VITE_PORT%
    echo.
    
    REM Run tauri dev with custom devUrl pointing to port 1421
    npm run tauri dev -- --config src-tauri/tauri.bob.json
    
    echo.
    echo App exited with code %ERRORLEVEL%
    pause
    ```

  - ğŸ“„ **run-bob.bat**

    ğŸ“„ *File Path*: `.\run-bob.bat`
    *Size*: 1888 bytes | *Modified*: 2026-01-17 20:01:34

    ```
    @echo off
    REM Launch Harbor instance as "Bob" (requires built app)
    REM First run: npm run tauri build
    REM This uses a separate data directory so Alice and Bob have separate identities
    
    set HARBOR_PROFILE=Bob
    set HARBOR_DATA_DIR=%USERPROFILE%\.harbor-bob
    set RUST_BACKTRACE=full
    set RUST_LOG=harbor_lib=debug,info
    
    echo Starting Harbor as Bob...
    echo Data directory: %HARBOR_DATA_DIR%
    echo.
    echo NOTE: If you haven't built the app yet, run: npm run tauri build
    echo.
    
    REM Create the data directory if it doesn't exist
    if not exist "%HARBOR_DATA_DIR%" mkdir "%HARBOR_DATA_DIR%"
    
    REM Run and capture output to log file (append)
    echo. >> "%HARBOR_DATA_DIR%\bob.log"
    echo ============== Session started at %date% %time% ============== >> "%HARBOR_DATA_DIR%\bob.log"
    
    if exist "src-tauri\target\release\harbor.exe" (
        echo Running release build...
        "src-tauri\target\release\harbor.exe" >> "%HARBOR_DATA_DIR%\bob.log" 2>&1
        set EXITCODE=%ERRORLEVEL%
        echo App exited with code %EXITCODE% >> "%HARBOR_DATA_DIR%\bob.log"
        echo.
        echo App exited with code %EXITCODE%
        echo Check log at: %HARBOR_DATA_DIR%\bob.log
        echo.
        echo Last 30 lines of log:
        powershell -command "Get-Content '%HARBOR_DATA_DIR%\bob.log' -Tail 30"
        pause
    ) else if exist "src-tauri\target\debug\harbor.exe" (
        echo Running debug build...
        "src-tauri\target\debug\harbor.exe" >> "%HARBOR_DATA_DIR%\bob.log" 2>&1
        set EXITCODE=%ERRORLEVEL%
        echo App exited with code %EXITCODE% >> "%HARBOR_DATA_DIR%\bob.log"
        echo.
        echo App exited with code %EXITCODE%
        echo Check log at: %HARBOR_DATA_DIR%\bob.log
        echo.
        echo Last 30 lines of log:
        powershell -command "Get-Content '%HARBOR_DATA_DIR%\bob.log' -Tail 30"
        pause
    ) else (
        echo ERROR: No built executable found. Please run: npm run tauri build
        pause
    )
    ```

  - ğŸ“„ **run-bob.ps1**

    ğŸ“„ *File Path*: `.\run-bob.ps1`
    *Size*: 276 bytes | *Modified*: 2026-01-17 12:37:15

    ```
    # Run Bob instance with different ports
    # Set environment variables for Bob's data directory and ports
    
    $env:HARBOR_DATA_DIR = "D:\apps\chat-app\bob-data"
    $env:VITE_DEV_SERVER_PORT = "1421"
    
    # Run tauri dev with custom vite port
    npm run tauri dev -- -- -- --port 1421
    ```

  - ğŸ“ **src/**
    - ğŸ“„ **App.css**

      ğŸ“„ *File Path*: `.\src\App.css`
      *Size*: 7690 bytes | *Modified*: 2026-01-17 04:34:39

      ```
      @import "tailwindcss";
      @import "./styles/design-system.css";
      
      /* ============================================
         Harbor - Global Styles
         ============================================ */
      
      /* Prevent text selection during drag operations */
      .select-none {
        user-select: none;
      }
      
      /* Smooth scrolling */
      html {
        scroll-behavior: smooth;
      }
      
      /* ============================================
         Typography Helpers
         ============================================ */
      
      .text-gradient {
        background: linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      
      .text-balance {
        text-wrap: balance;
      }
      
      /* ============================================
         Layout Helpers
         ============================================ */
      
      .hide-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      
      .hide-scrollbar::-webkit-scrollbar {
        display: none;
      }
      
      /* ============================================
         Interactive States
         ============================================ */
      
      .interactive {
        transition: all var(--transition-fast);
      }
      
      .interactive:hover {
        transform: translateY(-1px);
      }
      
      .interactive:active {
        transform: translateY(0);
      }
      
      /* Press effect for buttons */
      .press-effect {
        transition: transform var(--transition-fast);
      }
      
      .press-effect:active {
        transform: scale(0.98);
      }
      
      /* ============================================
         Card Styles
         ============================================ */
      
      .card {
        background: hsl(var(--harbor-bg-elevated));
        border: 1px solid hsl(var(--harbor-border-subtle));
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-sm);
        transition: all var(--transition-base);
      }
      
      .card:hover {
        box-shadow: var(--shadow-md);
        border-color: hsl(var(--harbor-border));
      }
      
      .card-interactive {
        cursor: pointer;
      }
      
      .card-interactive:hover {
        transform: translateY(-2px);
      }
      
      /* ============================================
         Input Enhancements
         ============================================ */
      
      input, textarea, select {
        font-family: inherit;
      }
      
      /* Autofill styles */
      input:-webkit-autofill,
      input:-webkit-autofill:hover,
      input:-webkit-autofill:focus {
        -webkit-text-fill-color: hsl(var(--harbor-text-primary));
        -webkit-box-shadow: 0 0 0px 1000px hsl(var(--harbor-bg-elevated)) inset;
        transition: background-color 5000s ease-in-out 0s;
      }
      
      /* ============================================
         Badge Styles
         ============================================ */
      
      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-1) var(--space-2);
        font-size: var(--font-size-xs);
        font-weight: var(--font-weight-medium);
        border-radius: var(--radius-full);
        white-space: nowrap;
      }
      
      .badge-primary {
        background: hsl(var(--harbor-primary) / 0.1);
        color: hsl(var(--harbor-primary));
      }
      
      .badge-success {
        background: hsl(var(--harbor-success) / 0.1);
        color: hsl(var(--harbor-success));
      }
      
      .badge-warning {
        background: hsl(var(--harbor-warning) / 0.1);
        color: hsl(var(--harbor-warning));
      }
      
      .badge-error {
        background: hsl(var(--harbor-error) / 0.1);
        color: hsl(var(--harbor-error));
      }
      
      /* ============================================
         Avatar Styles
         ============================================ */
      
      .avatar {
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)));
        color: white;
        font-weight: var(--font-weight-semibold);
        border-radius: var(--radius-full);
        overflow: hidden;
        flex-shrink: 0;
      }
      
      .avatar-sm {
        width: 32px;
        height: 32px;
        font-size: var(--font-size-sm);
      }
      
      .avatar-md {
        width: 40px;
        height: 40px;
        font-size: var(--font-size-base);
      }
      
      .avatar-lg {
        width: 56px;
        height: 56px;
        font-size: var(--font-size-xl);
      }
      
      .avatar-xl {
        width: 80px;
        height: 80px;
        font-size: var(--font-size-2xl);
      }
      
      /* Online indicator */
      .avatar-online::after {
        content: '';
        position: absolute;
        bottom: 0;
        right: 0;
        width: 25%;
        height: 25%;
        min-width: 8px;
        min-height: 8px;
        background: hsl(var(--harbor-success));
        border: 2px solid hsl(var(--harbor-bg-primary));
        border-radius: var(--radius-full);
      }
      
      /* ============================================
         Message Bubble Styles
         ============================================ */
      
      .message-bubble {
        max-width: 70%;
        padding: var(--space-3) var(--space-4);
        border-radius: var(--radius-xl);
        word-wrap: break-word;
      }
      
      .message-bubble-sent {
        background: hsl(var(--harbor-primary));
        color: white;
        border-bottom-right-radius: var(--radius-sm);
        margin-left: auto;
      }
      
      .message-bubble-received {
        background: hsl(var(--harbor-surface-1));
        color: hsl(var(--harbor-text-primary));
        border-bottom-left-radius: var(--radius-sm);
      }
      
      /* ============================================
         Skeleton Loading
         ============================================ */
      
      .skeleton {
        background: linear-gradient(
          90deg,
          hsl(var(--harbor-surface-1)) 25%,
          hsl(var(--harbor-surface-2)) 50%,
          hsl(var(--harbor-surface-1)) 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: var(--radius-md);
      }
      
      .skeleton-text {
        height: 1em;
        margin-bottom: 0.5em;
      }
      
      .skeleton-text:last-child {
        width: 70%;
      }
      
      .skeleton-avatar {
        border-radius: var(--radius-full);
      }
      
      /* ============================================
         Tooltip Styles
         ============================================ */
      
      .tooltip {
        position: relative;
      }
      
      .tooltip::before {
        content: attr(data-tooltip);
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%) scale(0.95);
        padding: var(--space-2) var(--space-3);
        background: hsl(var(--harbor-text-primary));
        color: hsl(var(--harbor-text-inverse));
        font-size: var(--font-size-xs);
        font-weight: var(--font-weight-medium);
        border-radius: var(--radius-md);
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-fast);
        z-index: var(--z-tooltip);
      }
      
      .tooltip:hover::before {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }
      
      /* ============================================
         Divider
         ============================================ */
      
      .divider {
        height: 1px;
        background: hsl(var(--harbor-border-subtle));
        margin: var(--space-4) 0;
      }
      
      .divider-vertical {
        width: 1px;
        height: auto;
        background: hsl(var(--harbor-border-subtle));
        margin: 0 var(--space-4);
      }
      
      /* ============================================
         Empty State
         ============================================ */
      
      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: var(--space-12);
        text-align: center;
      }
      
      .empty-state-icon {
        width: 80px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: hsl(var(--harbor-surface-1));
        border-radius: var(--radius-full);
        margin-bottom: var(--space-6);
        font-size: 2rem;
      }
      
      .empty-state-title {
        font-size: var(--font-size-lg);
        font-weight: var(--font-weight-semibold);
        color: hsl(var(--harbor-text-primary));
        margin-bottom: var(--space-2);
      }
      
      .empty-state-description {
        font-size: var(--font-size-sm);
        color: hsl(var(--harbor-text-secondary));
        max-width: 300px;
      }
      ```

    - ğŸ“„ **App.tsx**

      ğŸ“„ *File Path*: `.\src\App.tsx`
      *Size*: 6797 bytes | *Modified*: 2026-01-18 00:16:59

      ```
      import { useEffect, Component, type ReactNode } from "react";
      import { HashRouter, Routes, Route, Navigate } from "react-router-dom";
      import { Toaster } from "react-hot-toast";
      import { useIdentityStore } from "./stores";
      import { useTauriEvents } from "./hooks";
      import { MainLayout } from "./components/layout";
      import { CreateIdentity, UnlockIdentity } from "./components/onboarding";
      import { HarborIcon } from "./components/icons";
      import {
        ChatPage,
        WallPage,
        FeedPage,
        NetworkPage,
        SettingsPage,
      } from "./pages";
      
      // Error boundary to catch and display React errors
      interface ErrorBoundaryState {
        hasError: boolean;
        error: Error | null;
      }
      
      class ErrorBoundary extends Component<{ children: ReactNode }, ErrorBoundaryState> {
        constructor(props: { children: ReactNode }) {
          super(props);
          this.state = { hasError: false, error: null };
        }
      
        static getDerivedStateFromError(error: Error) {
          return { hasError: true, error };
        }
      
        componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
          console.error("React Error Boundary caught:", error, errorInfo);
        }
      
        render() {
          if (this.state.hasError) {
            return (
              <div
                style={{
                  padding: "40px",
                  background: "#1a1a2e",
                  color: "#fff",
                  minHeight: "100vh",
                  fontFamily: "monospace",
                }}
              >
                <h1 style={{ color: "#ff6b6b", marginBottom: "20px" }}>Something went wrong</h1>
                <pre
                  style={{
                    background: "#0d0d1a",
                    padding: "20px",
                    borderRadius: "8px",
                    overflow: "auto",
                    whiteSpace: "pre-wrap",
                    wordBreak: "break-word",
                  }}
                >
                  {this.state.error?.message}
                  {"\n\n"}
                  {this.state.error?.stack}
                </pre>
                <button
                  onClick={() => window.location.reload()}
                  style={{
                    marginTop: "20px",
                    padding: "10px 20px",
                    background: "#6366f1",
                    color: "white",
                    border: "none",
                    borderRadius: "8px",
                    cursor: "pointer",
                  }}
                >
                  Reload App
                </button>
              </div>
            );
          }
      
          return this.props.children;
        }
      }
      
      function LoadingScreen() {
        return (
          <div
            className="min-h-screen flex items-center justify-center"
            style={{
              background: "linear-gradient(135deg, hsl(220 91% 8%) 0%, hsl(262 60% 12%) 50%, hsl(220 91% 8%) 100%)",
            }}
          >
            <div className="text-center">
              {/* Animated logo container */}
              <div className="relative mb-8">
                {/* Outer glow ring */}
                <div
                  className="absolute inset-0 rounded-full animate-pulse"
                  style={{
                    background: "radial-gradient(circle, hsl(var(--harbor-primary) / 0.3) 0%, transparent 70%)",
                    transform: "scale(2)",
                  }}
                />
                {/* Logo */}
                <div
                  className="relative w-20 h-20 rounded-2xl flex items-center justify-center mx-auto"
                  style={{
                    background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                    boxShadow: "0 8px 32px hsl(var(--harbor-primary) / 0.4)",
                  }}
                >
                  <HarborIcon className="w-12 h-12 text-white" />
                </div>
              </div>
      
              {/* Loading text */}
              <h2
                className="text-xl font-semibold mb-2"
                style={{ color: "hsl(var(--harbor-text-primary))" }}
              >
                Harbor
              </h2>
              <p
                className="text-sm mb-6"
                style={{ color: "hsl(var(--harbor-text-tertiary))" }}
              >
                Initializing secure connection...
              </p>
      
              {/* Loading bar */}
              <div
                className="w-48 h-1 rounded-full mx-auto overflow-hidden"
                style={{ background: "hsl(var(--harbor-surface-2))" }}
              >
                <div
                  className="h-full rounded-full"
                  style={{
                    background: "linear-gradient(90deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                    animation: "loading-bar 1.5s ease-in-out infinite",
                  }}
                />
              </div>
            </div>
      
            {/* CSS animation for loading bar */}
            <style>{`
              @keyframes loading-bar {
                0% { width: 0%; margin-left: 0%; }
                50% { width: 60%; margin-left: 20%; }
                100% { width: 0%; margin-left: 100%; }
              }
            `}</style>
          </div>
        );
      }
      
      function AppContent() {
        const { state, initialize } = useIdentityStore();
      
        // Set up Tauri event listeners for real-time updates from backend
        useTauriEvents();
      
        useEffect(() => {
          initialize();
        }, [initialize]);
      
        // Loading state
        if (state.status === "loading") {
          return <LoadingScreen />;
        }
      
        // No identity - show create screen
        if (state.status === "no_identity") {
          return <CreateIdentity />;
        }
      
        // Identity locked - show unlock screen
        if (state.status === "locked") {
          return <UnlockIdentity />;
        }
      
        // Identity unlocked - show main app
        return (
          <MainLayout>
            <Routes>
              <Route path="/chat" element={<ChatPage />} />
              <Route path="/wall" element={<WallPage />} />
              <Route path="/feed" element={<FeedPage />} />
              <Route path="/network" element={<NetworkPage />} />
              <Route path="/settings" element={<SettingsPage />} />
              <Route path="*" element={<Navigate to="/chat" replace />} />
            </Routes>
          </MainLayout>
        );
      }
      
      export default function App() {
        return (
          <ErrorBoundary>
            <HashRouter>
              <AppContent />
              <Toaster
                position="bottom-right"
                toastOptions={{
                  duration: 3000,
                  style: {
                    background: "hsl(222 41% 13%)",
                    color: "hsl(220 14% 96%)",
                    border: "1px solid hsl(222 30% 22%)",
                    borderRadius: "12px",
                    padding: "12px 16px",
                    fontSize: "14px",
                    boxShadow: "0 10px 40px rgba(0, 0, 0, 0.4)",
                  },
                  success: {
                    iconTheme: {
                      primary: "hsl(152 69% 40%)",
                      secondary: "white",
                    },
                  },
                  error: {
                    iconTheme: {
                      primary: "hsl(0 84% 60%)",
                      secondary: "white",
                    },
                  },
                }}
              />
            </HashRouter>
          </ErrorBoundary>
        );
      }
      ```

    - ğŸ“ **assets/**
      - ğŸ“„ **react.svg**

        ğŸ“„ *File Path*: `.\src\assets\react.svg`
        *Size*: 4126 bytes | *Modified*: 2026-01-16 17:05:55

        ```
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
        ```

    - ğŸ“ **components/**
      - ğŸ“ **common/**
        - ğŸ“„ **Button.tsx**

          ğŸ“„ *File Path*: `.\src\components\common\Button.tsx`
          *Size*: 1945 bytes | *Modified*: 2026-01-16 17:15:21

          ```
          import { type ButtonHTMLAttributes, type ReactNode } from "react";
          
          interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
            variant?: "primary" | "secondary" | "ghost";
            size?: "sm" | "md" | "lg";
            loading?: boolean;
            children: ReactNode;
          }
          
          export function Button({
            variant = "primary",
            size = "md",
            loading = false,
            children,
            className = "",
            disabled,
            ...props
          }: ButtonProps) {
            const baseStyles =
              "inline-flex items-center justify-center font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed";
          
            const variants = {
              primary:
                "bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500",
              secondary:
                "bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500 dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600",
              ghost:
                "text-gray-700 hover:bg-gray-100 focus:ring-gray-500 dark:text-gray-300 dark:hover:bg-gray-800",
            };
          
            const sizes = {
              sm: "px-3 py-1.5 text-sm",
              md: "px-4 py-2 text-base",
              lg: "px-6 py-3 text-lg",
            };
          
            return (
              <button
                className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${className}`}
                disabled={disabled || loading}
                {...props}
              >
                {loading && (
                  <svg
                    className="animate-spin -ml-1 mr-2 h-4 w-4"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                  >
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    />
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    />
                  </svg>
                )}
                {children}
              </button>
            );
          }
          ```

        - ğŸ“„ **Input.tsx**

          ğŸ“„ *File Path*: `.\src\components\common\Input.tsx`
          *Size*: 1332 bytes | *Modified*: 2026-01-16 17:15:32

          ```
          import { type InputHTMLAttributes, forwardRef } from "react";
          
          interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
            label?: string;
            error?: string;
          }
          
          export const Input = forwardRef<HTMLInputElement, InputProps>(
            ({ label, error, className = "", ...props }, ref) => {
              return (
                <div className="w-full">
                  {label && (
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      {label}
                    </label>
                  )}
                  <input
                    ref={ref}
                    className={`
                      w-full px-3 py-2 rounded-lg border transition-colors
                      bg-white dark:bg-gray-800
                      text-gray-900 dark:text-gray-100
                      placeholder-gray-400 dark:placeholder-gray-500
                      ${
                        error
                          ? "border-red-500 focus:ring-red-500 focus:border-red-500"
                          : "border-gray-300 dark:border-gray-600 focus:ring-blue-500 focus:border-blue-500"
                      }
                      focus:outline-none focus:ring-2 focus:ring-offset-0
                      disabled:opacity-50 disabled:cursor-not-allowed
                      ${className}
                    `}
                    {...props}
                  />
                  {error && (
                    <p className="mt-1 text-sm text-red-500">{error}</p>
                  )}
                </div>
              );
            }
          );
          
          Input.displayName = "Input";
          ```

        - ğŸ“„ **index.ts**

          ğŸ“„ *File Path*: `.\src\components\common\index.ts`
          *Size*: 68 bytes | *Modified*: 2026-01-16 17:15:39

          ```
          export { Button } from "./Button";
          export { Input } from "./Input";
          ```

      - ğŸ“ **icons/**
        - ğŸ“„ **index.tsx**

          ğŸ“„ *File Path*: `.\src\components\icons\index.tsx`
          *Size*: 12884 bytes | *Modified*: 2026-01-17 04:42:41

          ```
          import { type SVGProps } from "react";
          
          type IconProps = SVGProps<SVGSVGElement> & {
            size?: number;
          };
          
          const defaultProps: IconProps = {
            size: 20,
            strokeWidth: 1.5,
            stroke: "currentColor",
            fill: "none",
          };
          
          export function ChatIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25z"
                />
              </svg>
            );
          }
          
          export function WallIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M12 7.5h1.5m-1.5 3h1.5m-7.5 3h7.5m-7.5 3h7.5m3-9h3.375c.621 0 1.125.504 1.125 1.125V18a2.25 2.25 0 01-2.25 2.25M16.5 7.5V18a2.25 2.25 0 002.25 2.25M16.5 7.5V4.875c0-.621-.504-1.125-1.125-1.125H4.125C3.504 3.75 3 4.254 3 4.875V18a2.25 2.25 0 002.25 2.25h13.5M6 7.5h3v3H6v-3z"
                />
              </svg>
            );
          }
          
          export function FeedIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6a2.25 2.25 0 01-2.25-2.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25zM13.5 6a2.25 2.25 0 012.25-2.25H18A2.25 2.25 0 0120.25 6v2.25A2.25 2.25 0 0118 10.5h-2.25a2.25 2.25 0 01-2.25-2.25V6zM13.5 15.75a2.25 2.25 0 012.25-2.25H18a2.25 2.25 0 012.25 2.25V18A2.25 2.25 0 0118 20.25h-2.25A2.25 2.25 0 0113.5 18v-2.25z"
                />
              </svg>
            );
          }
          
          export function NetworkIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M12.75 3.03v.568c0 .334.148.65.405.864l1.068.89c.442.369.535 1.01.216 1.49l-.51.766a2.25 2.25 0 01-1.161.886l-.143.048a1.107 1.107 0 00-.57 1.664c.369.555.169 1.307-.427 1.605L9 13.125l.423 1.059a.956.956 0 01-1.652.928l-.679-.906a1.125 1.125 0 00-1.906.172L4.5 15.75l-.612.153M12.75 3.031a9 9 0 00-8.862 12.872M12.75 3.031a9 9 0 016.69 14.036m0 0l-.177-.529A2.25 2.25 0 0017.128 15H16.5l-.324-.324a1.453 1.453 0 00-2.328.377l-.036.073a1.586 1.586 0 01-.982.816l-.99.282c-.55.157-.894.702-.8 1.267l.073.438c.08.474.49.821.97.821.846 0 1.598.542 1.865 1.345l.215.643m5.276-3.67a9.012 9.012 0 01-5.276 3.67m0 0a9 9 0 01-10.275-4.835M15.75 9c0 .896-.393 1.7-1.016 2.25"
                />
              </svg>
            );
          }
          
          export function SettingsIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z"
                />
                <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
            );
          }
          
          export function LockIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z"
                />
              </svg>
            );
          }
          
          export function UnlockIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M13.5 10.5V6.75a4.5 4.5 0 119 0v3.75M3.75 21.75h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H3.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z"
                />
              </svg>
            );
          }
          
          export function PhoneIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M2.25 6.75c0 8.284 6.716 15 15 15h2.25a2.25 2.25 0 002.25-2.25v-1.372c0-.516-.351-.966-.852-1.091l-4.423-1.106c-.44-.11-.902.055-1.173.417l-.97 1.293c-.282.376-.769.542-1.21.38a12.035 12.035 0 01-7.143-7.143c-.162-.441.004-.928.38-1.21l1.293-.97c.363-.271.527-.734.417-1.173L6.963 3.102a1.125 1.125 0 00-1.091-.852H4.5A2.25 2.25 0 002.25 4.5v2.25z"
                />
              </svg>
            );
          }
          
          export function PhoneOffIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M15.536 8.464a5 5 0 010 7.072M12 9.5l-7.5 7.5M3 3l18 18M10.5 12.5a2.5 2.5 0 003.536 3.536l-3.536-3.536zM17.657 17.657A8.5 8.5 0 106.343 6.343"
                />
              </svg>
            );
          }
          
          export function SendIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5"
                />
              </svg>
            );
          }
          
          export function PlusIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
              </svg>
            );
          }
          
          export function SearchIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
                />
              </svg>
            );
          }
          
          export function UserIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z"
                />
              </svg>
            );
          }
          
          export function UsersIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M15 19.128a9.38 9.38 0 002.625.372 9.337 9.337 0 004.121-.952 4.125 4.125 0 00-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 018.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0111.964-3.07M12 6.375a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zm8.25 2.25a2.625 2.625 0 11-5.25 0 2.625 2.625 0 015.25 0z"
                />
              </svg>
            );
          }
          
          export function CheckIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
              </svg>
            );
          }
          
          export function XIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
              </svg>
            );
          }
          
          export function ChevronRightIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
              </svg>
            );
          }
          
          export function ChevronDownIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
              </svg>
            );
          }
          
          export function EllipsisIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M6.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM12.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM18.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"
                />
              </svg>
            );
          }
          
          export function HarborLogoIcon({ size = 24, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" fill="none" {...props}>
                <defs>
                  <linearGradient id="harbor-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stopColor="hsl(220, 91%, 54%)" />
                    <stop offset="100%" stopColor="hsl(262, 83%, 58%)" />
                  </linearGradient>
                </defs>
                <path
                  d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2z"
                  fill="url(#harbor-gradient)"
                />
                <path
                  d="M12 5.5c-2.5 0-4.5 2-4.5 4.5 0 3.5 4.5 8 4.5 8s4.5-4.5 4.5-8c0-2.5-2-4.5-4.5-4.5zm0 6a1.5 1.5 0 110-3 1.5 1.5 0 010 3z"
                  fill="white"
                />
              </svg>
            );
          }
          
          // Harbor icon - anchor/safe harbor symbol
          export function HarborIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" fill="none" {...props}>
                <path
                  d="M12 3C10.9 3 10 3.9 10 5C10 5.74 10.4 6.39 11 6.73V9H9.5C7.57 9 6 10.57 6 12.5V13C6 13.55 6.45 14 7 14C7.55 14 8 13.55 8 13V12.5C8 11.67 8.67 11 9.5 11H11V18.05C8.72 17.56 7 15.5 7 13H5C5 16.27 7.51 18.92 10.71 19.88C10.5 19.96 10.26 20 10 20C9.45 20 9 20.45 9 21C9 21.55 9.45 22 10 22H14C14.55 22 15 21.55 15 21C15 20.45 14.55 20 14 20C13.74 20 13.5 19.96 13.29 19.88C16.49 18.92 19 16.27 19 13H17C17 15.5 15.28 17.56 13 18.05V11H14.5C15.33 11 16 11.67 16 12.5V13C16 13.55 16.45 14 17 14C17.55 14 18 13.55 18 13V12.5C18 10.57 16.43 9 14.5 9H13V6.73C13.6 6.39 14 5.74 14 5C14 3.9 13.1 3 12 3Z"
                  fill="currentColor"
                />
              </svg>
            );
          }
          
          export function ShieldIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg width={size} height={size} viewBox="0 0 24 24" {...defaultProps} {...props}>
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M9 12.75L11.25 15 15 9.75m-3-7.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285z"
                />
              </svg>
            );
          }
          
          export function SpinnerIcon({ size = 20, ...props }: IconProps) {
            return (
              <svg
                width={size}
                height={size}
                viewBox="0 0 24 24"
                fill="none"
                className="animate-spin"
                {...props}
              >
                <circle
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  strokeWidth="3"
                  strokeOpacity="0.2"
                />
                <path
                  d="M12 2a10 10 0 019.95 9"
                  stroke="currentColor"
                  strokeWidth="3"
                  strokeLinecap="round"
                />
              </svg>
            );
          }
          ```

      - ğŸ“ **onboarding/**
        - ğŸ“„ **CreateIdentity.tsx**

          ğŸ“„ *File Path*: `.\src\components\onboarding\CreateIdentity.tsx`
          *Size*: 16004 bytes | *Modified*: 2026-01-17 04:41:09

          ```
          import { useState, type FormEvent } from "react";
          import { Button, Input } from "../common";
          import { useIdentityStore } from "../../stores";
          import { HarborIcon, UserIcon, LockIcon, ShieldIcon } from "../icons";
          
          export function CreateIdentity() {
            const { createIdentity, error, clearError } = useIdentityStore();
          
            const [displayName, setDisplayName] = useState("");
            const [passphrase, setPassphrase] = useState("");
            const [confirmPassphrase, setConfirmPassphrase] = useState("");
            const [bio, setBio] = useState("");
            const [loading, setLoading] = useState(false);
            const [localError, setLocalError] = useState<string | null>(null);
            const [step, setStep] = useState<1 | 2>(1);
          
            const handleNextStep = () => {
              setLocalError(null);
              if (!displayName.trim()) {
                setLocalError("Display name is required");
                return;
              }
              setStep(2);
            };
          
            const handleSubmit = async (e: FormEvent) => {
              e.preventDefault();
              clearError();
              setLocalError(null);
          
              if (passphrase.length < 8) {
                setLocalError("Passphrase must be at least 8 characters");
                return;
              }
          
              if (passphrase !== confirmPassphrase) {
                setLocalError("Passphrases do not match");
                return;
              }
          
              setLoading(true);
              try {
                await createIdentity({
                  displayName: displayName.trim(),
                  passphrase,
                  bio: bio.trim() || undefined,
                });
              } catch {
                // Error is handled by store
              } finally {
                setLoading(false);
              }
            };
          
            const displayError = localError || error;
          
            // Password strength indicator
            const getPasswordStrength = () => {
              if (!passphrase) return { level: 0, label: "", color: "" };
              if (passphrase.length < 8) return { level: 1, label: "Too short", color: "hsl(var(--harbor-error))" };
              if (passphrase.length < 12) return { level: 2, label: "Fair", color: "hsl(var(--harbor-warning))" };
              if (passphrase.length < 16) return { level: 3, label: "Good", color: "hsl(var(--harbor-success))" };
              return { level: 4, label: "Strong", color: "hsl(152 69% 50%)" };
            };
          
            const strength = getPasswordStrength();
          
            return (
              <div
                className="min-h-screen flex"
                style={{
                  background: "linear-gradient(135deg, hsl(220 91% 8%) 0%, hsl(262 60% 12%) 50%, hsl(220 91% 8%) 100%)",
                }}
              >
                {/* Left side - Branding */}
                <div className="hidden lg:flex flex-1 items-center justify-center p-12">
                  <div className="max-w-md">
                    {/* Logo */}
                    <div className="flex items-center gap-4 mb-8">
                      <div
                        className="w-14 h-14 rounded-2xl flex items-center justify-center"
                        style={{
                          background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                          boxShadow: "0 8px 32px hsl(var(--harbor-primary) / 0.4)",
                        }}
                      >
                        <HarborIcon className="w-8 h-8 text-white" />
                      </div>
                      <div>
                        <h1
                          className="text-2xl font-bold"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Harbor
                        </h1>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        >
                          Decentralized Chat
                        </p>
                      </div>
                    </div>
          
                    {/* Features */}
                    <div className="space-y-6">
                      <div className="flex gap-4">
                        <div
                          className="w-10 h-10 rounded-xl flex items-center justify-center flex-shrink-0"
                          style={{ background: "hsl(var(--harbor-primary) / 0.15)" }}
                        >
                          <ShieldIcon
                            className="w-5 h-5"
                            style={{ color: "hsl(var(--harbor-primary))" }}
                          />
                        </div>
                        <div>
                          <h3
                            className="font-semibold mb-1"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            End-to-End Encrypted
                          </h3>
                          <p
                            className="text-sm"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Your messages are encrypted before they leave your device. Only you and your contacts can read them.
                          </p>
                        </div>
                      </div>
          
                      <div className="flex gap-4">
                        <div
                          className="w-10 h-10 rounded-xl flex items-center justify-center flex-shrink-0"
                          style={{ background: "hsl(var(--harbor-accent) / 0.15)" }}
                        >
                          <LockIcon
                            className="w-5 h-5"
                            style={{ color: "hsl(var(--harbor-accent))" }}
                          />
                        </div>
                        <div>
                          <h3
                            className="font-semibold mb-1"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            Own Your Data
                          </h3>
                          <p
                            className="text-sm"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            No central servers, no data harvesting. Your identity and content stay on your device.
                          </p>
                        </div>
                      </div>
          
                      <div className="flex gap-4">
                        <div
                          className="w-10 h-10 rounded-xl flex items-center justify-center flex-shrink-0"
                          style={{ background: "hsl(var(--harbor-success) / 0.15)" }}
                        >
                          <UserIcon
                            className="w-5 h-5"
                            style={{ color: "hsl(var(--harbor-success))" }}
                          />
                        </div>
                        <div>
                          <h3
                            className="font-semibold mb-1"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            Peer-to-Peer
                          </h3>
                          <p
                            className="text-sm"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Connect directly with friends. No middlemen, no tracking, just secure communication.
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
          
                {/* Right side - Form */}
                <div className="flex-1 flex items-center justify-center p-6 lg:p-12">
                  <div className="w-full max-w-md">
                    <div
                      className="rounded-2xl p-8"
                      style={{
                        background: "hsl(var(--harbor-bg-elevated))",
                        border: "1px solid hsl(var(--harbor-border-subtle))",
                        boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.5)",
                      }}
                    >
                      {/* Mobile logo */}
                      <div className="lg:hidden flex items-center gap-3 mb-8">
                        <div
                          className="w-10 h-10 rounded-xl flex items-center justify-center"
                          style={{
                            background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                          }}
                        >
                          <HarborIcon className="w-6 h-6 text-white" />
                        </div>
                        <span
                          className="text-lg font-bold"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Harbor
                        </span>
                      </div>
          
                      {/* Step indicator */}
                      <div className="flex items-center gap-3 mb-8">
                        <div className="flex items-center gap-2">
                          <div
                            className="w-8 h-8 rounded-full flex items-center justify-center text-sm font-semibold"
                            style={{
                              background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                              color: "white",
                            }}
                          >
                            1
                          </div>
                          <span
                            className="text-sm font-medium"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            Profile
                          </span>
                        </div>
                        <div
                          className="flex-1 h-0.5 rounded"
                          style={{
                            background: step === 2
                              ? "linear-gradient(90deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))"
                              : "hsl(var(--harbor-surface-2))",
                          }}
                        />
                        <div className="flex items-center gap-2">
                          <div
                            className="w-8 h-8 rounded-full flex items-center justify-center text-sm font-semibold transition-all duration-300"
                            style={{
                              background: step === 2
                                ? "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))"
                                : "hsl(var(--harbor-surface-2))",
                              color: step === 2 ? "white" : "hsl(var(--harbor-text-tertiary))",
                            }}
                          >
                            2
                          </div>
                          <span
                            className="text-sm font-medium"
                            style={{
                              color: step === 2
                                ? "hsl(var(--harbor-text-primary))"
                                : "hsl(var(--harbor-text-tertiary))",
                            }}
                          >
                            Security
                          </span>
                        </div>
                      </div>
          
                      {/* Header */}
                      <div className="mb-6">
                        <h2
                          className="text-2xl font-bold mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          {step === 1 ? "Create Your Identity" : "Secure Your Keys"}
                        </h2>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          {step === 1
                            ? "Choose how others will see you on the network"
                            : "Your passphrase encrypts your private keys locally"}
                        </p>
                      </div>
          
                      {/* Form */}
                      <form onSubmit={step === 1 ? (e) => { e.preventDefault(); handleNextStep(); } : handleSubmit}>
                        {step === 1 ? (
                          <div className="space-y-4">
                            <Input
                              label="Display Name"
                              type="text"
                              value={displayName}
                              onChange={(e) => setDisplayName(e.target.value)}
                              placeholder="How others will see you"
                              autoFocus
                            />
          
                            <Input
                              label="Bio (optional)"
                              type="text"
                              value={bio}
                              onChange={(e) => setBio(e.target.value)}
                              placeholder="Tell others about yourself"
                            />
          
                            {displayError && (
                              <div
                                className="p-3 rounded-xl text-sm"
                                style={{
                                  background: "hsl(var(--harbor-error) / 0.1)",
                                  color: "hsl(var(--harbor-error))",
                                  border: "1px solid hsl(var(--harbor-error) / 0.2)",
                                }}
                              >
                                {displayError}
                              </div>
                            )}
          
                            <Button type="submit" className="w-full" size="lg">
                              Continue
                            </Button>
                          </div>
                        ) : (
                          <div className="space-y-4">
                            <div>
                              <Input
                                label="Passphrase"
                                type="password"
                                value={passphrase}
                                onChange={(e) => setPassphrase(e.target.value)}
                                placeholder="At least 8 characters"
                                autoFocus
                              />
                              {/* Password strength indicator */}
                              {passphrase && (
                                <div className="mt-2">
                                  <div className="flex gap-1 mb-1">
                                    {[1, 2, 3, 4].map((level) => (
                                      <div
                                        key={level}
                                        className="h-1 flex-1 rounded-full transition-colors duration-200"
                                        style={{
                                          background: level <= strength.level
                                            ? strength.color
                                            : "hsl(var(--harbor-surface-2))",
                                        }}
                                      />
                                    ))}
                                  </div>
                                  <p
                                    className="text-xs"
                                    style={{ color: strength.color }}
                                  >
                                    {strength.label}
                                  </p>
                                </div>
                              )}
                            </div>
          
                            <Input
                              label="Confirm Passphrase"
                              type="password"
                              value={confirmPassphrase}
                              onChange={(e) => setConfirmPassphrase(e.target.value)}
                              placeholder="Enter passphrase again"
                            />
          
                            {displayError && (
                              <div
                                className="p-3 rounded-xl text-sm"
                                style={{
                                  background: "hsl(var(--harbor-error) / 0.1)",
                                  color: "hsl(var(--harbor-error))",
                                  border: "1px solid hsl(var(--harbor-error) / 0.2)",
                                }}
                              >
                                {displayError}
                              </div>
                            )}
          
                            <div className="flex gap-3">
                              <Button
                                type="button"
                                variant="secondary"
                                className="flex-1"
                                size="lg"
                                onClick={() => setStep(1)}
                              >
                                Back
                              </Button>
                              <Button
                                type="submit"
                                className="flex-1"
                                size="lg"
                                loading={loading}
                              >
                                Create Identity
                              </Button>
                            </div>
                          </div>
                        )}
                      </form>
          
                      {/* Security notice */}
                      {step === 2 && (
                        <div
                          className="mt-6 p-4 rounded-xl"
                          style={{
                            background: "hsl(var(--harbor-warning) / 0.1)",
                            border: "1px solid hsl(var(--harbor-warning) / 0.2)",
                          }}
                        >
                          <div className="flex gap-3">
                            <ShieldIcon
                              className="w-5 h-5 flex-shrink-0 mt-0.5"
                              style={{ color: "hsl(var(--harbor-warning))" }}
                            />
                            <div>
                              <p
                                className="text-sm font-medium mb-1"
                                style={{ color: "hsl(var(--harbor-warning))" }}
                              >
                                Important
                              </p>
                              <p
                                className="text-sm"
                                style={{ color: "hsl(var(--harbor-text-secondary))" }}
                              >
                                Your passphrase encrypts your private keys. If you lose it, you cannot recover your identity. Store it safely!
                              </p>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            );
          }
          ```

        - ğŸ“„ **UnlockIdentity.tsx**

          ğŸ“„ *File Path*: `.\src\components\onboarding\UnlockIdentity.tsx`
          *Size*: 9714 bytes | *Modified*: 2026-01-17 04:42:02

          ```
          import { useState, type FormEvent } from "react";
          import { Button, Input } from "../common";
          import { useIdentityStore } from "../../stores";
          import { HarborIcon, LockIcon, UnlockIcon } from "../icons";
          
          export function UnlockIdentity() {
            const { state, unlock, error, clearError } = useIdentityStore();
          
            const [passphrase, setPassphrase] = useState("");
            const [loading, setLoading] = useState(false);
            const [showPassphrase, setShowPassphrase] = useState(false);
          
            const identity = state.status === "locked" ? state.identity : null;
          
            const handleSubmit = async (e: FormEvent) => {
              e.preventDefault();
              clearError();
          
              if (!passphrase) {
                return;
              }
          
              setLoading(true);
              try {
                await unlock(passphrase);
              } catch {
                // Error is handled by store
              } finally {
                setLoading(false);
              }
            };
          
            // Generate avatar initials
            const getInitials = (name: string) => {
              return name
                .split(" ")
                .map((n) => n[0])
                .join("")
                .toUpperCase()
                .slice(0, 2);
            };
          
            return (
              <div
                className="min-h-screen flex items-center justify-center p-6"
                style={{
                  background: "linear-gradient(135deg, hsl(220 91% 8%) 0%, hsl(262 60% 12%) 50%, hsl(220 91% 8%) 100%)",
                }}
              >
                <div className="w-full max-w-md">
                  {/* Card */}
                  <div
                    className="rounded-2xl p-8 relative overflow-hidden"
                    style={{
                      background: "hsl(var(--harbor-bg-elevated))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                      boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.5)",
                    }}
                  >
                    {/* Decorative gradient blob */}
                    <div
                      className="absolute -top-24 -right-24 w-48 h-48 rounded-full blur-3xl opacity-20"
                      style={{
                        background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                      }}
                    />
          
                    {/* Logo and branding */}
                    <div className="relative text-center mb-8">
                      <div className="flex items-center justify-center gap-3 mb-6">
                        <div
                          className="w-12 h-12 rounded-xl flex items-center justify-center"
                          style={{
                            background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                            boxShadow: "0 8px 24px hsl(var(--harbor-primary) / 0.4)",
                          }}
                        >
                          <HarborIcon className="w-7 h-7 text-white" />
                        </div>
                        <span
                          className="text-xl font-bold"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Harbor
                        </span>
                      </div>
          
                      {/* Lock icon */}
                      <div className="relative inline-block mb-4">
                        <div
                          className="w-20 h-20 rounded-full flex items-center justify-center mx-auto"
                          style={{
                            background: "hsl(var(--harbor-surface-1))",
                            border: "2px solid hsl(var(--harbor-border-subtle))",
                          }}
                        >
                          <LockIcon
                            className="w-8 h-8"
                            style={{ color: "hsl(var(--harbor-primary))" }}
                          />
                        </div>
                      </div>
          
                      <h1
                        className="text-2xl font-bold mb-2"
                        style={{ color: "hsl(var(--harbor-text-primary))" }}
                      >
                        Welcome Back
                      </h1>
                      <p
                        className="text-sm"
                        style={{ color: "hsl(var(--harbor-text-secondary))" }}
                      >
                        Enter your passphrase to unlock your identity
                      </p>
                    </div>
          
                    {/* User info card */}
                    {identity && (
                      <div
                        className="relative mb-6 p-4 rounded-xl"
                        style={{
                          background: "hsl(var(--harbor-surface-1))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <div className="flex items-center gap-4">
                          {/* Avatar */}
                          <div
                            className="w-14 h-14 rounded-full flex items-center justify-center text-lg font-semibold text-white flex-shrink-0"
                            style={{
                              background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                            }}
                          >
                            {identity.avatarHash ? (
                              <img
                                src={`/media/${identity.avatarHash}`}
                                alt=""
                                className="w-full h-full rounded-full object-cover"
                              />
                            ) : (
                              getInitials(identity.displayName)
                            )}
                          </div>
          
                          {/* Info */}
                          <div className="flex-1 min-w-0">
                            <p
                              className="font-semibold truncate"
                              style={{ color: "hsl(var(--harbor-text-primary))" }}
                            >
                              {identity.displayName}
                            </p>
                            <p
                              className="text-xs truncate font-mono"
                              style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                            >
                              {identity.peerId.slice(0, 12)}...{identity.peerId.slice(-8)}
                            </p>
                          </div>
                        </div>
                      </div>
                    )}
          
                    {/* Form */}
                    <form onSubmit={handleSubmit} className="relative space-y-4">
                      <div className="relative">
                        <Input
                          label="Passphrase"
                          type={showPassphrase ? "text" : "password"}
                          value={passphrase}
                          onChange={(e) => setPassphrase(e.target.value)}
                          placeholder="Enter your passphrase"
                          autoFocus
                        />
                        {/* Show/hide toggle */}
                        <button
                          type="button"
                          className="absolute right-3 top-8 p-1.5 rounded-lg transition-colors duration-200"
                          style={{
                            color: "hsl(var(--harbor-text-tertiary))",
                            background: showPassphrase ? "hsl(var(--harbor-surface-2))" : "transparent",
                          }}
                          onClick={() => setShowPassphrase(!showPassphrase)}
                        >
                          {showPassphrase ? (
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                            </svg>
                          ) : (
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                            </svg>
                          )}
                        </button>
                      </div>
          
                      {error && (
                        <div
                          className="p-3 rounded-xl text-sm flex items-center gap-2"
                          style={{
                            background: "hsl(var(--harbor-error) / 0.1)",
                            color: "hsl(var(--harbor-error))",
                            border: "1px solid hsl(var(--harbor-error) / 0.2)",
                          }}
                        >
                          <svg className="w-4 h-4 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                          </svg>
                          {error}
                        </div>
                      )}
          
                      <Button
                        type="submit"
                        className="w-full"
                        size="lg"
                        loading={loading}
                      >
                        <UnlockIcon className="w-5 h-5 mr-2" />
                        Unlock
                      </Button>
                    </form>
          
                    {/* Security tip */}
                    <div
                      className="relative mt-6 p-4 rounded-xl text-center"
                      style={{
                        background: "hsl(var(--harbor-surface-1))",
                      }}
                    >
                      <p
                        className="text-xs"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      >
                        Your identity is encrypted and stored locally.
                        <br />
                        <span style={{ color: "hsl(var(--harbor-text-secondary))" }}>
                          Only you can access it with your passphrase.
                        </span>
                      </p>
                    </div>
                  </div>
          
                  {/* Footer */}
                  <p
                    className="text-center mt-6 text-xs"
                    style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                  >
                    Need help? Check the{" "}
                    <a
                      href="#"
                      className="underline underline-offset-2 transition-colors duration-200"
                      style={{ color: "hsl(var(--harbor-primary))" }}
                    >
                      documentation
                    </a>
                  </p>
                </div>
              </div>
            );
          }
          ```

        - ğŸ“„ **index.ts**

          ğŸ“„ *File Path*: `.\src\components\onboarding\index.ts`
          *Size*: 102 bytes | *Modified*: 2026-01-16 17:16:49

          ```
          export { CreateIdentity } from "./CreateIdentity";
          export { UnlockIdentity } from "./UnlockIdentity";
          ```

    - ğŸ“ **hooks/**
      - ğŸ“„ **index.ts**

        ğŸ“„ *File Path*: `.\src\hooks\index.ts`
        *Size*: 52 bytes | *Modified*: 2026-01-17 11:00:51

        ```
        export { useTauriEvents } from "./useTauriEvents";
        ```

      - ğŸ“„ **useTauriEvents.ts**

        ğŸ“„ *File Path*: `.\src\hooks\useTauriEvents.ts`
        *Size*: 3885 bytes | *Modified*: 2026-01-18 10:17:38

        ```
        import { useEffect, useRef } from "react";
        import { listen, UnlistenFn } from "@tauri-apps/api/event";
        import toast from "react-hot-toast";
        import type { NetworkEvent } from "../types";
        import { useNetworkStore, useContactsStore, useMessagingStore } from "../stores";
        
        /**
         * Hook to listen to Tauri events from the Rust backend.
         * Should be called once at the app root level.
         */
        export function useTauriEvents() {
          const unlistenersRef = useRef<UnlistenFn[]>([]);
          const { refreshPeers, refreshStats } = useNetworkStore();
          const { refreshContacts } = useContactsStore();
        
          useEffect(() => {
            async function setupListeners() {
              // Listen to network events
              const unlistenNetwork = await listen<NetworkEvent>(
                "harbor:network",
                (event) => {
                  console.log("[TauriEvent] harbor:network:", event.payload);
                  handleNetworkEvent(event.payload);
                }
              );
              unlistenersRef.current.push(unlistenNetwork);
        
              // Future: Listen to message events
              // const unlistenMessage = await listen<MessageEvent>(
              //   "harbor:message",
              //   (event) => handleMessageEvent(event.payload)
              // );
              // unlistenersRef.current.push(unlistenMessage);
            }
        
            function handleNetworkEvent(event: NetworkEvent) {
              switch (event.type) {
                case "peer_connected":
                  console.log(`[Network] Peer connected: ${event.peerId}`);
                  // Refresh the full peer list to get updated info
                  refreshPeers();
                  refreshStats();
                  break;
        
                case "peer_disconnected":
                  console.log(`[Network] Peer disconnected: ${event.peerId}`);
                  refreshPeers();
                  refreshStats();
                  break;
        
                case "peer_discovered":
                  console.log(`[Network] Peer discovered: ${event.peerId}`);
                  refreshPeers();
                  break;
        
                case "peer_expired":
                  console.log(`[Network] Peer expired: ${event.peerId}`);
                  refreshPeers();
                  break;
        
                case "message_received":
                  console.log(
                    `[Network] Message received from ${event.peerId} via ${event.protocol}`
                  );
                  // Use getState() to avoid stale closures - call functions directly from the store
                  const messagingState = useMessagingStore.getState();
                  // Refresh conversations to show new message
                  messagingState.loadConversations();
                  // Reload messages for the active conversation
                  const activeConv = messagingState.activeConversation;
                  console.log(`[Network] Active conversation: ${activeConv}, message from: ${event.peerId}`);
                  if (activeConv) {
                    console.log(`[Network] Reloading messages for active conversation: ${activeConv}`);
                    messagingState.loadMessages(activeConv);
                  }
                  // Also refresh contacts in case this is from a new contact
                  refreshContacts();
                  break;
        
                case "listening_on":
                  console.log(`[Network] Listening on: ${event.address}`);
                  break;
        
                case "external_address_discovered":
                  console.log(`[Network] External address: ${event.address}`);
                  break;
        
                case "status_changed":
                  console.log(`[Network] Status changed: ${event.status}`);
                  break;
        
                case "contact_added":
                  console.log(`[Network] Contact added: ${event.displayName} (${event.peerId})`);
                  refreshContacts();
                  toast.success(`Added ${event.displayName} to contacts!`);
                  break;
              }
            }
        
            setupListeners();
        
            // Cleanup on unmount
            return () => {
              unlistenersRef.current.forEach((unlisten) => unlisten());
              unlistenersRef.current = [];
            };
          }, [refreshPeers, refreshStats, refreshContacts]);
        }
        ```

    - ğŸ“„ **main.tsx**

      ğŸ“„ *File Path*: `.\src\main.tsx`
      *Size*: 259 bytes | *Modified*: 2026-01-16 17:20:21

      ```
      import React from "react";
      import ReactDOM from "react-dom/client";
      import App from "./App";
      import "./App.css";
      
      ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
        <React.StrictMode>
          <App />
        </React.StrictMode>,
      );
      ```

    - ğŸ“ **pages/**
      - ğŸ“„ **Chat.tsx**

        ğŸ“„ *File Path*: `.\src\pages\Chat.tsx`
        *Size*: 21424 bytes | *Modified*: 2026-01-18 10:09:15

        ```
        import { useState, useRef, useEffect, KeyboardEvent } from "react";
        import { useNavigate } from "react-router-dom";
        import toast from "react-hot-toast";
        import {
          ChatIcon,
          SearchIcon,
          PlusIcon,
          SendIcon,
          PhoneIcon,
          EllipsisIcon,
        } from "../components/icons";
        import { useMockPeersStore, useContactsStore, useMessagingStore } from "../stores";
        
        // Back arrow icon
        function BackIcon({ className }: { className?: string }) {
          return (
            <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
          );
        }
        
        // Unified conversation type for both real and mock
        interface UnifiedConversation {
          id: string;
          peerId: string;
          name: string;
          online: boolean;
          avatarGradient: string;
          lastMessage: string;
          timestamp: Date;
          unread: number;
          isReal: boolean; // true = real contact, false = mock
        }
        
        // Generate consistent avatar color from peer ID
        function getContactColor(peerId: string): string {
          const colors = [
            "linear-gradient(135deg, hsl(220 91% 54%), hsl(262 83% 58%))",
            "linear-gradient(135deg, hsl(262 83% 58%), hsl(330 81% 60%))",
            "linear-gradient(135deg, hsl(152 69% 40%), hsl(180 70% 45%))",
            "linear-gradient(135deg, hsl(36 90% 55%), hsl(15 80% 55%))",
            "linear-gradient(135deg, hsl(200 80% 50%), hsl(220 91% 54%))",
            "linear-gradient(135deg, hsl(340 75% 55%), hsl(10 80% 60%))",
          ];
          let hash = 0;
          for (let i = 0; i < peerId.length; i++) {
            hash = peerId.charCodeAt(i) + ((hash << 5) - hash);
          }
          return colors[Math.abs(hash) % colors.length];
        }
        
        export function ChatPage() {
          const navigate = useNavigate();
        
          // Mock peers store (for demo contacts)
          const { conversations: mockConversations, sendMessage: sendMockMessage } = useMockPeersStore();
        
          // Real contacts and messaging
          const { contacts, loadContacts } = useContactsStore();
          const {
            conversations: realConversations,
            messages: realMessages,
            loadConversations,
            loadMessages,
            sendMessage: sendRealMessage,
            setActiveConversation
          } = useMessagingStore();
        
          const [selectedConversation, setSelectedConversation] = useState<string | null>(null);
        
          // Keep the store's activeConversation in sync with local selectedConversation
          // This is needed for the event handler to know which conversation to refresh
          useEffect(() => {
            // Find if selected conversation is a real contact
            const isReal = selectedConversation?.startsWith("real-");
            if (isReal && selectedConversation) {
              const peerId = selectedConversation.replace("real-", "");
              setActiveConversation(peerId);
            } else {
              setActiveConversation(null);
            }
          }, [selectedConversation, setActiveConversation]);
        
          const [searchQuery, setSearchQuery] = useState("");
          const [messageInput, setMessageInput] = useState("");
          const messagesEndRef = useRef<HTMLDivElement>(null);
          const inputRef = useRef<HTMLTextAreaElement>(null);
        
          // Load real contacts and conversations on mount
          useEffect(() => {
            loadContacts();
            loadConversations();
          }, [loadContacts, loadConversations]);
        
          // Build unified conversation list
          const unifiedConversations: UnifiedConversation[] = [
            // Real contacts (with or without conversations)
            ...contacts.map((contact): UnifiedConversation => {
              const realConv = realConversations.find(c => c.peerId === contact.peerId);
              return {
                id: `real-${contact.peerId}`,
                peerId: contact.peerId,
                name: contact.displayName,
                online: true, // Assume online for now - would need presence tracking
                avatarGradient: getContactColor(contact.peerId),
                lastMessage: realConv ? "Tap to view messages" : "Start a conversation",
                timestamp: realConv ? new Date(realConv.lastMessageAt * 1000) : new Date(contact.addedAt * 1000),
                unread: realConv?.unreadCount || 0,
                isReal: true,
              };
            }),
            // Mock conversations
            ...mockConversations.map((conv): UnifiedConversation => ({
              id: conv.id,
              peerId: conv.peerId,
              name: conv.name,
              online: conv.online,
              avatarGradient: conv.avatarGradient,
              lastMessage: conv.lastMessage,
              timestamp: conv.timestamp,
              unread: conv.unread,
              isReal: false,
            })),
          ];
        
          const scrollToBottom = () => {
            messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
          };
        
          // Get selected conversation from unified list
          const selectedConv = unifiedConversations.find((c) => c.id === selectedConversation);
        
          // Get messages for current conversation
          const currentMessages = selectedConv
            ? selectedConv.isReal
              ? realMessages[selectedConv.peerId] || []
              : mockConversations.find((c) => c.id === selectedConversation)?.messages || []
            : [];
        
          // Load messages when selecting a real conversation
          useEffect(() => {
            if (selectedConv?.isReal) {
              loadMessages(selectedConv.peerId);
            }
          }, [selectedConv?.peerId, selectedConv?.isReal, loadMessages]);
        
          // Scroll to bottom when messages change
          useEffect(() => {
            scrollToBottom();
          }, [currentMessages.length]);
        
          const formatTime = (date: Date) => {
            const now = new Date();
            const diff = now.getTime() - date.getTime();
            const mins = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
        
            if (mins < 1) return "now";
            if (mins < 60) return `${mins}m`;
            if (hours < 24) return `${hours}h`;
            return `${days}d`;
          };
        
          const getInitials = (name: string) => {
            return name
              .split(" ")
              .map((n) => n[0])
              .join("")
              .toUpperCase()
              .slice(0, 2);
          };
        
          const filteredConversations = unifiedConversations.filter((c) =>
            c.name.toLowerCase().includes(searchQuery.toLowerCase())
          );
        
          const handleSendMessage = async () => {
            if (!messageInput.trim() || !selectedConversation || !selectedConv) return;
        
            const content = messageInput.trim();
            setMessageInput("");
            inputRef.current?.focus();
        
            if (selectedConv.isReal) {
              // Send via real P2P messaging
              try {
                await sendRealMessage(selectedConv.peerId, content);
                // Reload messages to show the sent message
                loadMessages(selectedConv.peerId);
              } catch (error) {
                console.error("Failed to send message:", error);
                toast.error("Failed to send message");
              }
            } else {
              // Send via mock store (triggers auto-reply for online peers)
              sendMockMessage(selectedConversation, content);
            }
          };
        
          const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
            // Enter to send, Shift+Enter for new line
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              handleSendMessage();
            }
          };
        
          const handleCall = () => {
            if (selectedConv) {
              if (selectedConv.online) {
                toast(`Calling ${selectedConv.name}...`, {
                  icon: "ğŸ“",
                  duration: 3000,
                });
              } else {
                toast.error(`${selectedConv.name} is offline`);
              }
            }
          };
        
          const handleNewConversation = () => {
            toast("Select a contact from Network to start a conversation", {
              icon: "ğŸ’¬",
            });
          };
        
          const handleConversationMenu = () => {
            if (selectedConv) {
              toast(`Options for ${selectedConv.name}`, {
                icon: "ğŸ“‹",
              });
            }
          };
        
          // Conversation list view (when no conversation selected)
          if (!selectedConversation) {
            return (
              <div
                className="h-full flex flex-col"
                style={{ background: "hsl(var(--harbor-bg-primary))" }}
              >
                {/* Header */}
                <div
                  className="p-4 border-b flex items-center justify-between"
                  style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                >
                  <div className="flex items-center gap-3">
                    <button
                      onClick={() => navigate(-1)}
                      className="p-2 -ml-2 rounded-lg transition-colors"
                      style={{ color: "hsl(var(--harbor-text-secondary))" }}
                    >
                      <BackIcon className="w-5 h-5" />
                    </button>
                    <h2
                      className="text-lg font-bold"
                      style={{ color: "hsl(var(--harbor-text-primary))" }}
                    >
                      Messages
                    </h2>
                  </div>
                  <button
                    onClick={handleNewConversation}
                    className="p-2 rounded-lg transition-colors duration-200"
                    style={{
                      background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                      color: "white",
                    }}
                  >
                    <PlusIcon className="w-5 h-5" />
                  </button>
                </div>
        
                {/* Search */}
                <div className="p-4">
                  <div className="relative">
                    <SearchIcon
                      className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4"
                      style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                    />
                    <input
                      type="text"
                      placeholder="Search conversations..."
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      className="w-full pl-10 pr-4 py-3 rounded-lg text-sm"
                      style={{
                        background: "hsl(var(--harbor-surface-1))",
                        border: "1px solid hsl(var(--harbor-border-subtle))",
                        color: "hsl(var(--harbor-text-primary))",
                      }}
                    />
                  </div>
                </div>
        
                {/* Conversation list */}
                <div className="flex-1 overflow-y-auto px-2">
                  {filteredConversations.length === 0 ? (
                    <div className="text-center py-12">
                      <ChatIcon
                        className="w-16 h-16 mx-auto mb-4"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      />
                      <p
                        className="text-sm"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      >
                        No conversations found
                      </p>
                    </div>
                  ) : (
                    <div className="space-y-1">
                      {filteredConversations.map((conversation) => (
                        <button
                          key={conversation.id}
                          onClick={() => setSelectedConversation(conversation.id)}
                          className="w-full flex items-center gap-3 p-3 rounded-lg text-left transition-all duration-200"
                          style={{
                            background: "transparent",
                          }}
                        >
                          {/* Avatar */}
                          <div className="relative flex-shrink-0">
                            <div
                              className="w-12 h-12 rounded-full flex items-center justify-center text-sm font-semibold text-white"
                              style={{
                                background: conversation.avatarGradient,
                              }}
                            >
                              {getInitials(conversation.name)}
                            </div>
                            {conversation.online && (
                              <div
                                className="absolute -bottom-0.5 -right-0.5 w-3.5 h-3.5 rounded-full border-2"
                                style={{
                                  background: "hsl(var(--harbor-success))",
                                  borderColor: "hsl(var(--harbor-bg-primary))",
                                }}
                              />
                            )}
                          </div>
        
                          {/* Info */}
                          <div className="flex-1 min-w-0">
                            <div className="flex items-center justify-between mb-0.5">
                              <div className="flex items-center gap-2 min-w-0">
                                <p
                                  className="font-semibold text-sm truncate"
                                  style={{ color: "hsl(var(--harbor-text-primary))" }}
                                >
                                  {conversation.name}
                                </p>
                                {conversation.isReal ? (
                                  <span
                                    className="text-[10px] px-1.5 py-0.5 rounded flex-shrink-0"
                                    style={{
                                      background: "hsl(var(--harbor-success) / 0.15)",
                                      color: "hsl(var(--harbor-success))",
                                    }}
                                  >
                                    P2P
                                  </span>
                                ) : (
                                  <span
                                    className="text-[10px] px-1.5 py-0.5 rounded flex-shrink-0"
                                    style={{
                                      background: "hsl(var(--harbor-text-tertiary) / 0.15)",
                                      color: "hsl(var(--harbor-text-tertiary))",
                                    }}
                                  >
                                    Demo
                                  </span>
                                )}
                              </div>
                              <span
                                className="text-xs flex-shrink-0 ml-2"
                                style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                              >
                                {formatTime(conversation.timestamp)}
                              </span>
                            </div>
                            <div className="flex items-center justify-between">
                              <p
                                className="text-sm truncate"
                                style={{ color: "hsl(var(--harbor-text-secondary))" }}
                              >
                                {conversation.lastMessage}
                              </p>
                              {conversation.unread > 0 && (
                                <span
                                  className="ml-2 px-2 py-0.5 rounded-full text-xs font-semibold flex-shrink-0"
                                  style={{
                                    background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                                    color: "white",
                                  }}
                                >
                                  {conversation.unread}
                                </span>
                              )}
                            </div>
                          </div>
                        </button>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            );
          }
        
          // Chat view (when conversation selected)
          return (
            <div
              className="h-full flex flex-col"
              style={{ background: "hsl(var(--harbor-bg-primary))" }}
            >
              {/* Chat header */}
              <header
                className="px-4 py-3 border-b flex items-center justify-between flex-shrink-0"
                style={{
                  borderColor: "hsl(var(--harbor-border-subtle))",
                  background: "hsl(var(--harbor-bg-elevated))",
                }}
              >
                <div className="flex items-center gap-3">
                  <button
                    onClick={() => setSelectedConversation(null)}
                    className="p-2 -ml-2 rounded-lg transition-colors"
                    style={{ color: "hsl(var(--harbor-text-secondary))" }}
                  >
                    <BackIcon className="w-5 h-5" />
                  </button>
                  <div className="relative">
                    <div
                      className="w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold text-white"
                      style={{
                        background: selectedConv!.avatarGradient,
                      }}
                    >
                      {getInitials(selectedConv!.name)}
                    </div>
                    {selectedConv!.online && (
                      <div
                        className="absolute -bottom-0.5 -right-0.5 w-3 h-3 rounded-full border-2"
                        style={{
                          background: "hsl(var(--harbor-success))",
                          borderColor: "hsl(var(--harbor-bg-elevated))",
                        }}
                      />
                    )}
                  </div>
                  <div>
                    <p
                      className="font-semibold"
                      style={{ color: "hsl(var(--harbor-text-primary))" }}
                    >
                      {selectedConv!.name}
                    </p>
                    <p
                      className="text-xs"
                      style={{
                        color: selectedConv!.online
                          ? "hsl(var(--harbor-success))"
                          : "hsl(var(--harbor-text-tertiary))",
                      }}
                    >
                      {selectedConv!.isReal
                        ? (selectedConv!.online ? "Online" : "Offline")
                        : (selectedConv!.online ? "Online - will reply automatically" : "Offline")}
                    </p>
                  </div>
                </div>
        
                <div className="flex items-center gap-2">
                  <button
                    onClick={handleCall}
                    className="p-2 rounded-lg transition-colors duration-200"
                    style={{
                      background: "hsl(var(--harbor-success) / 0.15)",
                      color: "hsl(var(--harbor-success))",
                    }}
                  >
                    <PhoneIcon className="w-5 h-5" />
                  </button>
                  <button
                    onClick={handleConversationMenu}
                    className="p-2 rounded-lg transition-colors duration-200"
                    style={{
                      background: "hsl(var(--harbor-surface-1))",
                      color: "hsl(var(--harbor-text-secondary))",
                    }}
                  >
                    <EllipsisIcon className="w-5 h-5" />
                  </button>
                </div>
              </header>
        
              {/* Messages */}
              <div className="flex-1 overflow-y-auto p-4">
                <div className="max-w-3xl mx-auto space-y-3">
                  {currentMessages.map((message) => {
                    // Handle both real messages (Message type) and mock messages (MockMessage type)
                    const isMine = 'isMine' in message ? message.isMine : message.isOutgoing;
                    const timestamp = 'timestamp' in message && message.timestamp instanceof Date
                      ? message.timestamp
                      : new Date(('sentAt' in message ? message.sentAt : 0) * 1000);
                    const content = message.content;
                    const id = 'id' in message ? message.id : message.messageId;
        
                    return (
                      <div
                        key={id}
                        className={`flex ${isMine ? "justify-end" : "justify-start"}`}
                      >
                        <div
                          className="max-w-[75%] px-4 py-2.5 rounded-2xl"
                          style={{
                            background: isMine
                              ? "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))"
                              : "hsl(var(--harbor-surface-1))",
                            color: isMine ? "white" : "hsl(var(--harbor-text-primary))",
                            borderBottomRightRadius: isMine ? "4px" : "16px",
                            borderBottomLeftRadius: isMine ? "16px" : "4px",
                          }}
                        >
                          <p className="text-sm whitespace-pre-wrap">{content}</p>
                          <p
                            className="text-xs mt-1 text-right"
                            style={{
                              color: isMine
                                ? "rgba(255,255,255,0.7)"
                                : "hsl(var(--harbor-text-tertiary))",
                            }}
                          >
                            {timestamp.toLocaleTimeString([], {
                              hour: "2-digit",
                              minute: "2-digit",
                            })}
                          </p>
                        </div>
                      </div>
                    );
                  })}
                  <div ref={messagesEndRef} />
                </div>
              </div>
        
              {/* Message input */}
              <div
                className="p-4 border-t"
                style={{
                  borderColor: "hsl(var(--harbor-border-subtle))",
                  background: "hsl(var(--harbor-bg-elevated))",
                }}
              >
                <div className="max-w-3xl mx-auto flex items-end gap-3">
                  <textarea
                    ref={inputRef}
                    placeholder="Type a message..."
                    value={messageInput}
                    onChange={(e) => setMessageInput(e.target.value)}
                    onKeyDown={handleKeyDown}
                    rows={1}
                    className="flex-1 px-4 py-3 rounded-lg text-sm resize-none max-h-32"
                    style={{
                      background: "hsl(var(--harbor-surface-1))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                      color: "hsl(var(--harbor-text-primary))",
                    }}
                  />
                  <button
                    onClick={handleSendMessage}
                    disabled={!messageInput.trim()}
                    className="p-3 rounded-lg transition-all duration-200 flex-shrink-0"
                    style={{
                      background: messageInput.trim()
                        ? "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))"
                        : "hsl(var(--harbor-surface-2))",
                      color: messageInput.trim() ? "white" : "hsl(var(--harbor-text-tertiary))",
                      boxShadow: messageInput.trim()
                        ? "0 4px 12px hsl(var(--harbor-primary) / 0.3)"
                        : "none",
                    }}
                  >
                    <SendIcon className="w-5 h-5" />
                  </button>
                </div>
                <p
                  className="text-xs mt-2 text-center"
                  style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                >
                  Press Enter to send â€¢ {selectedConv?.isReal
                    ? "End-to-end encrypted"
                    : (selectedConv?.online ? "Demo mode - auto replies enabled" : "Demo peer is offline")}
                </p>
              </div>
            </div>
          );
        }
        ```

      - ğŸ“„ **Feed.tsx**

        ğŸ“„ *File Path*: `.\src\pages\Feed.tsx`
        *Size*: 15183 bytes | *Modified*: 2026-01-17 12:59:02

        ```
        import { useState, useMemo, useEffect } from "react";
        import toast from "react-hot-toast";
        import { FeedIcon, EllipsisIcon } from "../components/icons";
        import { useMockPeersStore, useFeedStore, useContactsStore } from "../stores";
        import type { FeedItem } from "../types";
        
        // Unified post type for both real and mock posts
        interface UnifiedPost {
          id: string;
          content: string;
          timestamp: Date;
          likes: number;
          comments: number;
          likedByUser: boolean;
          author: {
            peerId: string;
            name: string;
            avatarGradient: string;
          };
          isReal: boolean;
        }
        
        // Generate consistent avatar color from peer ID
        function getContactColor(peerId: string): string {
          const colors = [
            "linear-gradient(135deg, hsl(220 91% 54%), hsl(262 83% 58%))",
            "linear-gradient(135deg, hsl(262 83% 58%), hsl(330 81% 60%))",
            "linear-gradient(135deg, hsl(152 69% 40%), hsl(180 70% 45%))",
            "linear-gradient(135deg, hsl(36 90% 55%), hsl(15 80% 55%))",
            "linear-gradient(135deg, hsl(200 80% 50%), hsl(220 91% 54%))",
            "linear-gradient(135deg, hsl(340 75% 55%), hsl(10 80% 60%))",
          ];
          let hash = 0;
          for (let i = 0; i < peerId.length; i++) {
            hash = peerId.charCodeAt(i) + ((hash << 5) - hash);
          }
          return colors[Math.abs(hash) % colors.length];
        }
        
        export function FeedPage() {
          const { getAllFeedPosts, likePost, toggleSavePost, isPostSaved, peers } = useMockPeersStore();
          const { feedItems, loadFeed, refreshFeed } = useFeedStore();
          const { contacts, loadContacts } = useContactsStore();
          const [isRefreshing, setIsRefreshing] = useState(false);
        
          // Load real feed and contacts on mount
          useEffect(() => {
            loadFeed();
            loadContacts();
          }, [loadFeed, loadContacts]);
        
          // Get mock feed posts
          const mockPosts = useMemo(() => getAllFeedPosts(), [peers]);
        
          // Convert real feed items to unified format
          const realPosts: UnifiedPost[] = useMemo(() => {
            return feedItems.map((item: FeedItem): UnifiedPost => {
              const contact = contacts.find(c => c.peerId === item.authorPeerId);
              return {
                id: `real-${item.postId}`,
                content: item.contentText || "",
                timestamp: new Date(item.createdAt * 1000),
                likes: 0, // Real posts don't have like counts yet
                comments: 0,
                likedByUser: false,
                author: {
                  peerId: item.authorPeerId,
                  name: item.authorDisplayName || contact?.displayName || "Unknown",
                  avatarGradient: getContactColor(item.authorPeerId),
                },
                isReal: true,
              };
            });
          }, [feedItems, contacts]);
        
          // Convert mock posts to unified format
          const mockUnifiedPosts: UnifiedPost[] = useMemo(() => {
            return mockPosts.map((post): UnifiedPost => ({
              id: post.id,
              content: post.content,
              timestamp: post.timestamp,
              likes: post.likes,
              comments: post.comments,
              likedByUser: post.likedByUser,
              author: {
                peerId: post.author.peerId,
                name: post.author.name,
                avatarGradient: post.author.avatarGradient,
              },
              isReal: false,
            }));
          }, [mockPosts]);
        
          // Combine and sort all posts by timestamp (newest first)
          const posts: UnifiedPost[] = useMemo(() => {
            return [...realPosts, ...mockUnifiedPosts].sort(
              (a, b) => b.timestamp.getTime() - a.timestamp.getTime()
            );
          }, [realPosts, mockUnifiedPosts]);
        
          const formatDate = (date: Date) => {
            const now = new Date();
            const diff = now.getTime() - date.getTime();
            const mins = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
        
            if (mins < 1) return "Just now";
            if (mins < 60) return `${mins}m ago`;
            if (hours < 24) return `${hours}h ago`;
            if (days < 7) return `${days}d ago`;
            return date.toLocaleDateString("en-US", {
              month: "short",
              day: "numeric",
              year: date.getFullYear() !== now.getFullYear() ? "numeric" : undefined
            });
          };
        
          const getInitials = (name: string) => {
            return name
              .split(" ")
              .map((n) => n[0])
              .join("")
              .toUpperCase()
              .slice(0, 2);
          };
        
          const handleRefresh = async () => {
            setIsRefreshing(true);
            try {
              await refreshFeed();
              toast.success("Feed refreshed!");
            } catch (error) {
              toast.error("Failed to refresh feed");
            } finally {
              setIsRefreshing(false);
            }
          };
        
          const handleLike = (post: UnifiedPost) => {
            if (post.isReal) {
              // Real posts don't support likes yet
              toast("Likes for P2P posts coming soon!", { icon: "ğŸ’œ" });
            } else {
              likePost(post.author.peerId, post.id);
              if (!post.likedByUser) {
                toast.success("Post liked!");
              }
            }
          };
        
          const handleSave = (post: UnifiedPost) => {
            if (post.isReal) {
              // Real posts don't support saving yet
              toast("Saving P2P posts coming soon!", { icon: "ğŸ”–" });
            } else {
              const wasSaved = isPostSaved(post.author.peerId, post.id);
              toggleSavePost(post.author.peerId, post.id);
              if (!wasSaved) {
                toast.success("Post saved to your collection!");
              } else {
                toast.success("Post removed from saved");
              }
            }
          };
        
          const isSaved = (post: UnifiedPost): boolean => {
            if (post.isReal) return false;
            return isPostSaved(post.author.peerId, post.id);
          };
        
          const handlePostMenu = (authorName: string) => {
            toast(`Post options for ${authorName}'s post`, {
              icon: "ğŸ“‹",
            });
          };
        
          return (
            <div
              className="h-full flex flex-col"
              style={{ background: "hsl(var(--harbor-bg-primary))" }}
            >
              {/* Header */}
              <header
                className="px-6 py-4 border-b flex-shrink-0"
                style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
              >
                <div className="max-w-3xl mx-auto flex items-center justify-between">
                  <div>
                    <h1
                      className="text-2xl font-bold"
                      style={{ color: "hsl(var(--harbor-text-primary))" }}
                    >
                      Feed
                    </h1>
                    <p
                      className="text-sm mt-1"
                      style={{ color: "hsl(var(--harbor-text-secondary))" }}
                    >
                      Updates from your contacts
                    </p>
                  </div>
        
                  <button
                    onClick={handleRefresh}
                    disabled={isRefreshing}
                    className="px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200"
                    style={{
                      background: "hsl(var(--harbor-surface-1))",
                      color: "hsl(var(--harbor-text-secondary))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                      opacity: isRefreshing ? 0.6 : 1,
                    }}
                  >
                    {isRefreshing ? "Refreshing..." : "Refresh"}
                  </button>
                </div>
              </header>
        
              <div className="flex-1 overflow-y-auto p-6">
                <div className="max-w-3xl mx-auto space-y-8">
                  {posts.length === 0 ? (
                    <div className="text-center py-16">
                      <div
                        className="w-20 h-20 rounded-lg flex items-center justify-center mx-auto mb-4"
                        style={{ background: "hsl(var(--harbor-surface-1))" }}
                      >
                        <FeedIcon
                          className="w-10 h-10"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        />
                      </div>
                      <h3
                        className="text-lg font-semibold mb-2"
                        style={{ color: "hsl(var(--harbor-text-primary))" }}
                      >
                        Your feed is empty
                      </h3>
                      <p
                        className="text-sm max-w-xs mx-auto mb-4"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      >
                        When your contacts share posts and grant you permission to view them, they'll appear here.
                      </p>
                      <button
                        className="px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200"
                        style={{
                          background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                          color: "white",
                          boxShadow: "0 4px 12px hsl(var(--harbor-primary) / 0.3)",
                        }}
                      >
                        Find Contacts
                      </button>
                    </div>
                  ) : (
                    posts.map((post) => {
                      const saved = isSaved(post);
        
                      return (
                        <article
                          key={post.id}
                          className="rounded-lg overflow-hidden"
                          style={{
                            background: "hsl(var(--harbor-bg-elevated))",
                            border: "1px solid hsl(var(--harbor-border-subtle))",
                          }}
                        >
                          {/* Post header */}
                          <div
                            className="px-5 py-4 flex items-center justify-between border-b"
                            style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                          >
                            <div className="flex items-center gap-3">
                              <div
                                className="w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold text-white"
                                style={{
                                  background: post.author.avatarGradient,
                                }}
                              >
                                {getInitials(post.author.name)}
                              </div>
                              <div>
                                <div className="flex items-center gap-2">
                                  <p
                                    className="font-semibold text-sm"
                                    style={{ color: "hsl(var(--harbor-text-primary))" }}
                                  >
                                    {post.author.name}
                                  </p>
                                  {post.isReal ? (
                                    <span
                                      className="text-[10px] px-1.5 py-0.5 rounded"
                                      style={{
                                        background: "hsl(var(--harbor-success) / 0.15)",
                                        color: "hsl(var(--harbor-success))",
                                      }}
                                    >
                                      P2P
                                    </span>
                                  ) : (
                                    <span
                                      className="text-[10px] px-1.5 py-0.5 rounded"
                                      style={{
                                        background: "hsl(var(--harbor-text-tertiary) / 0.15)",
                                        color: "hsl(var(--harbor-text-tertiary))",
                                      }}
                                    >
                                      Demo
                                    </span>
                                  )}
                                </div>
                                <p
                                  className="text-xs"
                                  style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                                >
                                  {formatDate(post.timestamp)}
                                </p>
                              </div>
                            </div>
        
                            <button
                              onClick={() => handlePostMenu(post.author.name)}
                              className="p-2 rounded-lg transition-colors duration-200 hover:bg-white/5"
                              style={{
                                color: "hsl(var(--harbor-text-tertiary))",
                              }}
                            >
                              <EllipsisIcon className="w-5 h-5" />
                            </button>
                          </div>
        
                          {/* Post content */}
                          <div className="px-5 py-5">
                            <p
                              className="text-base leading-relaxed whitespace-pre-wrap"
                              style={{ color: "hsl(var(--harbor-text-primary))" }}
                            >
                              {post.content}
                            </p>
                          </div>
        
                          {/* Post actions */}
                          <div
                            className="px-5 py-3 flex items-center gap-6 border-t"
                            style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                          >
                            <button
                              onClick={() => handleLike(post)}
                              className="flex items-center gap-2 transition-colors duration-200"
                              style={{
                                color: post.likedByUser
                                  ? "hsl(var(--harbor-error))"
                                  : "hsl(var(--harbor-text-secondary))",
                              }}
                            >
                              <svg
                                className="w-5 h-5"
                                fill={post.likedByUser ? "currentColor" : "none"}
                                viewBox="0 0 24 24"
                                stroke="currentColor"
                              >
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                              </svg>
                              <span className="text-sm">{post.likes}</span>
                            </button>
        
                            <button
                              onClick={() => toast("Comments coming soon!")}
                              className="flex items-center gap-2 transition-colors duration-200"
                              style={{
                                color: "hsl(var(--harbor-text-secondary))",
                              }}
                            >
                              <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                              </svg>
                              <span className="text-sm">{post.comments}</span>
                            </button>
        
                            <button
                              onClick={() => handleSave(post)}
                              className="flex items-center gap-2 transition-colors duration-200 ml-auto"
                              style={{
                                color: saved
                                  ? "hsl(var(--harbor-primary))"
                                  : "hsl(var(--harbor-text-secondary))",
                              }}
                            >
                              <svg
                                className="w-5 h-5"
                                fill={saved ? "currentColor" : "none"}
                                viewBox="0 0 24 24"
                                stroke="currentColor"
                              >
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                              </svg>
                              <span className="text-sm">{saved ? "Saved" : "Save"}</span>
                            </button>
                          </div>
                        </article>
                      );
                    })
                  )}
                </div>
              </div>
            </div>
          );
        }
        ```

      - ğŸ“„ **Network.tsx**

        ğŸ“„ *File Path*: `.\src\pages\Network.tsx`
        *Size*: 32604 bytes | *Modified*: 2026-01-18 09:50:02

        ```
        import { useEffect, useState } from "react";
        import toast from "react-hot-toast";
        import { useIdentityStore, useNetworkStore } from "../stores";
        import { contactsService } from "../services/contacts";
        import {
          NetworkIcon,
          UserIcon,
          UsersIcon,
          SearchIcon,
          PlusIcon,
          CheckIcon,
          XIcon,
        } from "../components/icons";
        
        // Adjectives and animals for generating human-friendly peer names
        const ADJECTIVES = [
          "Swift", "Brave", "Calm", "Clever", "Eager", "Gentle", "Happy", "Jolly",
          "Kind", "Lively", "Merry", "Noble", "Proud", "Quick", "Quiet", "Sleek",
          "Smart", "Sunny", "Warm", "Wise", "Bold", "Bright", "Cool", "Crisp",
          "Dapper", "Fresh", "Grand", "Lucky", "Neat", "Sharp", "Vivid", "Witty"
        ];
        
        const ANIMALS = [
          "Falcon", "Wolf", "Bear", "Eagle", "Hawk", "Lion", "Tiger", "Otter",
          "Fox", "Deer", "Owl", "Raven", "Swan", "Crane", "Heron", "Panda",
          "Koala", "Dolphin", "Whale", "Seal", "Lynx", "Badger", "Hare", "Finch",
          "Robin", "Sparrow", "Jay", "Wren", "Lark", "Dove", "Elk", "Moose"
        ];
        
        // Generate a consistent human-friendly name from a peer ID
        function getPeerFriendlyName(peerId: string): string {
          // Use the peer ID to generate consistent indices
          let hash = 0;
          for (let i = 0; i < peerId.length; i++) {
            const char = peerId.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
          }
        
          const adjIndex = Math.abs(hash) % ADJECTIVES.length;
          const animalIndex = Math.abs(hash >> 8) % ANIMALS.length;
        
          return `${ADJECTIVES[adjIndex]} ${ANIMALS[animalIndex]}`;
        }
        
        // Generate consistent avatar color from peer ID
        function getPeerColor(peerId: string): string {
          const colors = [
            "linear-gradient(135deg, hsl(220 91% 54%), hsl(262 83% 58%))",
            "linear-gradient(135deg, hsl(262 83% 58%), hsl(330 81% 60%))",
            "linear-gradient(135deg, hsl(152 69% 40%), hsl(180 70% 45%))",
            "linear-gradient(135deg, hsl(36 90% 55%), hsl(15 80% 55%))",
            "linear-gradient(135deg, hsl(200 80% 50%), hsl(220 91% 54%))",
            "linear-gradient(135deg, hsl(340 75% 55%), hsl(10 80% 60%))",
            "linear-gradient(135deg, hsl(280 70% 50%), hsl(320 75% 55%))",
            "linear-gradient(135deg, hsl(170 65% 45%), hsl(200 70% 50%))",
          ];
        
          let hash = 0;
          for (let i = 0; i < peerId.length; i++) {
            hash = peerId.charCodeAt(i) + ((hash << 5) - hash);
          }
        
          return colors[Math.abs(hash) % colors.length];
        }
        
        export function NetworkPage() {
          const { state } = useIdentityStore();
          const {
            isRunning,
            status,
            connectedPeers,
            stats,
            error,
            isLoading,
            startNetwork,
            stopNetwork,
            refreshPeers,
            refreshStats,
            checkStatus,
          } = useNetworkStore();
        
          const [searchQuery, setSearchQuery] = useState("");
          const [activeTab, setActiveTab] = useState<"peers" | "contacts">("peers");
          const [showAddContactModal, setShowAddContactModal] = useState(false);
          const [manualPeerId, setManualPeerId] = useState("");
          const [isAddingContact, setIsAddingContact] = useState(false);
        
          const identity = state.status === "unlocked" ? state.identity : null;
        
          // Check network status on mount and set up refresh interval
          useEffect(() => {
            checkStatus();
        
            // Refresh peers and stats every 5 seconds when running
            const interval = setInterval(() => {
              if (isRunning) {
                refreshPeers();
                refreshStats();
              }
            }, 5000);
        
            return () => clearInterval(interval);
          }, [isRunning, checkStatus, refreshPeers, refreshStats]);
        
          const formatBytes = (bytes: number) => {
            // Handle NaN, undefined, or null
            if (!bytes || isNaN(bytes)) return "0 B";
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
          };
        
          const formatUptime = (seconds: number) => {
            // Handle NaN, undefined, or null
            if (!seconds || isNaN(seconds)) return "0s";
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
          };
        
          const getInitials = (name: string) => {
            return name
              .split(" ")
              .map((n) => n[0])
              .join("")
              .toUpperCase()
              .slice(0, 2);
          };
        
          const filteredPeers = connectedPeers.filter((peer) => {
            const query = searchQuery.toLowerCase();
            const friendlyName = getPeerFriendlyName(peer.peerId).toLowerCase();
            return (
              friendlyName.includes(query) ||
              peer.peerId.toLowerCase().includes(query) ||
              peer.addresses.some((addr) => addr.toLowerCase().includes(query))
            );
          });
        
          // Handle adding a contact by peer ID
          const handleAddContactByPeerId = async () => {
            if (!manualPeerId.trim()) {
              toast.error("Please enter a Peer ID");
              return;
            }
        
            // Basic validation: libp2p peer IDs typically start with "12D3KooW" and are ~52 chars
            if (!manualPeerId.startsWith("12D3KooW") || manualPeerId.length < 50) {
              toast.error("Invalid Peer ID format. It should start with '12D3KooW' and be about 52 characters.");
              return;
            }
        
            setIsAddingContact(true);
            try {
              await contactsService.requestPeerIdentity(manualPeerId.trim());
              toast.success("Identity request sent! Contact will be added when they respond.");
              setShowAddContactModal(false);
              setManualPeerId("");
            } catch (err) {
              console.error("Failed to request identity:", err);
              toast.error(`Failed to add contact: ${err}`);
            } finally {
              setIsAddingContact(false);
            }
          };
        
          return (
            <div
              className="h-full flex flex-col"
              style={{ background: "hsl(var(--harbor-bg-primary))" }}
            >
              {/* Header */}
              <header
                className="px-6 py-4 border-b flex-shrink-0"
                style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
              >
                <div className="flex items-center justify-between">
                  <div>
                    <h1
                      className="text-xl font-bold"
                      style={{ color: "hsl(var(--harbor-text-primary))" }}
                    >
                      Network
                    </h1>
                    <p
                      className="text-sm mt-0.5"
                      style={{ color: "hsl(var(--harbor-text-secondary))" }}
                    >
                      Manage your connections and contacts
                    </p>
                  </div>
        
                  {/* Network toggle button */}
                  <button
                    onClick={isRunning ? stopNetwork : startNetwork}
                    disabled={isLoading || state.status !== "unlocked"}
                    className="flex items-center gap-2 px-4 py-2 rounded-xl font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                    style={{
                      background: isRunning
                        ? "hsl(var(--harbor-error) / 0.1)"
                        : "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                      color: isRunning ? "hsl(var(--harbor-error))" : "white",
                      border: isRunning
                        ? "1px solid hsl(var(--harbor-error) / 0.2)"
                        : "none",
                      boxShadow: isRunning
                        ? "none"
                        : "0 4px 12px hsl(var(--harbor-primary) / 0.3)",
                    }}
                  >
                    {isLoading ? (
                      <div
                        className="w-4 h-4 border-2 rounded-full animate-spin"
                        style={{
                          borderColor: isRunning
                            ? "hsl(var(--harbor-error) / 0.3)"
                            : "rgba(255,255,255,0.3)",
                          borderTopColor: isRunning
                            ? "hsl(var(--harbor-error))"
                            : "white",
                        }}
                      />
                    ) : isRunning ? (
                      <XIcon className="w-4 h-4" />
                    ) : (
                      <NetworkIcon className="w-4 h-4" />
                    )}
                    {isLoading ? "..." : isRunning ? "Stop Network" : "Start Network"}
                  </button>
                </div>
              </header>
        
              <div className="flex-1 overflow-y-auto p-6">
                <div className="max-w-4xl mx-auto space-y-6">
                  {/* Error banner */}
                  {error && (
                    <div
                      className="p-4 rounded-xl flex items-center gap-3"
                      style={{
                        background: "hsl(var(--harbor-error) / 0.1)",
                        border: "1px solid hsl(var(--harbor-error) / 0.2)",
                      }}
                    >
                      <XIcon
                        className="w-5 h-5 flex-shrink-0"
                        style={{ color: "hsl(var(--harbor-error))" }}
                      />
                      <p style={{ color: "hsl(var(--harbor-error))" }}>{error}</p>
                    </div>
                  )}
        
                  {/* Network Status Card */}
                  <div
                    className="rounded-2xl p-6"
                    style={{
                      background: "hsl(var(--harbor-bg-elevated))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                    }}
                  >
                    <div className="flex items-start gap-4">
                      {/* Status indicator */}
                      <div
                        className="w-14 h-14 rounded-xl flex items-center justify-center flex-shrink-0"
                        style={{
                          background:
                            status === "connected"
                              ? "hsl(var(--harbor-success) / 0.15)"
                              : status === "connecting"
                                ? "hsl(var(--harbor-warning) / 0.15)"
                                : "hsl(var(--harbor-surface-2))",
                        }}
                      >
                        <NetworkIcon
                          className="w-7 h-7"
                          style={{
                            color:
                              status === "connected"
                                ? "hsl(var(--harbor-success))"
                                : status === "connecting"
                                  ? "hsl(var(--harbor-warning))"
                                  : "hsl(var(--harbor-text-tertiary))",
                          }}
                        />
                      </div>
        
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-1">
                          <h3
                            className="text-lg font-semibold"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            Peer-to-Peer Network
                          </h3>
                          <div
                            className="px-2 py-0.5 rounded-full text-xs font-medium"
                            style={{
                              background:
                                status === "connected"
                                  ? "hsl(var(--harbor-success) / 0.15)"
                                  : status === "connecting"
                                    ? "hsl(var(--harbor-warning) / 0.15)"
                                    : "hsl(var(--harbor-surface-2))",
                              color:
                                status === "connected"
                                  ? "hsl(var(--harbor-success))"
                                  : status === "connecting"
                                    ? "hsl(var(--harbor-warning))"
                                    : "hsl(var(--harbor-text-tertiary))",
                            }}
                          >
                            {status === "connected"
                              ? "Online"
                              : status === "connecting"
                                ? "Connecting..."
                                : "Offline"}
                          </div>
                        </div>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          {isRunning
                            ? `Connected to ${stats.connectedPeers} peer${stats.connectedPeers !== 1 ? "s" : ""} via libp2p`
                            : "Start the network to discover and connect with peers"}
                        </p>
                      </div>
                    </div>
        
                    {/* Stats grid */}
                    {isRunning && (
                      <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mt-6">
                        <div
                          className="p-3 rounded-xl"
                          style={{ background: "hsl(var(--harbor-surface-1))" }}
                        >
                          <p
                            className="text-xs mb-1"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Peers
                          </p>
                          <p
                            className="text-xl font-bold"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {stats.connectedPeers}
                          </p>
                        </div>
                        <div
                          className="p-3 rounded-xl"
                          style={{ background: "hsl(var(--harbor-surface-1))" }}
                        >
                          <p
                            className="text-xs mb-1"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Uptime
                          </p>
                          <p
                            className="text-xl font-bold"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {formatUptime(stats.uptimeSeconds)}
                          </p>
                        </div>
                        <div
                          className="p-3 rounded-xl"
                          style={{ background: "hsl(var(--harbor-surface-1))" }}
                        >
                          <p
                            className="text-xs mb-1"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Received
                          </p>
                          <p
                            className="text-xl font-bold"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {formatBytes(stats.totalBytesIn)}
                          </p>
                        </div>
                        <div
                          className="p-3 rounded-xl"
                          style={{ background: "hsl(var(--harbor-surface-1))" }}
                        >
                          <p
                            className="text-xs mb-1"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Sent
                          </p>
                          <p
                            className="text-xl font-bold"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {formatBytes(stats.totalBytesOut)}
                          </p>
                        </div>
                      </div>
                    )}
                  </div>
        
                  {/* Identity Card */}
                  {identity && (
                    <div
                      className="rounded-2xl p-6"
                      style={{
                        background: "hsl(var(--harbor-bg-elevated))",
                        border: "1px solid hsl(var(--harbor-border-subtle))",
                      }}
                    >
                      <h3
                        className="text-sm font-medium mb-4"
                        style={{ color: "hsl(var(--harbor-text-secondary))" }}
                      >
                        Your Identity
                      </h3>
        
                      <div className="flex items-center gap-4">
                        <div
                          className="w-16 h-16 rounded-full flex items-center justify-center text-xl font-semibold text-white flex-shrink-0"
                          style={{
                            background:
                              "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                          }}
                        >
                          {identity.avatarHash ? (
                            <img
                              src={`/media/${identity.avatarHash}`}
                              alt=""
                              className="w-full h-full rounded-full object-cover"
                            />
                          ) : (
                            getInitials(identity.displayName)
                          )}
                        </div>
        
                        <div className="flex-1 min-w-0">
                          <p
                            className="text-lg font-semibold"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {identity.displayName}
                          </p>
                          {identity.bio && (
                            <p
                              className="text-sm mt-0.5"
                              style={{ color: "hsl(var(--harbor-text-secondary))" }}
                            >
                              {identity.bio}
                            </p>
                          )}
                          <div
                            className="mt-2 px-3 py-1.5 rounded-lg inline-block font-mono text-xs"
                            style={{
                              background: "hsl(var(--harbor-surface-1))",
                              color: "hsl(var(--harbor-text-tertiary))",
                            }}
                          >
                            {identity.peerId.slice(0, 16)}...{identity.peerId.slice(-12)}
                          </div>
                        </div>
        
                        <button
                          className="p-2 rounded-lg transition-colors duration-200"
                          style={{
                            color: "hsl(var(--harbor-text-tertiary))",
                            background: "hsl(var(--harbor-surface-1))",
                          }}
                          title="Copy Peer ID"
                          onClick={() => {
                            navigator.clipboard.writeText(identity.peerId);
                            toast.success("Peer ID copied to clipboard!");
                          }}
                        >
                          <svg
                            className="w-5 h-5"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                          >
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={1.5}
                              d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                            />
                          </svg>
                        </button>
                      </div>
                    </div>
                  )}
        
                  {/* Peers/Contacts Section */}
                  <div
                    className="rounded-2xl overflow-hidden"
                    style={{
                      background: "hsl(var(--harbor-bg-elevated))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                    }}
                  >
                    {/* Tabs and Search */}
                    <div
                      className="p-4 border-b flex items-center gap-4"
                      style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                    >
                      <div
                        className="flex rounded-lg p-1"
                        style={{ background: "hsl(var(--harbor-surface-1))" }}
                      >
                        <button
                          onClick={() => setActiveTab("peers")}
                          className="px-4 py-1.5 rounded-md text-sm font-medium transition-all duration-200"
                          style={{
                            background:
                              activeTab === "peers"
                                ? "hsl(var(--harbor-bg-elevated))"
                                : "transparent",
                            color:
                              activeTab === "peers"
                                ? "hsl(var(--harbor-text-primary))"
                                : "hsl(var(--harbor-text-tertiary))",
                            boxShadow:
                              activeTab === "peers" ? "var(--shadow-sm)" : "none",
                          }}
                        >
                          <UsersIcon className="w-4 h-4 inline mr-1.5" />
                          Peers
                        </button>
                        <button
                          onClick={() => setActiveTab("contacts")}
                          className="px-4 py-1.5 rounded-md text-sm font-medium transition-all duration-200"
                          style={{
                            background:
                              activeTab === "contacts"
                                ? "hsl(var(--harbor-bg-elevated))"
                                : "transparent",
                            color:
                              activeTab === "contacts"
                                ? "hsl(var(--harbor-text-primary))"
                                : "hsl(var(--harbor-text-tertiary))",
                            boxShadow:
                              activeTab === "contacts" ? "var(--shadow-sm)" : "none",
                          }}
                        >
                          <UserIcon className="w-4 h-4 inline mr-1.5" />
                          Contacts
                        </button>
                      </div>
        
                      <div className="flex-1 relative">
                        <SearchIcon
                          className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        />
                        <input
                          type="text"
                          placeholder="Search peers..."
                          value={searchQuery}
                          onChange={(e) => setSearchQuery(e.target.value)}
                          className="w-full pl-10 pr-4 py-2 rounded-lg text-sm"
                          style={{
                            background: "hsl(var(--harbor-surface-1))",
                            border: "1px solid hsl(var(--harbor-border-subtle))",
                            color: "hsl(var(--harbor-text-primary))",
                          }}
                        />
                      </div>
        
                      <button
                        className="p-2 rounded-lg transition-colors duration-200"
                        style={{
                          background:
                            "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                          color: "white",
                        }}
                        title="Add contact by Peer ID"
                        onClick={() => setShowAddContactModal(true)}
                      >
                        <PlusIcon className="w-5 h-5" />
                      </button>
                    </div>
        
                    {/* Peer list */}
                    <div className="p-4">
                      {!isRunning ? (
                        <div className="text-center py-12">
                          <div
                            className="w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4"
                            style={{ background: "hsl(var(--harbor-surface-1))" }}
                          >
                            <NetworkIcon
                              className="w-8 h-8"
                              style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                            />
                          </div>
                          <p
                            className="font-medium mb-1"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            Network is offline
                          </p>
                          <p
                            className="text-sm"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Start the network to discover peers on your local network
                          </p>
                        </div>
                      ) : filteredPeers.length === 0 ? (
                        <div className="text-center py-12">
                          <div
                            className="w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4"
                            style={{ background: "hsl(var(--harbor-surface-1))" }}
                          >
                            <UsersIcon
                              className="w-8 h-8"
                              style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                            />
                          </div>
                          <p
                            className="font-medium mb-1"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {searchQuery ? "No peers found" : "No peers connected"}
                          </p>
                          <p
                            className="text-sm"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            {searchQuery
                              ? "Try a different search term"
                              : "Peers running Harbor on your network will appear here"}
                          </p>
                        </div>
                      ) : (
                        <div className="space-y-2">
                          {filteredPeers.map((peer) => {
                            const friendlyName = getPeerFriendlyName(peer.peerId);
                            const avatarColor = getPeerColor(peer.peerId);
                            const initials = friendlyName
                              .split(" ")
                              .map((w) => w[0])
                              .join("");
        
                            return (
                              <div
                                key={peer.peerId}
                                className="flex items-center gap-4 p-3 rounded-xl transition-all duration-200"
                                style={{
                                  background: "hsl(var(--harbor-surface-1))",
                                }}
                              >
                                {/* Avatar with color gradient */}
                                <div
                                  className="w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold text-white flex-shrink-0"
                                  style={{
                                    background: avatarColor,
                                  }}
                                >
                                  {initials}
                                </div>
        
                                {/* Info - friendly name prominently, peer ID small */}
                                <div className="flex-1 min-w-0">
                                  <p
                                    className="font-medium text-sm"
                                    style={{ color: "hsl(var(--harbor-text-primary))" }}
                                  >
                                    {friendlyName}
                                  </p>
                                  <p
                                    className="text-xs font-mono truncate"
                                    style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                                    title={peer.peerId}
                                  >
                                    {peer.peerId.slice(0, 12)}...{peer.peerId.slice(-6)}
                                  </p>
                                </div>
        
                                {/* Status */}
                                <div className="flex items-center gap-2">
                                  <div
                                    className={`w-2 h-2 rounded-full ${
                                      peer.isConnected ? "animate-pulse" : ""
                                    }`}
                                    style={{
                                      background: peer.isConnected
                                        ? "hsl(var(--harbor-success))"
                                        : "hsl(var(--harbor-text-tertiary))",
                                    }}
                                  />
                                  <span
                                    className="text-xs"
                                    style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                                  >
                                    {peer.isConnected ? "Connected" : "Disconnected"}
                                  </span>
                                </div>
        
                                {/* Actions */}
                                <button
                                  className="p-2 rounded-lg transition-colors duration-200"
                                  style={{
                                    background: "hsl(var(--harbor-success) / 0.15)",
                                    color: "hsl(var(--harbor-success))",
                                  }}
                                  title={`Add ${friendlyName} to contacts`}
                                  onClick={async () => {
                                    try {
                                      await contactsService.requestPeerIdentity(peer.peerId);
                                      toast.success(`Requesting identity from ${friendlyName}...`);
                                    } catch (e) {
                                      toast.error(`Failed to add contact: ${e}`);
                                    }
                                  }}
                                >
                                  <CheckIcon className="w-4 h-4" />
                                </button>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
        
              {/* Add Contact by Peer ID Modal */}
              {showAddContactModal && (
                <div
                  className="fixed inset-0 flex items-center justify-center z-50"
                  style={{ background: "rgba(0, 0, 0, 0.6)" }}
                  onClick={() => setShowAddContactModal(false)}
                >
                  <div
                    className="rounded-xl p-6 max-w-md w-full mx-4"
                    style={{ background: "hsl(var(--harbor-bg-elevated))" }}
                    onClick={(e) => e.stopPropagation()}
                  >
                    <div className="flex items-center justify-between mb-4">
                      <h2
                        className="text-lg font-semibold"
                        style={{ color: "hsl(var(--harbor-text-primary))" }}
                      >
                        Add Contact by Peer ID
                      </h2>
                      <button
                        onClick={() => setShowAddContactModal(false)}
                        className="p-1 rounded-lg hover:bg-white/10"
                      >
                        <XIcon className="w-5 h-5" style={{ color: "hsl(var(--harbor-text-secondary))" }} />
                      </button>
                    </div>
        
                    <p
                      className="text-sm mb-4"
                      style={{ color: "hsl(var(--harbor-text-secondary))" }}
                    >
                      Enter the Peer ID of the person you want to add. You can find your own Peer ID in Settings.
                    </p>
        
                    {/* Show own Peer ID for easy sharing */}
                    {identity && (
                      <div
                        className="mb-4 p-3 rounded-lg"
                        style={{ background: "hsl(var(--harbor-surface-1))" }}
                      >
                        <label
                          className="text-xs font-medium block mb-1"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        >
                          Your Peer ID (share this with others)
                        </label>
                        <div className="flex items-center gap-2">
                          <code
                            className="text-xs flex-1 break-all"
                            style={{ color: "hsl(var(--harbor-primary))" }}
                          >
                            {identity.peerId}
                          </code>
                          <button
                            className="p-1 rounded hover:bg-white/10"
                            onClick={() => {
                              navigator.clipboard.writeText(identity.peerId);
                              toast.success("Peer ID copied!");
                            }}
                            title="Copy Peer ID"
                          >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ color: "hsl(var(--harbor-text-secondary))" }}>
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                            </svg>
                          </button>
                        </div>
                      </div>
                    )}
        
                    <input
                      type="text"
                      value={manualPeerId}
                      onChange={(e) => setManualPeerId(e.target.value)}
                      placeholder="Enter Peer ID (starts with 12D3KooW...)"
                      className="w-full p-3 rounded-lg text-sm mb-4"
                      style={{
                        background: "hsl(var(--harbor-surface-1))",
                        border: "1px solid hsl(var(--harbor-border-subtle))",
                        color: "hsl(var(--harbor-text-primary))",
                      }}
                      disabled={isAddingContact}
                    />
        
                    <div className="flex gap-3">
                      <button
                        onClick={() => setShowAddContactModal(false)}
                        className="flex-1 px-4 py-2 rounded-lg font-medium transition-colors"
                        style={{
                          background: "hsl(var(--harbor-surface-1))",
                          color: "hsl(var(--harbor-text-primary))",
                        }}
                        disabled={isAddingContact}
                      >
                        Cancel
                      </button>
                      <button
                        onClick={handleAddContactByPeerId}
                        disabled={isAddingContact || !manualPeerId.trim()}
                        className="flex-1 px-4 py-2 rounded-lg font-medium transition-colors disabled:opacity-50"
                        style={{
                          background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                          color: "white",
                        }}
                      >
                        {isAddingContact ? "Adding..." : "Add Contact"}
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }
        ```

      - ğŸ“„ **Settings.tsx**

        ğŸ“„ *File Path*: `.\src\pages\Settings.tsx`
        *Size*: 48470 bytes | *Modified*: 2026-01-17 06:32:08

        ```
        import { useState, useRef, useEffect } from "react";
        import toast from "react-hot-toast";
        import { useIdentityStore, useSettingsStore } from "../stores";
        import {
          UserIcon,
          LockIcon,
          NetworkIcon,
          ShieldIcon,
          ChevronRightIcon,
          XIcon,
        } from "../components/icons";
        
        // Toggle component
        function Toggle({ enabled, onChange }: { enabled: boolean; onChange: (v: boolean) => void }) {
          return (
            <button
              onClick={() => onChange(!enabled)}
              className="w-12 h-6 rounded-full relative transition-colors duration-200"
              style={{
                background: enabled
                  ? "hsl(var(--harbor-primary))"
                  : "hsl(var(--harbor-surface-2))"
              }}
            >
              <div
                className="w-5 h-5 rounded-full absolute top-0.5 transition-all duration-200"
                style={{
                  background: "white",
                  left: enabled ? "calc(100% - 22px)" : "2px"
                }}
              />
            </button>
          );
        }
        
        // Password input with reveal
        function PasswordInput({ placeholder, value, onChange }: {
          placeholder: string;
          value: string;
          onChange: (v: string) => void;
        }) {
          const [show, setShow] = useState(false);
        
          return (
            <div className="relative">
              <input
                type={show ? "text" : "password"}
                placeholder={placeholder}
                value={value}
                onChange={(e) => onChange(e.target.value)}
                className="w-full px-4 py-3 pr-12 rounded-lg text-sm"
                style={{
                  background: "hsl(var(--harbor-surface-1))",
                  border: "1px solid hsl(var(--harbor-border-subtle))",
                  color: "hsl(var(--harbor-text-primary))",
                }}
              />
              <button
                type="button"
                onClick={() => setShow(!show)}
                className="absolute right-3 top-1/2 -translate-y-1/2 p-1"
                style={{ color: "hsl(var(--harbor-text-tertiary))" }}
              >
                {show ? (
                  <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.523 10.523 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.242 4.242L9.88 9.88" />
                  </svg>
                ) : (
                  <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </svg>
                )}
              </button>
            </div>
          );
        }
        
        export function SettingsPage() {
          const { state, updateDisplayName, updateBio } = useIdentityStore();
          const {
            autoStartNetwork,
            localDiscovery,
            showReadReceipts,
            showOnlineStatus,
            defaultVisibility,
            avatarUrl,
            setAutoStartNetwork,
            setLocalDiscovery,
            setShowReadReceipts,
            setShowOnlineStatus,
            setDefaultVisibility,
            setAvatarUrl,
          } = useSettingsStore();
        
          const [activeSection, setActiveSection] = useState<string>("profile");
        
          // Profile edit state
          const [displayName, setDisplayName] = useState("");
          const [bio, setBio] = useState("");
          const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
          const avatarInputRef = useRef<HTMLInputElement>(null);
        
          // Passphrase change state
          const [currentPass, setCurrentPass] = useState("");
          const [newPass, setNewPass] = useState("");
          const [confirmPass, setConfirmPass] = useState("");
          const [passError, setPassError] = useState("");
          const [isChangingPass, setIsChangingPass] = useState(false);
        
          // Delete account modal state
          const [showDeleteModal, setShowDeleteModal] = useState(false);
          const [deleteConfirmText, setDeleteConfirmText] = useState("");
          const [deletePassphrase, setDeletePassphrase] = useState("");
          const [deleteError, setDeleteError] = useState("");
          const [isDeleting, setIsDeleting] = useState(false);
        
          // Import identity state
          const fileInputRef = useRef<HTMLInputElement>(null);
          const [importError, setImportError] = useState("");
          const [importPassphrase, setImportPassphrase] = useState("");
          const [showImportModal, setShowImportModal] = useState(false);
          const [importFile, setImportFile] = useState<File | null>(null);
        
          const identity = state.status === "unlocked" ? state.identity : null;
        
          // Initialize form values when identity changes
          useEffect(() => {
            if (identity) {
              setDisplayName(identity.displayName);
              setBio(identity.bio || "");
            }
          }, [identity]);
        
          const getInitials = (name: string) => {
            return name
              .split(" ")
              .map((n) => n[0])
              .join("")
              .toUpperCase()
              .slice(0, 2);
          };
        
          const handleAvatarUpload = () => {
            avatarInputRef.current?.click();
          };
        
          const handleAvatarChange = (e: React.ChangeEvent<HTMLInputElement>) => {
            const file = e.target.files?.[0];
            if (!file) return;
        
            // Check file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
              toast.error("Image must be less than 5MB");
              return;
            }
        
            // Create object URL for preview
            const url = URL.createObjectURL(file);
            setAvatarUrl(url);
            toast.success("Profile photo updated!");
        
            // Reset file input
            if (avatarInputRef.current) {
              avatarInputRef.current.value = "";
            }
          };
        
          const handleCopyPeerId = () => {
            if (identity) {
              navigator.clipboard.writeText(identity.peerId);
              toast.success("Peer ID copied to clipboard!");
            }
          };
        
          const handleSaveProfile = async () => {
            if (!identity) return;
        
            try {
              const trimmedName = displayName.trim() || identity.displayName;
              const trimmedBio = bio.trim() || null;
        
              if (trimmedName !== identity.displayName) {
                await updateDisplayName(trimmedName);
              }
        
              if (trimmedBio !== identity.bio) {
                await updateBio(trimmedBio);
              }
        
              setHasUnsavedChanges(false);
              toast.success("Profile saved!");
            } catch {
              toast.error("Failed to save profile");
            }
          };
        
          const handlePassphraseChange = async () => {
            setPassError("");
            if (!currentPass || !newPass || !confirmPass) {
              setPassError("All fields are required");
              return;
            }
            if (newPass !== confirmPass) {
              setPassError("New passphrases do not match");
              return;
            }
            if (newPass.length < 8) {
              setPassError("Passphrase must be at least 8 characters");
              return;
            }
        
            setIsChangingPass(true);
        
            // Simulate passphrase change (in a real app, this would call the backend)
            await new Promise((resolve) => setTimeout(resolve, 1500));
        
            setIsChangingPass(false);
            setCurrentPass("");
            setNewPass("");
            setConfirmPass("");
            toast.success("Passphrase changed successfully!");
          };
        
          const handleExportIdentity = () => {
            if (!identity) return;
        
            // Create export data (encrypted identity blob)
            const exportData = {
              version: 1,
              type: "harbor-identity-backup",
              peerId: identity.peerId,
              displayName: identity.displayName,
              bio: identity.bio,
              createdAt: new Date().toISOString(),
              encryptedKeys: "ENCRYPTED_KEY_DATA_PLACEHOLDER",
              note: "Keep this file safe. You'll need your passphrase to restore it."
            };
        
            // Create and download the file
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `harbor-backup-${identity.displayName.replace(/\s+/g, "-").toLowerCase()}-${new Date().toISOString().split("T")[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        
            toast.success("Backup exported! Keep it safe.");
          };
        
          const handleImportClick = () => {
            fileInputRef.current?.click();
          };
        
          const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
            const file = e.target.files?.[0];
            if (file) {
              setImportFile(file);
              setShowImportModal(true);
              setImportError("");
              setImportPassphrase("");
            }
            // Reset the input
            e.target.value = "";
          };
        
          const handleImportIdentity = async () => {
            if (!importFile) return;
        
            if (!importPassphrase) {
              setImportError("Passphrase is required to decrypt the backup");
              return;
            }
        
            // Read and parse the file
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const data = JSON.parse(e.target?.result as string);
        
                if (data.type !== "harbor-identity-backup") {
                  setImportError("Invalid backup file format");
                  return;
                }
        
                // Simulate recovery process
                await new Promise((resolve) => setTimeout(resolve, 2000));
        
                toast.success(`Account recovered! Welcome back, ${data.displayName}`);
                setShowImportModal(false);
                setImportFile(null);
                setImportPassphrase("");
              } catch {
                setImportError("Failed to parse backup file");
              }
            };
            reader.readAsText(importFile);
          };
        
          const handleDeleteIdentity = () => {
            setShowDeleteModal(true);
            setDeleteConfirmText("");
            setDeletePassphrase("");
            setDeleteError("");
          };
        
          const confirmDeleteIdentity = async () => {
            if (deleteConfirmText !== "DELETE") {
              setDeleteError("Please type DELETE to confirm");
              return;
            }
        
            if (!deletePassphrase) {
              setDeleteError("Passphrase is required");
              return;
            }
        
            setIsDeleting(true);
        
            // Simulate deletion process
            await new Promise((resolve) => setTimeout(resolve, 2000));
        
            setIsDeleting(false);
            toast.success("Account deleted. Goodbye!");
            setShowDeleteModal(false);
        
            // In a real app, this would clear all data and redirect to onboarding
          };
        
          const handleOnlineStatusChange = (value: boolean) => {
            setShowOnlineStatus(value);
            toast.success(value ? "Online status visible to contacts" : "Online status hidden");
          };
        
          const sections = [
            { id: "profile", label: "Profile", icon: UserIcon, description: "Your identity and bio" },
            { id: "security", label: "Security", icon: LockIcon, description: "Passphrase and keys" },
            { id: "network", label: "Network", icon: NetworkIcon, description: "Connection settings" },
            { id: "privacy", label: "Privacy", icon: ShieldIcon, description: "Visibility controls" },
          ];
        
          return (
            <div
              className="h-full flex"
              style={{ background: "hsl(var(--harbor-bg-primary))" }}
            >
              {/* Hidden file inputs */}
              <input
                ref={avatarInputRef}
                type="file"
                accept="image/*"
                onChange={handleAvatarChange}
                className="hidden"
              />
              <input
                ref={fileInputRef}
                type="file"
                accept=".json"
                onChange={handleFileSelect}
                className="hidden"
              />
        
              {/* Settings sidebar - 33% width */}
              <div
                className="w-1/3 max-w-xs flex flex-col border-r flex-shrink-0"
                style={{
                  borderColor: "hsl(var(--harbor-border-subtle))",
                  background: "hsl(var(--harbor-bg-elevated))",
                }}
              >
                <div
                  className="p-4 border-b"
                  style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                >
                  <h2
                    className="text-lg font-bold"
                    style={{ color: "hsl(var(--harbor-text-primary))" }}
                  >
                    Settings
                  </h2>
                  <p
                    className="text-sm mt-0.5"
                    style={{ color: "hsl(var(--harbor-text-secondary))" }}
                  >
                    Customize your experience
                  </p>
                </div>
        
                <nav className="flex-1 p-2 space-y-1">
                  {sections.map((section) => {
                    const Icon = section.icon;
                    const isActive = activeSection === section.id;
        
                    return (
                      <button
                        key={section.id}
                        onClick={() => setActiveSection(section.id)}
                        className="w-full flex items-center gap-3 p-3 rounded-lg text-left transition-all duration-200"
                        style={{
                          background: isActive
                            ? "linear-gradient(135deg, hsl(var(--harbor-primary) / 0.15), hsl(var(--harbor-accent) / 0.1))"
                            : "transparent",
                          border: isActive
                            ? "1px solid hsl(var(--harbor-primary) / 0.2)"
                            : "1px solid transparent",
                        }}
                      >
                        <div
                          className="w-9 h-9 rounded-lg flex items-center justify-center"
                          style={{
                            background: isActive
                              ? "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))"
                              : "hsl(var(--harbor-surface-2))",
                          }}
                        >
                          <Icon
                            className="w-5 h-5"
                            style={{
                              color: isActive ? "white" : "hsl(var(--harbor-text-secondary))",
                            }}
                          />
                        </div>
                        <div className="flex-1 min-w-0">
                          <p
                            className="font-medium text-sm"
                            style={{
                              color: isActive
                                ? "hsl(var(--harbor-primary))"
                                : "hsl(var(--harbor-text-primary))",
                            }}
                          >
                            {section.label}
                          </p>
                          <p
                            className="text-xs truncate"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            {section.description}
                          </p>
                        </div>
                        <ChevronRightIcon
                          className="w-4 h-4"
                          style={{
                            color: isActive
                              ? "hsl(var(--harbor-primary))"
                              : "hsl(var(--harbor-text-tertiary))",
                          }}
                        />
                      </button>
                    );
                  })}
                </nav>
        
                {/* Version info */}
                <div
                  className="p-4 border-t"
                  style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                >
                  <p
                    className="text-xs text-center"
                    style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                  >
                    Harbor v1.0.0
                  </p>
                </div>
              </div>
        
              {/* Settings content - 66% width */}
              <div className="flex-1 overflow-y-auto p-8">
                <div className="max-w-2xl">
                  {activeSection === "profile" && (
                    <div className="space-y-6">
                      <div>
                        <h3
                          className="text-xl font-semibold mb-1"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Profile
                        </h3>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Manage your identity and how others see you
                        </p>
                      </div>
        
                      {/* Avatar section */}
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <div className="flex items-center gap-6">
                          {identity && (
                            <div
                              className="w-24 h-24 rounded-full flex items-center justify-center text-2xl font-semibold text-white flex-shrink-0 overflow-hidden"
                              style={{
                                background: avatarUrl
                                  ? "transparent"
                                  : "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                              }}
                            >
                              {avatarUrl ? (
                                <img
                                  src={avatarUrl}
                                  alt="Avatar"
                                  className="w-full h-full object-cover"
                                />
                              ) : (
                                getInitials(identity.displayName)
                              )}
                            </div>
                          )}
                          <div className="flex-1">
                            <h4
                              className="font-medium mb-2"
                              style={{ color: "hsl(var(--harbor-text-primary))" }}
                            >
                              Profile Photo
                            </h4>
                            <p
                              className="text-sm mb-3"
                              style={{ color: "hsl(var(--harbor-text-secondary))" }}
                            >
                              Upload a photo to personalize your profile
                            </p>
                            <div className="flex gap-2">
                              <button
                                onClick={handleAvatarUpload}
                                className="px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200"
                                style={{
                                  background: "hsl(var(--harbor-surface-1))",
                                  color: "hsl(var(--harbor-text-primary))",
                                  border: "1px solid hsl(var(--harbor-border-subtle))",
                                }}
                              >
                                Upload Photo
                              </button>
                              {avatarUrl && (
                                <button
                                  onClick={() => {
                                    setAvatarUrl(null);
                                    toast.success("Photo removed");
                                  }}
                                  className="px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200"
                                  style={{
                                    color: "hsl(var(--harbor-error))",
                                  }}
                                >
                                  Remove
                                </button>
                              )}
                            </div>
                          </div>
                        </div>
                      </div>
        
                      {/* Display name */}
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <label
                          className="block text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Display Name
                        </label>
                        <input
                          type="text"
                          value={displayName}
                          onChange={(e) => {
                            setDisplayName(e.target.value);
                            setHasUnsavedChanges(true);
                          }}
                          className="w-full px-4 py-3 rounded-lg text-sm"
                          style={{
                            background: "hsl(var(--harbor-surface-1))",
                            border: "1px solid hsl(var(--harbor-border-subtle))",
                            color: "hsl(var(--harbor-text-primary))",
                          }}
                        />
                      </div>
        
                      {/* Bio - now 5 lines tall */}
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <label
                          className="block text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Bio
                        </label>
                        <textarea
                          value={bio}
                          onChange={(e) => {
                            setBio(e.target.value);
                            setHasUnsavedChanges(true);
                          }}
                          rows={5}
                          placeholder="Tell others about yourself, your interests, what you're working on..."
                          className="w-full px-4 py-3 rounded-lg text-sm resize-none"
                          style={{
                            background: "hsl(var(--harbor-surface-1))",
                            border: "1px solid hsl(var(--harbor-border-subtle))",
                            color: "hsl(var(--harbor-text-primary))",
                          }}
                        />
                        <p
                          className="text-xs mt-2"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        >
                          This will be visible to your contacts
                        </p>
                      </div>
        
                      {/* Your unique ID */}
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <label
                          className="block text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Your Unique ID
                        </label>
                        <div className="flex gap-2">
                          <div
                            className="flex-1 px-4 py-3 rounded-lg text-sm font-mono truncate"
                            style={{
                              background: "hsl(var(--harbor-surface-1))",
                              border: "1px solid hsl(var(--harbor-border-subtle))",
                              color: "hsl(var(--harbor-text-secondary))",
                            }}
                          >
                            {identity?.peerId || "No identity"}
                          </div>
                          <button
                            onClick={handleCopyPeerId}
                            className="px-4 py-3 rounded-lg text-sm font-medium transition-colors duration-200"
                            style={{
                              background: "hsl(var(--harbor-surface-1))",
                              color: "hsl(var(--harbor-text-primary))",
                              border: "1px solid hsl(var(--harbor-border-subtle))",
                            }}
                          >
                            Copy
                          </button>
                        </div>
                        <p
                          className="text-xs mt-2"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        >
                          Share this ID with others so they can add you as a contact
                        </p>
                      </div>
        
                      {/* Save button */}
                      <div className="flex justify-end">
                        <button
                          onClick={handleSaveProfile}
                          disabled={!hasUnsavedChanges}
                          className="px-6 py-3 rounded-lg text-sm font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                          style={{
                            background: hasUnsavedChanges
                              ? "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))"
                              : "hsl(var(--harbor-surface-2))",
                            color: hasUnsavedChanges ? "white" : "hsl(var(--harbor-text-tertiary))",
                            boxShadow: hasUnsavedChanges ? "0 4px 12px hsl(var(--harbor-primary) / 0.3)" : "none",
                          }}
                        >
                          Save Changes
                        </button>
                      </div>
                    </div>
                  )}
        
                  {activeSection === "security" && (
                    <div className="space-y-6">
                      <div>
                        <h3
                          className="text-xl font-semibold mb-1"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Security
                        </h3>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Manage your passphrase and encryption keys
                        </p>
                      </div>
        
                      {/* Change passphrase */}
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Change Passphrase
                        </h4>
                        <p
                          className="text-sm mb-4"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Update your passphrase to keep your identity secure
                        </p>
        
                        <div className="space-y-3">
                          <PasswordInput
                            placeholder="Current passphrase"
                            value={currentPass}
                            onChange={setCurrentPass}
                          />
                          <PasswordInput
                            placeholder="New passphrase"
                            value={newPass}
                            onChange={setNewPass}
                          />
                          <PasswordInput
                            placeholder="Confirm new passphrase"
                            value={confirmPass}
                            onChange={setConfirmPass}
                          />
                        </div>
        
                        {passError && (
                          <p className="text-sm mt-2" style={{ color: "hsl(var(--harbor-error))" }}>
                            {passError}
                          </p>
                        )}
        
                        <button
                          onClick={handlePassphraseChange}
                          disabled={isChangingPass}
                          className="mt-4 px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200 disabled:opacity-50"
                          style={{
                            background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                            color: "white",
                          }}
                        >
                          {isChangingPass ? "Updating..." : "Update Passphrase"}
                        </button>
                      </div>
        
                      {/* Backup & Recovery */}
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Backup & Recovery
                        </h4>
                        <p
                          className="text-sm mb-4"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Export your identity to create a backup, or import an existing backup to recover your account
                        </p>
        
                        <div className="flex gap-3">
                          <button
                            onClick={handleExportIdentity}
                            className="flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-colors duration-200 flex items-center justify-center gap-2"
                            style={{
                              background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                              color: "white",
                            }}
                          >
                            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                            </svg>
                            Export Backup
                          </button>
                          <button
                            onClick={handleImportClick}
                            className="flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-colors duration-200 flex items-center justify-center gap-2"
                            style={{
                              background: "hsl(var(--harbor-surface-1))",
                              color: "hsl(var(--harbor-text-primary))",
                              border: "1px solid hsl(var(--harbor-border-subtle))",
                            }}
                          >
                            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            Recover Account
                          </button>
                        </div>
        
                        <p
                          className="text-xs mt-3"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        >
                          Your backup file is encrypted with your passphrase. Keep it safe and never share it.
                        </p>
                      </div>
        
                      {/* Danger zone */}
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-error) / 0.05)",
                          border: "1px solid hsl(var(--harbor-error) / 0.2)",
                        }}
                      >
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-error))" }}
                        >
                          Delete Account
                        </h4>
                        <p
                          className="text-sm mb-4"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Permanently delete your identity, messages, posts, and all associated data. This action cannot be undone.
                        </p>
                        <button
                          onClick={handleDeleteIdentity}
                          className="px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200"
                          style={{
                            background: "hsl(var(--harbor-error) / 0.15)",
                            color: "hsl(var(--harbor-error))",
                            border: "1px solid hsl(var(--harbor-error) / 0.3)",
                          }}
                        >
                          Delete Account
                        </button>
                      </div>
                    </div>
                  )}
        
                  {activeSection === "network" && (
                    <div className="space-y-6">
                      <div>
                        <h3
                          className="text-xl font-semibold mb-1"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Network
                        </h3>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Configure connection settings
                        </p>
                      </div>
        
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <div className="flex items-center justify-between">
                          <div>
                            <h4
                              className="font-medium"
                              style={{ color: "hsl(var(--harbor-text-primary))" }}
                            >
                              Auto-connect on startup
                            </h4>
                            <p
                              className="text-sm mt-0.5"
                              style={{ color: "hsl(var(--harbor-text-secondary))" }}
                            >
                              Automatically connect to the network when app starts
                            </p>
                          </div>
                          <Toggle enabled={autoStartNetwork} onChange={setAutoStartNetwork} />
                        </div>
                      </div>
        
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <div className="flex items-center justify-between">
                          <div>
                            <h4
                              className="font-medium"
                              style={{ color: "hsl(var(--harbor-text-primary))" }}
                            >
                              Local network discovery
                            </h4>
                            <p
                              className="text-sm mt-0.5"
                              style={{ color: "hsl(var(--harbor-text-secondary))" }}
                            >
                              Automatically find other Harbor users on your local network
                            </p>
                          </div>
                          <Toggle enabled={localDiscovery} onChange={setLocalDiscovery} />
                        </div>
                      </div>
                    </div>
                  )}
        
                  {activeSection === "privacy" && (
                    <div className="space-y-6">
                      <div>
                        <h3
                          className="text-xl font-semibold mb-1"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Privacy
                        </h3>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Control who can see your content
                        </p>
                      </div>
        
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Default post visibility
                        </h4>
                        <p
                          className="text-sm mb-4"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Who can see your new posts by default
                        </p>
                        <select
                          value={defaultVisibility}
                          onChange={(e) => setDefaultVisibility(e.target.value as "contacts" | "public")}
                          className="w-full px-4 py-3 rounded-lg text-sm"
                          style={{
                            background: "hsl(var(--harbor-surface-1))",
                            border: "1px solid hsl(var(--harbor-border-subtle))",
                            color: "hsl(var(--harbor-text-primary))",
                          }}
                        >
                          <option value="contacts">Contacts only</option>
                          <option value="public">Anyone with the link</option>
                        </select>
                      </div>
        
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <div className="flex items-center justify-between">
                          <div>
                            <h4
                              className="font-medium"
                              style={{ color: "hsl(var(--harbor-text-primary))" }}
                            >
                              Message read notifications
                            </h4>
                            <p
                              className="text-sm mt-0.5"
                              style={{ color: "hsl(var(--harbor-text-secondary))" }}
                            >
                              Let others know when you've read their messages
                            </p>
                          </div>
                          <Toggle enabled={showReadReceipts} onChange={setShowReadReceipts} />
                        </div>
                      </div>
        
                      <div
                        className="rounded-lg p-6"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <div className="flex items-center justify-between">
                          <div>
                            <h4
                              className="font-medium"
                              style={{ color: "hsl(var(--harbor-text-primary))" }}
                            >
                              Show online status
                            </h4>
                            <p
                              className="text-sm mt-0.5"
                              style={{ color: "hsl(var(--harbor-text-secondary))" }}
                            >
                              Show when you're online to your contacts
                            </p>
                          </div>
                          <Toggle enabled={showOnlineStatus} onChange={handleOnlineStatusChange} />
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              </div>
        
              {/* Delete Account Modal */}
              {showDeleteModal && (
                <div
                  className="fixed inset-0 flex items-center justify-center z-50 p-4"
                  style={{ background: "rgba(0, 0, 0, 0.6)" }}
                >
                  <div
                    className="w-full max-w-md rounded-lg overflow-hidden"
                    style={{
                      background: "hsl(var(--harbor-bg-elevated))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                    }}
                  >
                    {/* Modal header */}
                    <div
                      className="px-6 py-4 flex items-center justify-between border-b"
                      style={{
                        borderColor: "hsl(var(--harbor-border-subtle))",
                        background: "hsl(var(--harbor-error) / 0.05)",
                      }}
                    >
                      <h3
                        className="text-lg font-semibold"
                        style={{ color: "hsl(var(--harbor-error))" }}
                      >
                        Delete Account
                      </h3>
                      <button
                        onClick={() => setShowDeleteModal(false)}
                        className="p-1 rounded-lg transition-colors duration-200"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      >
                        <XIcon className="w-5 h-5" />
                      </button>
                    </div>
        
                    {/* Modal body */}
                    <div className="p-6 space-y-4">
                      <div
                        className="p-4 rounded-lg"
                        style={{
                          background: "hsl(var(--harbor-error) / 0.1)",
                          border: "1px solid hsl(var(--harbor-error) / 0.2)",
                        }}
                      >
                        <p
                          className="text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-error))" }}
                        >
                          Warning: This action is irreversible
                        </p>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Deleting your account will permanently remove:
                        </p>
                        <ul
                          className="text-sm mt-2 ml-4 space-y-1 list-disc"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          <li>Your identity and cryptographic keys</li>
                          <li>All messages and conversations</li>
                          <li>All posts and media</li>
                          <li>Your contacts and permissions</li>
                        </ul>
                      </div>
        
                      <div>
                        <label
                          className="block text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Type <span style={{ color: "hsl(var(--harbor-error))" }}>DELETE</span> to confirm
                        </label>
                        <input
                          type="text"
                          value={deleteConfirmText}
                          onChange={(e) => setDeleteConfirmText(e.target.value)}
                          placeholder="Type DELETE"
                          className="w-full px-4 py-3 rounded-lg text-sm"
                          style={{
                            background: "hsl(var(--harbor-surface-1))",
                            border: "1px solid hsl(var(--harbor-border-subtle))",
                            color: "hsl(var(--harbor-text-primary))",
                          }}
                        />
                      </div>
        
                      <div>
                        <label
                          className="block text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Enter your passphrase
                        </label>
                        <PasswordInput
                          placeholder="Your passphrase"
                          value={deletePassphrase}
                          onChange={setDeletePassphrase}
                        />
                      </div>
        
                      {deleteError && (
                        <p className="text-sm" style={{ color: "hsl(var(--harbor-error))" }}>
                          {deleteError}
                        </p>
                      )}
                    </div>
        
                    {/* Modal footer */}
                    <div
                      className="px-6 py-4 flex gap-3 border-t"
                      style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                    >
                      <button
                        onClick={() => setShowDeleteModal(false)}
                        className="flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-colors duration-200"
                        style={{
                          background: "hsl(var(--harbor-surface-1))",
                          color: "hsl(var(--harbor-text-primary))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        Cancel
                      </button>
                      <button
                        onClick={confirmDeleteIdentity}
                        disabled={deleteConfirmText !== "DELETE" || isDeleting}
                        className="flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                        style={{
                          background: "hsl(var(--harbor-error))",
                          color: "white",
                        }}
                      >
                        {isDeleting ? "Deleting..." : "Delete Account Forever"}
                      </button>
                    </div>
                  </div>
                </div>
              )}
        
              {/* Import/Recover Modal */}
              {showImportModal && (
                <div
                  className="fixed inset-0 flex items-center justify-center z-50 p-4"
                  style={{ background: "rgba(0, 0, 0, 0.6)" }}
                >
                  <div
                    className="w-full max-w-md rounded-lg overflow-hidden"
                    style={{
                      background: "hsl(var(--harbor-bg-elevated))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                    }}
                  >
                    {/* Modal header */}
                    <div
                      className="px-6 py-4 flex items-center justify-between border-b"
                      style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                    >
                      <h3
                        className="text-lg font-semibold"
                        style={{ color: "hsl(var(--harbor-text-primary))" }}
                      >
                        Recover Account
                      </h3>
                      <button
                        onClick={() => {
                          setShowImportModal(false);
                          setImportFile(null);
                        }}
                        className="p-1 rounded-lg transition-colors duration-200"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      >
                        <XIcon className="w-5 h-5" />
                      </button>
                    </div>
        
                    {/* Modal body */}
                    <div className="p-6 space-y-4">
                      {/* Explanation section */}
                      <div
                        className="p-4 rounded-lg"
                        style={{
                          background: "hsl(var(--harbor-surface-1))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        <h4
                          className="text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          What is account recovery?
                        </h4>
                        <p
                          className="text-sm"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          If you previously exported a backup of your Harbor identity, you can use it to restore your account on this device. Your backup file contains your encrypted cryptographic keys.
                        </p>
                      </div>
        
                      <div
                        className="p-4 rounded-lg"
                        style={{
                          background: "hsl(var(--harbor-primary) / 0.1)",
                          border: "1px solid hsl(var(--harbor-primary) / 0.2)",
                        }}
                      >
                        <p
                          className="text-sm font-medium mb-1"
                          style={{ color: "hsl(var(--harbor-primary))" }}
                        >
                          Selected backup file
                        </p>
                        <p
                          className="text-sm truncate"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          {importFile?.name}
                        </p>
                      </div>
        
                      <div>
                        <label
                          className="block text-sm font-medium mb-2"
                          style={{ color: "hsl(var(--harbor-text-primary))" }}
                        >
                          Enter backup passphrase
                        </label>
                        <p
                          className="text-sm mb-3"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                        >
                          Enter the passphrase you used when you created this backup. This will decrypt your identity keys.
                        </p>
                        <PasswordInput
                          placeholder="Backup passphrase"
                          value={importPassphrase}
                          onChange={setImportPassphrase}
                        />
                      </div>
        
                      {importError && (
                        <p className="text-sm" style={{ color: "hsl(var(--harbor-error))" }}>
                          {importError}
                        </p>
                      )}
        
                      <p
                        className="text-xs"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      >
                        Note: Recovering an account will replace your current identity if you have one.
                      </p>
                    </div>
        
                    {/* Modal footer */}
                    <div
                      className="px-6 py-4 flex gap-3 border-t"
                      style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                    >
                      <button
                        onClick={() => {
                          setShowImportModal(false);
                          setImportFile(null);
                        }}
                        className="flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-colors duration-200"
                        style={{
                          background: "hsl(var(--harbor-surface-1))",
                          color: "hsl(var(--harbor-text-primary))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        Cancel
                      </button>
                      <button
                        onClick={handleImportIdentity}
                        className="flex-1 px-4 py-3 rounded-lg text-sm font-medium transition-colors duration-200"
                        style={{
                          background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                          color: "white",
                        }}
                      >
                        Recover Account
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }
        ```

      - ğŸ“„ **Wall.tsx**

        ğŸ“„ *File Path*: `.\src\pages\Wall.tsx`
        *Size*: 21401 bytes | *Modified*: 2026-01-17 06:25:30

        ```
        import { useState, useRef } from "react";
        import toast from "react-hot-toast";
        import { useIdentityStore, useMockPeersStore } from "../stores";
        import {
          WallIcon,
          EllipsisIcon,
        } from "../components/icons";
        
        export function WallPage() {
          const { state } = useIdentityStore();
          const { userPosts, addUserPost, likeUserPost, deleteUserPost } = useMockPeersStore();
          const [newPost, setNewPost] = useState("");
          const [isComposing, setIsComposing] = useState(false);
          const [pendingMedia, setPendingMedia] = useState<{ type: "image" | "video"; url: string; name: string }[]>([]);
          const [showPostMenu, setShowPostMenu] = useState<string | null>(null);
          const fileInputRef = useRef<HTMLInputElement>(null);
          const mediaTypeRef = useRef<"image" | "video">("image");
        
          const identity = state.status === "unlocked" ? state.identity : null;
        
          const formatDate = (date: Date) => {
            const now = new Date();
            const diff = now.getTime() - date.getTime();
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
        
            if (hours < 1) return "Just now";
            if (hours < 24) return `${hours}h ago`;
            if (days < 7) return `${days}d ago`;
            return date.toLocaleDateString("en-US", {
              month: "short",
              day: "numeric",
              year: date.getFullYear() !== now.getFullYear() ? "numeric" : undefined
            });
          };
        
          const getInitials = (name: string) => {
            return name
              .split(" ")
              .map((n) => n[0])
              .join("")
              .toUpperCase()
              .slice(0, 2);
          };
        
          const handlePost = () => {
            if (!newPost.trim() && pendingMedia.length === 0) return;
        
            addUserPost(newPost.trim(), pendingMedia.length > 0 ? pendingMedia : undefined);
            setNewPost("");
            setPendingMedia([]);
            setIsComposing(false);
            toast.success("Post published!");
          };
        
          const handleLike = (postId: string) => {
            likeUserPost(postId);
          };
        
          const handleAddMedia = (type: "image" | "video") => {
            mediaTypeRef.current = type;
            if (fileInputRef.current) {
              fileInputRef.current.accept = type === "image" ? "image/*" : "video/*";
              fileInputRef.current.click();
            }
          };
        
          const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
            const file = e.target.files?.[0];
            if (!file) return;
        
            // Check file size (max 10MB)
            if (file.size > 10 * 1024 * 1024) {
              toast.error("File size must be less than 10MB");
              return;
            }
        
            // Create object URL for preview
            const url = URL.createObjectURL(file);
            setPendingMedia([...pendingMedia, {
              type: mediaTypeRef.current,
              url,
              name: file.name
            }]);
            toast.success(`${mediaTypeRef.current === "image" ? "Image" : "Video"} added!`);
        
            // Reset file input
            if (fileInputRef.current) {
              fileInputRef.current.value = "";
            }
          };
        
          const handleRemoveMedia = (index: number) => {
            const media = pendingMedia[index];
            URL.revokeObjectURL(media.url);
            setPendingMedia(pendingMedia.filter((_, i) => i !== index));
          };
        
          const handleShare = (postId: string) => {
            const post = userPosts.find(p => p.id === postId);
            if (post) {
              navigator.clipboard.writeText(post.content.slice(0, 100) + "...");
              toast.success("Post link copied to clipboard");
            }
          };
        
          const handleDeletePost = (postId: string) => {
            deleteUserPost(postId);
            setShowPostMenu(null);
            toast.success("Post deleted");
          };
        
          return (
            <div
              className="h-full flex flex-col"
              style={{ background: "hsl(var(--harbor-bg-primary))" }}
            >
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                onChange={handleFileChange}
                className="hidden"
              />
        
              {/* Header */}
              <header
                className="px-6 py-4 border-b flex-shrink-0"
                style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
              >
                <div className="max-w-3xl mx-auto">
                  <h1
                    className="text-2xl font-bold"
                    style={{ color: "hsl(var(--harbor-text-primary))" }}
                  >
                    Journal
                  </h1>
                  <p
                    className="text-sm mt-1"
                    style={{ color: "hsl(var(--harbor-text-secondary))" }}
                  >
                    Share your thoughts and creations
                  </p>
                </div>
              </header>
        
              <div className="flex-1 overflow-y-auto p-6">
                <div className="max-w-3xl mx-auto space-y-8">
                  {/* Composer - blog style */}
                  <div
                    className="rounded-lg overflow-hidden"
                    style={{
                      background: "hsl(var(--harbor-bg-elevated))",
                      border: "1px solid hsl(var(--harbor-border-subtle))",
                    }}
                  >
                    {/* Composer header */}
                    <div
                      className="px-5 py-3 border-b"
                      style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                    >
                      <div className="flex items-center gap-3">
                        {identity && (
                          <div
                            className="w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold text-white"
                            style={{
                              background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                            }}
                          >
                            {getInitials(identity.displayName)}
                          </div>
                        )}
                        <div>
                          <p
                            className="font-medium text-sm"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {identity?.displayName || "You"}
                          </p>
                          <p
                            className="text-xs"
                            style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                          >
                            Creating a new post
                          </p>
                        </div>
                      </div>
                    </div>
        
                    {/* Composer body */}
                    <div className="p-5">
                      <textarea
                        placeholder="Share your thoughts, ideas, or creative work..."
                        value={newPost}
                        onChange={(e) => {
                          setNewPost(e.target.value);
                          setIsComposing(true);
                        }}
                        onFocus={() => setIsComposing(true)}
                        rows={isComposing ? 6 : 3}
                        className="w-full resize-none text-base leading-relaxed"
                        style={{
                          background: "transparent",
                          border: "none",
                          outline: "none",
                          color: "hsl(var(--harbor-text-primary))",
                        }}
                      />
        
                      {/* Pending media preview */}
                      {pendingMedia.length > 0 && (
                        <div className="mt-4 flex flex-wrap gap-3">
                          {pendingMedia.map((media, index) => (
                            <div
                              key={index}
                              className="relative rounded-lg overflow-hidden"
                              style={{ background: "hsl(var(--harbor-surface-1))" }}
                            >
                              {media.type === "image" ? (
                                <img
                                  src={media.url}
                                  alt={media.name}
                                  className="w-32 h-32 object-cover"
                                />
                              ) : (
                                <video
                                  src={media.url}
                                  className="w-32 h-32 object-cover"
                                />
                              )}
                              <button
                                onClick={() => handleRemoveMedia(index)}
                                className="absolute top-1 right-1 w-6 h-6 rounded-full flex items-center justify-center"
                                style={{
                                  background: "hsl(var(--harbor-error))",
                                  color: "white",
                                }}
                              >
                                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                              </button>
                              <div
                                className="absolute bottom-0 left-0 right-0 px-2 py-1 text-xs truncate"
                                style={{
                                  background: "rgba(0,0,0,0.6)",
                                  color: "white",
                                }}
                              >
                                {media.name}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
        
                    {/* Composer footer */}
                    <div
                      className="px-5 py-3 border-t flex items-center justify-between"
                      style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                    >
                      <div className="flex items-center gap-1">
                        <button
                          onClick={() => handleAddMedia("image")}
                          className="p-2 rounded-lg transition-colors duration-200 hover:bg-white/5"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                          title="Add image"
                        >
                          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                          </svg>
                        </button>
                        <button
                          onClick={() => handleAddMedia("video")}
                          className="p-2 rounded-lg transition-colors duration-200 hover:bg-white/5"
                          style={{ color: "hsl(var(--harbor-text-secondary))" }}
                          title="Add video"
                        >
                          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                          </svg>
                        </button>
                      </div>
        
                      <div className="flex items-center gap-2">
                        {isComposing && (
                          <button
                            onClick={() => {
                              setIsComposing(false);
                              setNewPost("");
                              pendingMedia.forEach(m => URL.revokeObjectURL(m.url));
                              setPendingMedia([]);
                            }}
                            className="px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200"
                            style={{ color: "hsl(var(--harbor-text-secondary))" }}
                          >
                            Cancel
                          </button>
                        )}
                        <button
                          onClick={handlePost}
                          disabled={!newPost.trim() && pendingMedia.length === 0}
                          className="px-5 py-2 rounded-lg text-sm font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                          style={{
                            background: (newPost.trim() || pendingMedia.length > 0)
                              ? "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))"
                              : "hsl(var(--harbor-surface-2))",
                            color: (newPost.trim() || pendingMedia.length > 0) ? "white" : "hsl(var(--harbor-text-tertiary))",
                            boxShadow: (newPost.trim() || pendingMedia.length > 0)
                              ? "0 4px 12px hsl(var(--harbor-primary) / 0.3)"
                              : "none",
                          }}
                        >
                          Publish
                        </button>
                      </div>
                    </div>
                  </div>
        
                  {/* Posts - blog style with less rounded corners */}
                  {userPosts.length === 0 ? (
                    <div className="text-center py-16">
                      <div
                        className="w-20 h-20 rounded-lg flex items-center justify-center mx-auto mb-4"
                        style={{ background: "hsl(var(--harbor-surface-1))" }}
                      >
                        <WallIcon
                          className="w-10 h-10"
                          style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                        />
                      </div>
                      <h3
                        className="text-lg font-semibold mb-2"
                        style={{ color: "hsl(var(--harbor-text-primary))" }}
                      >
                        No posts yet
                      </h3>
                      <p
                        className="text-sm max-w-xs mx-auto"
                        style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                      >
                        Share your first post with your contacts. Your posts are stored locally and shared peer-to-peer.
                      </p>
                    </div>
                  ) : (
                    userPosts.map((post) => (
                      <article
                        key={post.id}
                        className="rounded-lg overflow-hidden"
                        style={{
                          background: "hsl(var(--harbor-bg-elevated))",
                          border: "1px solid hsl(var(--harbor-border-subtle))",
                        }}
                      >
                        {/* Post header */}
                        <div
                          className="px-5 py-4 flex items-center justify-between border-b"
                          style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                        >
                          <div className="flex items-center gap-3">
                            {identity && (
                              <div
                                className="w-10 h-10 rounded-full flex items-center justify-center text-sm font-semibold text-white"
                                style={{
                                  background: "linear-gradient(135deg, hsl(var(--harbor-primary)), hsl(var(--harbor-accent)))",
                                }}
                              >
                                {getInitials(identity.displayName)}
                              </div>
                            )}
                            <div>
                              <p
                                className="font-semibold text-sm"
                                style={{ color: "hsl(var(--harbor-text-primary))" }}
                              >
                                {identity?.displayName || "You"}
                              </p>
                              <p
                                className="text-xs"
                                style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                              >
                                {formatDate(post.timestamp)}
                              </p>
                            </div>
                          </div>
        
                          <div className="relative">
                            <button
                              onClick={() => setShowPostMenu(showPostMenu === post.id ? null : post.id)}
                              className="p-2 rounded-lg transition-colors duration-200"
                              style={{ color: "hsl(var(--harbor-text-tertiary))" }}
                            >
                              <EllipsisIcon className="w-5 h-5" />
                            </button>
        
                            {/* Post menu dropdown */}
                            {showPostMenu === post.id && (
                              <div
                                className="absolute right-0 top-full mt-1 w-40 rounded-lg overflow-hidden z-10"
                                style={{
                                  background: "hsl(var(--harbor-bg-elevated))",
                                  border: "1px solid hsl(var(--harbor-border-subtle))",
                                  boxShadow: "0 10px 40px rgba(0,0,0,0.3)",
                                }}
                              >
                                <button
                                  onClick={() => {
                                    toast("Edit feature coming soon!");
                                    setShowPostMenu(null);
                                  }}
                                  className="w-full px-4 py-2.5 text-left text-sm transition-colors hover:bg-white/5"
                                  style={{ color: "hsl(var(--harbor-text-primary))" }}
                                >
                                  Edit post
                                </button>
                                <button
                                  onClick={() => handleDeletePost(post.id)}
                                  className="w-full px-4 py-2.5 text-left text-sm transition-colors hover:bg-white/5"
                                  style={{ color: "hsl(var(--harbor-error))" }}
                                >
                                  Delete post
                                </button>
                              </div>
                            )}
                          </div>
                        </div>
        
                        {/* Post content */}
                        <div className="px-5 py-5">
                          <p
                            className="text-base leading-relaxed whitespace-pre-wrap"
                            style={{ color: "hsl(var(--harbor-text-primary))" }}
                          >
                            {post.content}
                          </p>
        
                          {/* Post media */}
                          {post.media && post.media.length > 0 && (
                            <div className="mt-4 flex flex-wrap gap-3">
                              {post.media.map((media, index) => (
                                <div
                                  key={index}
                                  className="rounded-lg overflow-hidden"
                                  style={{ background: "hsl(var(--harbor-surface-1))" }}
                                >
                                  {media.type === "image" ? (
                                    <img
                                      src={media.url}
                                      alt={media.name || "Image"}
                                      className="max-w-full max-h-96 object-contain"
                                    />
                                  ) : (
                                    <video
                                      src={media.url}
                                      controls
                                      className="max-w-full max-h-96"
                                    />
                                  )}
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
        
                        {/* Post actions */}
                        <div
                          className="px-5 py-3 flex items-center gap-6 border-t"
                          style={{ borderColor: "hsl(var(--harbor-border-subtle))" }}
                        >
                          <button
                            onClick={() => handleLike(post.id)}
                            className="flex items-center gap-2 transition-colors duration-200"
                            style={{
                              color: post.liked
                                ? "hsl(var(--harbor-error))"
                                : "hsl(var(--harbor-text-secondary))",
                            }}
                          >
                            <svg
                              className="w-5 h-5"
                              fill={post.liked ? "currentColor" : "none"}
                              viewBox="0 0 24 24"
                              stroke="currentColor"
                            >
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                            </svg>
                            <span className="text-sm">{post.likes}</span>
                          </button>
        
                          <button
                            onClick={() => toast("Comments coming soon!")}
                            className="flex items-center gap-2 transition-colors duration-200"
                            style={{ color: "hsl(var(--harbor-text-secondary))" }}
                          >
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                            </svg>
                            <span className="text-sm">{post.comments}</span>
                          </button>
        
                          <button
                            onClick={() => handleShare(post.id)}
                            className="flex items-center gap-2 transition-colors duration-200 ml-auto"
                            style={{ color: "hsl(var(--harbor-text-secondary))" }}
                          >
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                            </svg>
                            <span className="text-sm">Share</span>
                          </button>
                        </div>
                      </article>
                    ))
                  )}
                </div>
              </div>
        
              {/* Click outside to close menu */}
              {showPostMenu && (
                <div
                  className="fixed inset-0 z-0"
                  onClick={() => setShowPostMenu(null)}
                />
              )}
            </div>
          );
        }
        ```

      - ğŸ“„ **index.ts**

        ğŸ“„ *File Path*: `.\src\pages\index.ts`
        *Size*: 189 bytes | *Modified*: 2026-01-16 17:19:05

        ```
        export { ChatPage } from "./Chat";
        export { WallPage } from "./Wall";
        export { FeedPage } from "./Feed";
        export { NetworkPage } from "./Network";
        export { SettingsPage } from "./Settings";
        ```

    - ğŸ“ **services/**
      - ğŸ“„ **calling.ts**

        ğŸ“„ *File Path*: `.\src\services\calling.ts`
        *Size*: 2887 bytes | *Modified*: 2026-01-17 04:26:01

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type {
          OfferResult,
          AnswerResult,
          IceResult,
          HangupResult,
          HangupReason,
        } from "../types";
        
        /** Calling service - wraps Tauri commands for voice calling */
        export const callingService = {
          /** Start a call (create an offer) */
          async startCall(calleePeerId: string, sdp: string): Promise<OfferResult> {
            return invoke<OfferResult>("start_call", { calleePeerId, sdp });
          },
        
          /** Answer a call */
          async answerCall(
            callId: string,
            callerPeerId: string,
            sdp: string
          ): Promise<AnswerResult> {
            return invoke<AnswerResult>("answer_call", { callId, callerPeerId, sdp });
          },
        
          /** Send an ICE candidate */
          async sendIceCandidate(
            callId: string,
            candidate: string,
            sdpMid?: string,
            sdpMlineIndex?: number
          ): Promise<IceResult> {
            return invoke<IceResult>("send_ice_candidate", {
              callId,
              candidate,
              sdpMid,
              sdpMlineIndex,
            });
          },
        
          /** Hang up a call */
          async hangupCall(
            callId: string,
            reason?: HangupReason
          ): Promise<HangupResult> {
            return invoke<HangupResult>("hangup_call", { callId, reason });
          },
        
          /** Process an incoming offer (validate it) */
          async processOffer(
            callId: string,
            callerPeerId: string,
            calleePeerId: string,
            sdp: string,
            timestamp: number,
            signature: number[]
          ): Promise<void> {
            return invoke<void>("process_offer", {
              callId,
              callerPeerId,
              calleePeerId,
              sdp,
              timestamp,
              signature,
            });
          },
        
          /** Process an incoming answer (validate it) */
          async processAnswer(
            callId: string,
            callerPeerId: string,
            calleePeerId: string,
            sdp: string,
            timestamp: number,
            signature: number[]
          ): Promise<void> {
            return invoke<void>("process_answer", {
              callId,
              callerPeerId,
              calleePeerId,
              sdp,
              timestamp,
              signature,
            });
          },
        
          /** Process an incoming ICE candidate (validate it) */
          async processIceCandidate(
            callId: string,
            senderPeerId: string,
            candidate: string,
            sdpMid: string | undefined,
            sdpMlineIndex: number | undefined,
            timestamp: number,
            signature: number[]
          ): Promise<void> {
            return invoke<void>("process_ice_candidate", {
              callId,
              senderPeerId,
              candidate,
              sdpMid,
              sdpMlineIndex,
              timestamp,
              signature,
            });
          },
        
          /** Process an incoming hangup (validate it) */
          async processHangup(
            callId: string,
            senderPeerId: string,
            reason: string,
            timestamp: number,
            signature: number[]
          ): Promise<void> {
            return invoke<void>("process_hangup", {
              callId,
              senderPeerId,
              reason,
              timestamp,
              signature,
            });
          },
        };
        ```

      - ğŸ“„ **contacts.ts**

        ğŸ“„ *File Path*: `.\src\services\contacts.ts`
        *Size*: 2170 bytes | *Modified*: 2026-01-17 11:12:13

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type { Contact, ContactData } from "../types";
        
        /** Contacts service - wraps Tauri commands */
        export const contactsService = {
          /** Get all contacts */
          async getContacts(): Promise<Contact[]> {
            return invoke<Contact[]>("get_contacts");
          },
        
          /** Get active (non-blocked) contacts */
          async getActiveContacts(): Promise<Contact[]> {
            return invoke<Contact[]>("get_active_contacts");
          },
        
          /** Get a specific contact by peer ID */
          async getContact(peerId: string): Promise<Contact | null> {
            return invoke<Contact | null>("get_contact", { peerId });
          },
        
          /** Add a new contact */
          async addContact(contact: ContactData): Promise<number> {
            // Convert base64 strings to byte arrays for the backend
            const publicKey = Array.from(atob(contact.publicKey), (c) =>
              c.charCodeAt(0)
            );
            const x25519Public = Array.from(atob(contact.x25519Public), (c) =>
              c.charCodeAt(0)
            );
            return invoke<number>("add_contact", {
              peerId: contact.peerId,
              publicKey,
              x25519Public,
              displayName: contact.displayName,
              avatarHash: contact.avatarHash ?? null,
              bio: contact.bio ?? null,
            });
          },
        
          /** Block a contact */
          async blockContact(peerId: string): Promise<boolean> {
            return invoke<boolean>("block_contact", { peerId });
          },
        
          /** Unblock a contact */
          async unblockContact(peerId: string): Promise<boolean> {
            return invoke<boolean>("unblock_contact", { peerId });
          },
        
          /** Remove a contact */
          async removeContact(peerId: string): Promise<boolean> {
            return invoke<boolean>("remove_contact", { peerId });
          },
        
          /** Check if a peer is a contact */
          async isContact(peerId: string): Promise<boolean> {
            return invoke<boolean>("is_contact", { peerId });
          },
        
          /** Check if a peer is blocked */
          async isBlocked(peerId: string): Promise<boolean> {
            return invoke<boolean>("is_contact_blocked", { peerId });
          },
        
          /** Request identity exchange with a peer (adds them as a contact) */
          async requestPeerIdentity(peerId: string): Promise<void> {
            return invoke<void>("request_peer_identity", { peerId });
          },
        };
        ```

      - ğŸ“„ **feed.ts**

        ğŸ“„ *File Path*: `.\src\services\feed.ts`
        *Size*: 688 bytes | *Modified*: 2026-01-17 04:19:47

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type { FeedItem } from "../types";
        
        /** Feed service - wraps Tauri commands for feed functionality */
        export const feedService = {
          /** Get the user's feed (posts from contacts) */
          async getFeed(limit?: number, beforeTimestamp?: number): Promise<FeedItem[]> {
            return invoke<FeedItem[]>("get_feed", { limit, beforeTimestamp });
          },
        
          /** Get a specific user's wall */
          async getWall(
            authorPeerId: string,
            limit?: number,
            beforeTimestamp?: number
          ): Promise<FeedItem[]> {
            return invoke<FeedItem[]>("get_wall", {
              authorPeerId,
              limit,
              beforeTimestamp,
            });
          },
        };
        ```

      - ğŸ“„ **identity.ts**

        ğŸ“„ *File Path*: `.\src\services\identity.ts`
        *Size*: 1522 bytes | *Modified*: 2026-01-16 17:14:34

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type { IdentityInfo, CreateIdentityRequest } from "../types";
        
        /** Identity service - wraps Tauri commands */
        export const identityService = {
          /** Check if an identity has been created */
          async hasIdentity(): Promise<boolean> {
            return invoke<boolean>("has_identity");
          },
        
          /** Check if the identity is currently unlocked */
          async isUnlocked(): Promise<boolean> {
            return invoke<boolean>("is_identity_unlocked");
          },
        
          /** Get identity info (public data only) */
          async getIdentityInfo(): Promise<IdentityInfo | null> {
            return invoke<IdentityInfo | null>("get_identity_info");
          },
        
          /** Create a new identity */
          async createIdentity(request: CreateIdentityRequest): Promise<IdentityInfo> {
            return invoke<IdentityInfo>("create_identity", { request });
          },
        
          /** Unlock the identity with passphrase */
          async unlock(passphrase: string): Promise<IdentityInfo> {
            return invoke<IdentityInfo>("unlock_identity", { passphrase });
          },
        
          /** Lock the identity */
          async lock(): Promise<void> {
            return invoke("lock_identity");
          },
        
          /** Update display name */
          async updateDisplayName(displayName: string): Promise<void> {
            return invoke("update_display_name", { displayName });
          },
        
          /** Update bio */
          async updateBio(bio: string | null): Promise<void> {
            return invoke("update_bio", { bio });
          },
        
          /** Get the local peer ID */
          async getPeerId(): Promise<string> {
            return invoke<string>("get_peer_id");
          },
        };
        ```

      - ğŸ“„ **index.ts**

        ğŸ“„ *File Path*: `.\src\services\index.ts`
        *Size*: 359 bytes | *Modified*: 2026-01-17 04:26:20

        ```
        export { identityService } from "./identity";
        export * as networkService from "./network";
        export { contactsService } from "./contacts";
        export { permissionsService } from "./permissions";
        export { messagingService } from "./messaging";
        export { postsService } from "./posts";
        export { feedService } from "./feed";
        export { callingService } from "./calling";
        ```

      - ğŸ“„ **messaging.ts**

        ğŸ“„ *File Path*: `.\src\services\messaging.ts`
        *Size*: 1435 bytes | *Modified*: 2026-01-16 22:58:46

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type { Message, Conversation, SendMessageResult } from "../types";
        
        /** Messaging service - wraps Tauri commands */
        export const messagingService = {
          /** Send a message to a peer */
          async sendMessage(
            peerId: string,
            content: string,
            contentType?: string,
            replyTo?: string
          ): Promise<SendMessageResult> {
            return invoke<SendMessageResult>("send_message", {
              peerId,
              content,
              contentType,
              replyTo,
            });
          },
        
          /** Get messages for a conversation */
          async getMessages(
            peerId: string,
            limit?: number,
            beforeTimestamp?: number
          ): Promise<Message[]> {
            return invoke<Message[]>("get_messages", {
              peerId,
              limit,
              beforeTimestamp,
            });
          },
        
          /** Get all conversations */
          async getConversations(): Promise<Conversation[]> {
            return invoke<Conversation[]>("get_conversations");
          },
        
          /** Mark a conversation as read */
          async markConversationRead(peerId: string): Promise<number> {
            return invoke<number>("mark_conversation_read", { peerId });
          },
        
          /** Get unread count for a conversation */
          async getUnreadCount(peerId: string): Promise<number> {
            return invoke<number>("get_unread_count", { peerId });
          },
        
          /** Get total unread count across all conversations */
          async getTotalUnreadCount(): Promise<number> {
            return invoke<number>("get_total_unread_count");
          },
        };
        ```

      - ğŸ“„ **network.ts**

        ğŸ“„ *File Path*: `.\src\services\network.ts`
        *Size*: 914 bytes | *Modified*: 2026-01-16 17:48:48

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type { PeerInfo, NetworkStats } from "../types";
        
        /** Start the P2P network (requires unlocked identity) */
        export async function startNetwork(): Promise<void> {
          return invoke("start_network");
        }
        
        /** Stop the P2P network */
        export async function stopNetwork(): Promise<void> {
          return invoke("stop_network");
        }
        
        /** Check if the network is running */
        export async function isNetworkRunning(): Promise<boolean> {
          return invoke("is_network_running");
        }
        
        /** Get list of connected peers */
        export async function getConnectedPeers(): Promise<PeerInfo[]> {
          return invoke("get_connected_peers");
        }
        
        /** Get network statistics */
        export async function getNetworkStats(): Promise<NetworkStats> {
          return invoke("get_network_stats");
        }
        
        /** Bootstrap the DHT */
        export async function bootstrapNetwork(): Promise<void> {
          return invoke("bootstrap_network");
        }
        ```

      - ğŸ“„ **permissions.ts**

        ğŸ“„ *File Path*: `.\src\services\permissions.ts`
        *Size*: 1918 bytes | *Modified*: 2026-01-16 21:43:18

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type { Capability, PermissionInfo, GrantResult } from "../types";
        
        /** Permissions service - wraps Tauri commands */
        export const permissionsService = {
          /** Grant a permission to another peer */
          async grantPermission(
            subjectPeerId: string,
            capability: Capability,
            expiresInSeconds?: number | null
          ): Promise<GrantResult> {
            return invoke<GrantResult>("grant_permission", {
              subjectPeerId,
              capability,
              expiresInSeconds,
            });
          },
        
          /** Revoke a permission */
          async revokePermission(grantId: string): Promise<boolean> {
            return invoke<boolean>("revoke_permission", { grantId });
          },
        
          /** Check if a peer has a specific capability (we granted it to them) */
          async peerHasCapability(
            peerId: string,
            capability: Capability
          ): Promise<boolean> {
            return invoke<boolean>("peer_has_capability", { peerId, capability });
          },
        
          /** Check if we have a specific capability from another peer */
          async weHaveCapability(
            issuerPeerId: string,
            capability: Capability
          ): Promise<boolean> {
            return invoke<boolean>("we_have_capability", { issuerPeerId, capability });
          },
        
          /** Get all permissions we've granted */
          async getGrantedPermissions(): Promise<PermissionInfo[]> {
            return invoke<PermissionInfo[]>("get_granted_permissions");
          },
        
          /** Get all permissions granted to us */
          async getReceivedPermissions(): Promise<PermissionInfo[]> {
            return invoke<PermissionInfo[]>("get_received_permissions");
          },
        
          /** Get all peers we can chat with */
          async getChatPeers(): Promise<string[]> {
            return invoke<string[]>("get_chat_peers");
          },
        
          /** Grant all standard permissions (chat, wall_read, call) to a peer */
          async grantAllPermissions(subjectPeerId: string): Promise<GrantResult[]> {
            return invoke<GrantResult[]>("grant_all_permissions", { subjectPeerId });
          },
        };
        ```

      - ğŸ“„ **posts.ts**

        ğŸ“„ *File Path*: `.\src\services\posts.ts`
        *Size*: 2166 bytes | *Modified*: 2026-01-16 23:49:02

        ```
        import { invoke } from "@tauri-apps/api/core";
        import type { Post, PostMedia, PostVisibility, CreatePostResult } from "../types";
        
        /** Posts service - wraps Tauri commands for wall/blog functionality */
        export const postsService = {
          /** Create a new post */
          async createPost(
            contentType: string,
            contentText?: string,
            visibility?: PostVisibility
          ): Promise<CreatePostResult> {
            return invoke<CreatePostResult>("create_post", {
              contentType,
              contentText,
              visibility,
            });
          },
        
          /** Update a post's content */
          async updatePost(postId: string, contentText?: string): Promise<void> {
            return invoke<void>("update_post", { postId, contentText });
          },
        
          /** Delete a post (soft delete) */
          async deletePost(postId: string): Promise<void> {
            return invoke<void>("delete_post", { postId });
          },
        
          /** Get a single post by ID */
          async getPost(postId: string): Promise<Post | null> {
            return invoke<Post | null>("get_post", { postId });
          },
        
          /** Get the local user's posts (their wall) */
          async getMyPosts(limit?: number, beforeTimestamp?: number): Promise<Post[]> {
            return invoke<Post[]>("get_my_posts", { limit, beforeTimestamp });
          },
        
          /** Get posts by a specific author */
          async getPostsByAuthor(
            authorPeerId: string,
            limit?: number,
            beforeTimestamp?: number
          ): Promise<Post[]> {
            return invoke<Post[]>("get_posts_by_author", {
              authorPeerId,
              limit,
              beforeTimestamp,
            });
          },
        
          /** Add media to a post */
          async addPostMedia(
            postId: string,
            mediaHash: string,
            mediaType: string,
            mimeType: string,
            fileName: string,
            fileSize: number,
            width?: number,
            height?: number,
            durationSeconds?: number,
            sortOrder?: number
          ): Promise<void> {
            return invoke<void>("add_post_media", {
              postId,
              mediaHash,
              mediaType,
              mimeType,
              fileName,
              fileSize,
              width,
              height,
              durationSeconds,
              sortOrder,
            });
          },
        
          /** Get media for a post */
          async getPostMedia(postId: string): Promise<PostMedia[]> {
            return invoke<PostMedia[]>("get_post_media", { postId });
          },
        };
        ```

    - ğŸ“ **stores/**
      - ğŸ“„ **contacts.ts**

        ğŸ“„ *File Path*: `.\src\stores\contacts.ts`
        *Size*: 1562 bytes | *Modified*: 2026-01-17 12:19:04

        ```
        import { create } from "zustand";
        import { contactsService } from "../services/contacts";
        import type { Contact } from "../types";
        
        interface ContactsState {
          // State
          contacts: Contact[];
          isLoading: boolean;
          error: string | null;
        
          // Actions
          loadContacts: () => Promise<void>;
          refreshContacts: () => Promise<void>;
          isContact: (peerId: string) => boolean;
          getContact: (peerId: string) => Contact | undefined;
        }
        
        export const useContactsStore = create<ContactsState>((set, get) => ({
          // Initial state
          contacts: [],
          isLoading: false,
          error: null,
        
          // Load all contacts
          loadContacts: async () => {
            set({ isLoading: true, error: null });
            try {
              const contacts = await contactsService.getActiveContacts();
              set({ contacts, isLoading: false });
            } catch (error) {
              console.error("Failed to load contacts:", error);
              set({ error: String(error), isLoading: false });
            }
          },
        
          // Refresh contacts (alias for loadContacts, used after adding new contact)
          refreshContacts: async () => {
            try {
              const contacts = await contactsService.getActiveContacts();
              set({ contacts });
            } catch (error) {
              console.error("Failed to refresh contacts:", error);
            }
          },
        
          // Check if a peer is a contact
          isContact: (peerId: string) => {
            return get().contacts.some((c) => c.peerId === peerId);
          },
        
          // Get a contact by peer ID
          getContact: (peerId: string) => {
            return get().contacts.find((c) => c.peerId === peerId);
          },
        }));
        ```

      - ğŸ“„ **feed.ts**

        ğŸ“„ *File Path*: `.\src\stores\feed.ts`
        *Size*: 2178 bytes | *Modified*: 2026-01-17 12:27:11

        ```
        import { create } from "zustand";
        import { feedService } from "../services/feed";
        import type { FeedItem } from "../types";
        
        interface FeedState {
          // State
          feedItems: FeedItem[];
          isLoading: boolean;
          error: string | null;
          hasMore: boolean;
        
          // Actions
          loadFeed: (limit?: number) => Promise<void>;
          loadMore: (limit?: number) => Promise<void>;
          refreshFeed: () => Promise<void>;
        }
        
        export const useFeedStore = create<FeedState>((set, get) => ({
          // Initial state
          feedItems: [],
          isLoading: false,
          error: null,
          hasMore: true,
        
          // Load initial feed
          loadFeed: async (limit: number = 50) => {
            set({ isLoading: true, error: null });
            try {
              const feedItems = await feedService.getFeed(limit);
              set({
                feedItems,
                isLoading: false,
                hasMore: feedItems.length === limit,
              });
            } catch (error) {
              console.error("Failed to load feed:", error);
              set({ error: String(error), isLoading: false });
            }
          },
        
          // Load more items (pagination)
          loadMore: async (limit: number = 50) => {
            const { feedItems, isLoading, hasMore } = get();
            if (isLoading || !hasMore) return;
        
            set({ isLoading: true });
            try {
              const lastItem = feedItems[feedItems.length - 1];
              const beforeTimestamp = lastItem?.createdAt;
              const newItems = await feedService.getFeed(limit, beforeTimestamp);
        
              set({
                feedItems: [...feedItems, ...newItems],
                isLoading: false,
                hasMore: newItems.length === limit,
              });
            } catch (error) {
              console.error("Failed to load more feed items:", error);
              set({ error: String(error), isLoading: false });
            }
          },
        
          // Refresh feed (reload from beginning)
          refreshFeed: async () => {
            set({ isLoading: true, error: null });
            try {
              const feedItems = await feedService.getFeed(50);
              set({
                feedItems,
                isLoading: false,
                hasMore: feedItems.length === 50,
              });
            } catch (error) {
              console.error("Failed to refresh feed:", error);
              set({ error: String(error), isLoading: false });
            }
          },
        }));
        ```

      - ğŸ“„ **identity.ts**

        ğŸ“„ *File Path*: `.\src\stores\identity.ts`
        *Size*: 3450 bytes | *Modified*: 2026-01-16 17:24:05

        ```
        import { create } from "zustand";
        import type { IdentityState, CreateIdentityRequest } from "../types";
        import { identityService } from "../services";
        
        interface IdentityStore {
          state: IdentityState;
          error: string | null;
        
          // Actions
          initialize: () => Promise<void>;
          createIdentity: (request: CreateIdentityRequest) => Promise<void>;
          unlock: (passphrase: string) => Promise<void>;
          lock: () => Promise<void>;
          updateDisplayName: (displayName: string) => Promise<void>;
          updateBio: (bio: string | null) => Promise<void>;
          clearError: () => void;
        }
        
        export const useIdentityStore = create<IdentityStore>((set, get) => ({
          state: { status: "loading" },
          error: null,
        
          initialize: async () => {
            try {
              set({ state: { status: "loading" }, error: null });
        
              const hasIdentity = await identityService.hasIdentity();
        
              if (!hasIdentity) {
                set({ state: { status: "no_identity" } });
                return;
              }
        
              const identity = await identityService.getIdentityInfo();
              if (!identity) {
                set({ state: { status: "no_identity" } });
                return;
              }
        
              const isUnlocked = await identityService.isUnlocked();
        
              if (isUnlocked) {
                set({ state: { status: "unlocked", identity } });
              } else {
                set({ state: { status: "locked", identity } });
              }
            } catch (err) {
              set({
                state: { status: "no_identity" },
                error: err instanceof Error ? err.message : String(err),
              });
            }
          },
        
          createIdentity: async (request: CreateIdentityRequest) => {
            try {
              set({ error: null });
              const identity = await identityService.createIdentity(request);
              set({ state: { status: "unlocked", identity } });
            } catch (err) {
              set({ error: err instanceof Error ? err.message : String(err) });
              throw err;
            }
          },
        
          unlock: async (passphrase: string) => {
            try {
              set({ error: null });
              const identity = await identityService.unlock(passphrase);
              set({ state: { status: "unlocked", identity } });
            } catch (err) {
              set({ error: err instanceof Error ? err.message : String(err) });
              throw err;
            }
          },
        
          lock: async () => {
            try {
              await identityService.lock();
              const { state } = get();
              if (state.status === "unlocked") {
                set({ state: { status: "locked", identity: state.identity } });
              }
            } catch (err) {
              set({ error: err instanceof Error ? err.message : String(err) });
            }
          },
        
          updateDisplayName: async (displayName: string) => {
            try {
              await identityService.updateDisplayName(displayName);
              const { state } = get();
              if (state.status === "unlocked" || state.status === "locked") {
                set({
                  state: {
                    ...state,
                    identity: { ...state.identity, displayName },
                  },
                });
              }
            } catch (err) {
              set({ error: err instanceof Error ? err.message : String(err) });
            }
          },
        
          updateBio: async (bio: string | null) => {
            try {
              await identityService.updateBio(bio);
              const { state } = get();
              if (state.status === "unlocked" || state.status === "locked") {
                set({
                  state: {
                    ...state,
                    identity: { ...state.identity, bio },
                  },
                });
              }
            } catch (err) {
              set({ error: err instanceof Error ? err.message : String(err) });
            }
          },
        
          clearError: () => set({ error: null }),
        }));
        ```

      - ğŸ“„ **index.ts**

        ğŸ“„ *File Path*: `.\src\stores\index.ts`
        *Size*: 430 bytes | *Modified*: 2026-01-17 12:27:32

        ```
        export { useIdentityStore } from "./identity";
        export { useNetworkStore } from "./network";
        export { useMessagingStore } from "./messaging";
        export { useContactsStore } from "./contacts";
        export { useFeedStore } from "./feed";
        export { useMockPeersStore } from "./mockPeers";
        export { useSettingsStore } from "./settings";
        export type { MockPeer, MockPost, MockConversation, MockMessage, UserPost, SavedPost } from "./mockPeers";
        ```

      - ğŸ“„ **messaging.ts**

        ğŸ“„ *File Path*: `.\src\stores\messaging.ts`
        *Size*: 4115 bytes | *Modified*: 2026-01-17 11:13:40

        ```
        import { create } from "zustand";
        import { invoke } from "@tauri-apps/api/core";
        import type { Message, Conversation, SendMessageResult } from "../types";
        
        interface MessagingState {
          // State
          conversations: Conversation[];
          messages: Record<string, Message[]>; // keyed by peerId
          activeConversation: string | null;
          isLoading: boolean;
          error: string | null;
        
          // Actions
          loadConversations: () => Promise<void>;
          loadMessages: (peerId: string) => Promise<void>;
          sendMessage: (
            peerId: string,
            content: string,
            contentType?: string
          ) => Promise<SendMessageResult>;
          setActiveConversation: (peerId: string | null) => void;
          handleIncomingMessage: (message: Message) => void;
          markConversationRead: (peerId: string) => Promise<void>;
        }
        
        export const useMessagingStore = create<MessagingState>((set, get) => ({
          // Initial state
          conversations: [],
          messages: {},
          activeConversation: null,
          isLoading: false,
          error: null,
        
          // Load all conversations
          loadConversations: async () => {
            set({ isLoading: true, error: null });
            try {
              const conversations = await invoke<Conversation[]>("get_conversations");
              set({ conversations, isLoading: false });
            } catch (error) {
              console.error("Failed to load conversations:", error);
              set({ error: String(error), isLoading: false });
            }
          },
        
          // Load messages for a specific conversation
          loadMessages: async (peerId: string) => {
            set({ isLoading: true, error: null });
            try {
              const messages = await invoke<Message[]>("get_messages", {
                peerId,
                limit: 100,
              });
              set((state) => ({
                messages: { ...state.messages, [peerId]: messages },
                isLoading: false,
              }));
            } catch (error) {
              console.error("Failed to load messages:", error);
              set({ error: String(error), isLoading: false });
            }
          },
        
          // Send a message
          sendMessage: async (
            peerId: string,
            content: string,
            contentType: string = "text"
          ) => {
            try {
              const result = await invoke<SendMessageResult>("send_message", {
                peerId,
                content,
                contentType,
              });
        
              // Add the sent message to local state optimistically
              const newMessage: Message = {
                messageId: result.messageId,
                conversationId: result.conversationId,
                senderPeerId: "", // Will be filled by backend
                recipientPeerId: peerId,
                content,
                contentType,
                replyToMessageId: null,
                sentAt: result.sentAt,
                deliveredAt: null,
                readAt: null,
                status: "sent",
                isOutgoing: true,
              };
        
              set((state) => ({
                messages: {
                  ...state.messages,
                  [peerId]: [...(state.messages[peerId] || []), newMessage],
                },
              }));
        
              // Refresh conversations to update last message
              get().loadConversations();
        
              return result;
            } catch (error) {
              console.error("Failed to send message:", error);
              throw error;
            }
          },
        
          // Set active conversation
          setActiveConversation: (peerId: string | null) => {
            set({ activeConversation: peerId });
            if (peerId) {
              get().loadMessages(peerId);
            }
          },
        
          // Handle incoming message from Tauri event
          handleIncomingMessage: (message: Message) => {
            const peerId = message.isOutgoing
              ? message.recipientPeerId
              : message.senderPeerId;
        
            set((state) => ({
              messages: {
                ...state.messages,
                [peerId]: [...(state.messages[peerId] || []), message],
              },
            }));
        
            // Refresh conversations to update last message
            get().loadConversations();
          },
        
          // Mark conversation as read
          markConversationRead: async (peerId: string) => {
            try {
              await invoke("mark_conversation_read", { peerId });
              // Refresh conversations to update unread count
              get().loadConversations();
            } catch (error) {
              console.error("Failed to mark conversation read:", error);
            }
          },
        }));
        ```

      - ğŸ“„ **mockPeers.ts**

        ğŸ“„ *File Path*: `.\src\stores\mockPeers.ts`
        *Size*: 19786 bytes | *Modified*: 2026-01-17 06:24:08

        ```
        import { create } from "zustand";
        
        // Types for mock peer data
        export interface MockPost {
          id: string;
          content: string;
          timestamp: Date;
          likes: number;
          comments: number;
          media?: { type: "image" | "video"; url: string }[];
        }
        
        export interface MockPeer {
          id: string;
          peerId: string;
          name: string;
          bio: string;
          online: boolean;
          avatarGradient: string;
          wall: MockPost[];
        }
        
        export interface MockMessage {
          id: string;
          content: string;
          timestamp: Date;
          isMine: boolean;
        }
        
        export interface MockConversation {
          id: string;
          peerId: string;
          name: string;
          online: boolean;
          avatarGradient: string;
          lastMessage: string;
          timestamp: Date;
          unread: number;
          messages: MockMessage[];
        }
        
        // Auto-reply responses based on keywords
        const autoReplies: { keywords: string[]; responses: string[] }[] = [
          {
            keywords: ["hello", "hi", "hey", "sup"],
            responses: [
              "Hey there! How's it going?",
              "Hi! Great to hear from you!",
              "Hello! What's up?",
            ],
          },
          {
            keywords: ["how are you", "how's it going", "what's up"],
            responses: [
              "I'm doing great, thanks for asking! How about you?",
              "Pretty good! Just working on some projects. You?",
              "Can't complain! What's new with you?",
            ],
          },
          {
            keywords: ["harbor", "app", "project"],
            responses: [
              "Harbor is such a cool project! The P2P architecture is really impressive.",
              "I love how Harbor keeps everything decentralized. No data harvesting!",
              "The encryption in Harbor makes me feel so much safer about my messages.",
            ],
          },
          {
            keywords: ["p2p", "peer", "network", "libp2p"],
            responses: [
              "Peer-to-peer is the future! Centralized services are so 2010s.",
              "I've been learning a lot about libp2p lately. It's fascinating stuff!",
              "The NAT traversal in P2P apps is getting really good these days.",
            ],
          },
          {
            keywords: ["thanks", "thank you", "appreciate"],
            responses: [
              "You're welcome! Happy to help!",
              "No problem at all!",
              "Anytime! That's what friends are for.",
            ],
          },
          {
            keywords: ["bye", "goodbye", "see you", "later"],
            responses: [
              "See you later! Take care!",
              "Goodbye! Chat soon!",
              "Later! Have a great day!",
            ],
          },
          {
            keywords: ["?"],
            responses: [
              "That's a good question! Let me think about it...",
              "Hmm, I'm not entirely sure. What do you think?",
              "Interesting question! I'd need to look into that more.",
            ],
          },
        ];
        
        // Default responses when no keywords match
        const defaultResponses = [
          "That's interesting! Tell me more.",
          "I see what you mean.",
          "Yeah, I totally agree with that.",
          "That makes sense!",
          "Oh nice! Sounds cool.",
          "Haha, yeah!",
          "I was just thinking the same thing!",
          "For sure! That's a great point.",
        ];
        
        // Generate a response based on the incoming message
        function generateAutoReply(message: string): string {
          const lowerMessage = message.toLowerCase();
        
          // Check for keyword matches
          for (const rule of autoReplies) {
            if (rule.keywords.some((keyword) => lowerMessage.includes(keyword))) {
              return rule.responses[Math.floor(Math.random() * rule.responses.length)];
            }
          }
        
          // Return a default response
          return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
        }
        
        // Avatar gradients for visual variety
        const avatarGradients = [
          "linear-gradient(135deg, hsl(220 91% 54%), hsl(262 83% 58%))",
          "linear-gradient(135deg, hsl(262 83% 58%), hsl(330 81% 60%))",
          "linear-gradient(135deg, hsl(152 69% 40%), hsl(180 70% 45%))",
          "linear-gradient(135deg, hsl(36 90% 55%), hsl(15 80% 55%))",
          "linear-gradient(135deg, hsl(200 80% 50%), hsl(220 91% 54%))",
          "linear-gradient(135deg, hsl(340 75% 55%), hsl(10 80% 60%))",
        ];
        
        // Create mock peers with their own walls
        const mockPeers: MockPeer[] = [
          {
            id: "peer-alice",
            peerId: "12D3KooWAbCdEfGhIjKlMnOpQrStUvWxYz",
            name: "Alice Chen",
            bio: "Full-stack developer passionate about decentralized systems. Building the future of communication.",
            online: true,
            avatarGradient: avatarGradients[0],
            wall: [
              {
                id: "alice-1",
                content:
                  "Just deployed my first smart contract on Ethereum! The gas fees were brutal but the satisfaction of seeing it work was worth it. Next step: optimizing for L2 solutions. ğŸš€",
                timestamp: new Date(Date.now() - 1000 * 60 * 30),
                likes: 24,
                comments: 8,
              },
              {
                id: "alice-2",
                content:
                  "Hot take: The best code is the code you don't write. Every line is a liability. Simplicity wins every time.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 4),
                likes: 45,
                comments: 12,
              },
              {
                id: "alice-3",
                content:
                  "Reading 'The Network State' by Balaji. Fascinating ideas about how digital communities can evolve into something more. What are your thoughts on decentralized governance?",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 12),
                likes: 18,
                comments: 5,
              },
            ],
          },
          {
            id: "peer-bob",
            peerId: "12D3KooWXyZaBcDeFgHiJkLmNoPqRsTuVw",
            name: "Bob Wilson",
            bio: "Systems engineer. Rust enthusiast. Making computers go brrr.",
            online: true,
            avatarGradient: avatarGradients[1],
            wall: [
              {
                id: "bob-1",
                content:
                  "Just hit 1 million messages processed per second on our new message queue. The secret? Zero-copy buffers and careful memory alignment. Performance matters!",
                timestamp: new Date(Date.now() - 1000 * 60 * 45),
                likes: 67,
                comments: 21,
              },
              {
                id: "bob-2",
                content:
                  "Excited to announce that I'm joining the Harbor project as a contributor! Looking forward to building the future of decentralized communication together.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 8),
                likes: 89,
                comments: 34,
              },
              {
                id: "bob-3",
                content:
                  "Debugging tip: When you're stuck, explain the problem to a rubber duck. If that doesn't work, take a walk. The solution often comes when you stop forcing it.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24),
                likes: 156,
                comments: 28,
              },
            ],
          },
          {
            id: "peer-carol",
            peerId: "12D3KooWQrStUvWxYzAbCdEfGhIjKlMnOp",
            name: "Carol Davis",
            bio: "UX designer turned developer. Making tech accessible and beautiful.",
            online: false,
            avatarGradient: avatarGradients[2],
            wall: [
              {
                id: "carol-1",
                content:
                  "Design tip: The best interface is no interface. Before adding a new screen or dialog, ask yourself: can the system figure this out automatically?",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2),
                likes: 78,
                comments: 15,
              },
              {
                id: "carol-2",
                content:
                  "Tip for fellow developers: When working with libp2p, make sure to handle peer disconnections gracefully. The network is inherently unstable, and your app needs to handle that elegantly.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 12),
                likes: 34,
                comments: 9,
              },
            ],
          },
          {
            id: "peer-david",
            peerId: "12D3KooWMnOpQrStUvWxYzAbCdEfGhIjKl",
            name: "David Miller",
            bio: "Privacy advocate. Building tools for a more private internet.",
            online: true,
            avatarGradient: avatarGradients[3],
            wall: [
              {
                id: "david-1",
                content:
                  "The more I use peer-to-peer apps, the more I realize how much we've given up to centralized platforms. Privacy isn't just a featureâ€”it's a right.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60),
                likes: 123,
                comments: 45,
              },
              {
                id: "david-2",
                content:
                  "Just finished setting up my own email server. Yes, it's a pain. Yes, deliverability is a nightmare. But knowing my emails aren't being scanned? Priceless.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 18),
                likes: 89,
                comments: 32,
              },
              {
                id: "david-3",
                content:
                  "Reminder: Your data is valuable. If a service is free, you're the product. That's why I'm so excited about Harbor - no servers, no data harvesting, just direct communication.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 36),
                likes: 201,
                comments: 67,
              },
            ],
          },
          {
            id: "peer-eva",
            peerId: "12D3KooWEfGhIjKlMnOpQrStUvWxYzAbCd",
            name: "Eva Martinez",
            bio: "Cryptography researcher. Turning math into privacy.",
            online: true,
            avatarGradient: avatarGradients[4],
            wall: [
              {
                id: "eva-1",
                content:
                  "New paper just dropped: 'Post-Quantum Key Exchange for Real-Time Communication'. We show that lattice-based crypto can be practical for P2P messaging. Link in bio!",
                timestamp: new Date(Date.now() - 1000 * 60 * 90),
                likes: 156,
                comments: 38,
              },
              {
                id: "eva-2",
                content:
                  "People ask why I work on cryptography. Simple: Math is the only thing that can truly protect your secrets. Governments change, companies fail, but prime numbers are forever.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 6),
                likes: 234,
                comments: 52,
              },
            ],
          },
          {
            id: "peer-frank",
            peerId: "12D3KooWKlMnOpQrStUvWxYzAbCdEfGhIj",
            name: "Frank Johnson",
            bio: "DevOps engineer by day, open source contributor by night.",
            online: false,
            avatarGradient: avatarGradients[5],
            wall: [
              {
                id: "frank-1",
                content:
                  "Finally automated our entire deployment pipeline. From commit to production in under 5 minutes with full rollback capability. CI/CD done right feels magical.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 3),
                likes: 98,
                comments: 24,
              },
              {
                id: "frank-2",
                content:
                  "Unpopular opinion: Kubernetes is overkill for 90% of projects. Sometimes a simple VPS with Docker Compose is all you need. Fight me.",
                timestamp: new Date(Date.now() - 1000 * 60 * 60 * 28),
                likes: 312,
                comments: 89,
              },
            ],
          },
        ];
        
        // Create initial conversations from mock peers
        const initialConversations: MockConversation[] = mockPeers.map((peer, index) => ({
          id: `conv-${peer.id}`,
          peerId: peer.peerId,
          name: peer.name,
          online: peer.online,
          avatarGradient: peer.avatarGradient,
          lastMessage: index === 0
            ? "Hey! Are you coming to the meetup?"
            : index === 1
              ? "Thanks for the help yesterday!"
              : index === 2
                ? "I'll send over the design files soon"
                : index === 3
                  ? "Privacy is non-negotiable!"
                  : index === 4
                    ? "Check out my new paper!"
                    : "Let's sync up on the deployment",
          timestamp: new Date(Date.now() - 1000 * 60 * (5 + index * 30)),
          unread: index === 0 ? 2 : index === 3 ? 1 : 0,
          messages: [
            {
              id: `${peer.id}-msg-1`,
              content: `Hey! Nice to connect with you on Harbor!`,
              timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2),
              isMine: false,
            },
            {
              id: `${peer.id}-msg-2`,
              content: "Thanks! Great to be here. How are you finding the app?",
              timestamp: new Date(Date.now() - 1000 * 60 * 60 * 1.5),
              isMine: true,
            },
            {
              id: `${peer.id}-msg-3`,
              content: "It's amazing! The P2P connectivity is really smooth.",
              timestamp: new Date(Date.now() - 1000 * 60 * 60),
              isMine: false,
            },
          ],
        }));
        
        // User's own posts interface
        export interface UserPost {
          id: string;
          content: string;
          timestamp: Date;
          likes: number;
          comments: number;
          liked: boolean; // Has the user liked their own post
          media?: { type: "image" | "video"; url: string; name?: string }[];
        }
        
        // Saved posts interface
        export interface SavedPost {
          postId: string;
          peerId: string;
          savedAt: Date;
        }
        
        // Zustand store interface
        interface MockPeersState {
          peers: MockPeer[];
          conversations: MockConversation[];
          userPosts: UserPost[];
          savedPosts: SavedPost[];
          likedPosts: Set<string>; // Track which feed posts user has liked (format: "peerId:postId")
        
          // Actions
          sendMessage: (conversationId: string, content: string) => void;
          likePost: (peerId: string, postId: string) => void;
          getAllFeedPosts: () => Array<MockPost & { author: Pick<MockPeer, "id" | "name" | "avatarGradient" | "peerId">; likedByUser: boolean }>;
        
          // User posts actions
          addUserPost: (content: string, media?: { type: "image" | "video"; url: string; name?: string }[]) => void;
          likeUserPost: (postId: string) => void;
          deleteUserPost: (postId: string) => void;
        
          // Saved posts actions
          toggleSavePost: (peerId: string, postId: string) => void;
          isPostSaved: (peerId: string, postId: string) => boolean;
        }
        
        // Initial user posts (demo data)
        const initialUserPosts: UserPost[] = [
          {
            id: "1",
            content: "Just launched Harbor - a decentralized P2P chat application! It's been an incredible journey building this. Check out the features: end-to-end encryption, local-first data, and peer-to-peer communication. No central servers, no data harvesting. Your identity stays with you.",
            timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2),
            likes: 12,
            comments: 3,
            liked: false,
          },
          {
            id: "2",
            content: "The beauty of decentralized systems is that you own your data. No company can access your messages, no algorithm decides what you see. Just direct, secure communication with the people you choose.",
            timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24),
            likes: 8,
            comments: 2,
            liked: false,
          },
          {
            id: "3",
            content: "Working on voice calling next! WebRTC signaling through libp2p is going to be interesting. Stay tuned for updates.",
            timestamp: new Date(Date.now() - 1000 * 60 * 60 * 48),
            likes: 15,
            comments: 5,
            liked: false,
          },
        ];
        
        export const useMockPeersStore = create<MockPeersState>((set, get) => ({
          peers: mockPeers,
          conversations: initialConversations,
          userPosts: initialUserPosts,
          savedPosts: [],
          likedPosts: new Set<string>(),
        
          sendMessage: (conversationId: string, content: string) => {
            const timestamp = new Date();
            const myMessage: MockMessage = {
              id: `msg-${Date.now()}`,
              content,
              timestamp,
              isMine: true,
            };
        
            set((state) => ({
              conversations: state.conversations.map((conv) =>
                conv.id === conversationId
                  ? {
                      ...conv,
                      messages: [...conv.messages, myMessage],
                      lastMessage: content,
                      timestamp,
                      unread: 0,
                    }
                  : conv
              ),
            }));
        
            // Simulate auto-reply after a delay (1-3 seconds)
            const conversation = get().conversations.find((c) => c.id === conversationId);
            if (conversation?.online) {
              const delay = 1000 + Math.random() * 2000;
              setTimeout(() => {
                const replyContent = generateAutoReply(content);
                const replyTimestamp = new Date();
                const replyMessage: MockMessage = {
                  id: `msg-${Date.now()}-reply`,
                  content: replyContent,
                  timestamp: replyTimestamp,
                  isMine: false,
                };
        
                set((state) => ({
                  conversations: state.conversations.map((conv) =>
                    conv.id === conversationId
                      ? {
                          ...conv,
                          messages: [...conv.messages, replyMessage],
                          lastMessage: replyContent,
                          timestamp: replyTimestamp,
                        }
                      : conv
                  ),
                }));
              }, delay);
            }
          },
        
          likePost: (peerId: string, postId: string) => {
            const likeKey = `${peerId}:${postId}`;
            const { likedPosts } = get();
        
            // If already liked, unlike it
            if (likedPosts.has(likeKey)) {
              const newLikedPosts = new Set(likedPosts);
              newLikedPosts.delete(likeKey);
              set((state) => ({
                likedPosts: newLikedPosts,
                peers: state.peers.map((peer) =>
                  peer.peerId === peerId
                    ? {
                        ...peer,
                        wall: peer.wall.map((post) =>
                          post.id === postId ? { ...post, likes: Math.max(0, post.likes - 1) } : post
                        ),
                      }
                    : peer
                ),
              }));
            } else {
              // Like the post
              const newLikedPosts = new Set(likedPosts);
              newLikedPosts.add(likeKey);
              set((state) => ({
                likedPosts: newLikedPosts,
                peers: state.peers.map((peer) =>
                  peer.peerId === peerId
                    ? {
                        ...peer,
                        wall: peer.wall.map((post) =>
                          post.id === postId ? { ...post, likes: post.likes + 1 } : post
                        ),
                      }
                    : peer
                ),
              }));
            }
          },
        
          getAllFeedPosts: () => {
            const { peers, likedPosts } = get();
        
            // Collect all posts from all peers with author info
            const allPosts = peers.flatMap((peer) =>
              peer.wall.map((post) => ({
                ...post,
                author: {
                  id: peer.id,
                  name: peer.name,
                  avatarGradient: peer.avatarGradient,
                  peerId: peer.peerId,
                },
                likedByUser: likedPosts.has(`${peer.peerId}:${post.id}`),
              }))
            );
        
            // Sort by timestamp (most recent first)
            return allPosts.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
          },
        
          // User posts actions
          addUserPost: (content: string, media?: { type: "image" | "video"; url: string; name?: string }[]) => {
            const newPost: UserPost = {
              id: Date.now().toString(),
              content,
              timestamp: new Date(),
              likes: 0,
              comments: 0,
              liked: false,
              media,
            };
            set((state) => ({
              userPosts: [newPost, ...state.userPosts],
            }));
          },
        
          likeUserPost: (postId: string) => {
            set((state) => ({
              userPosts: state.userPosts.map((post) =>
                post.id === postId
                  ? {
                      ...post,
                      liked: !post.liked,
                      likes: post.liked ? post.likes - 1 : post.likes + 1,
                    }
                  : post
              ),
            }));
          },
        
          deleteUserPost: (postId: string) => {
            set((state) => ({
              userPosts: state.userPosts.filter((post) => post.id !== postId),
            }));
          },
        
          // Saved posts actions
          toggleSavePost: (peerId: string, postId: string) => {
            set((state) => {
              const existingIndex = state.savedPosts.findIndex(
                (s) => s.peerId === peerId && s.postId === postId
              );
              if (existingIndex >= 0) {
                return {
                  savedPosts: state.savedPosts.filter((_, i) => i !== existingIndex),
                };
              }
              return {
                savedPosts: [
                  ...state.savedPosts,
                  { peerId, postId, savedAt: new Date() },
                ],
              };
            });
          },
        
          isPostSaved: (peerId: string, postId: string) => {
            return get().savedPosts.some((s) => s.peerId === peerId && s.postId === postId);
          },
        }));
        ```

      - ğŸ“„ **network.ts**

        ğŸ“„ *File Path*: `.\src\stores\network.ts`
        *Size*: 2726 bytes | *Modified*: 2026-01-17 09:13:43

        ```
        import { create } from "zustand";
        import type { PeerInfo, NetworkStats, ConnectionStatus } from "../types";
        import * as networkService from "../services/network";
        
        interface NetworkState {
          // State
          isRunning: boolean;
          status: ConnectionStatus;
          connectedPeers: PeerInfo[];
          stats: NetworkStats;
          error: string | null;
          isLoading: boolean;
        
          // Actions
          startNetwork: () => Promise<void>;
          stopNetwork: () => Promise<void>;
          refreshPeers: () => Promise<void>;
          refreshStats: () => Promise<void>;
          checkStatus: () => Promise<void>;
        }
        
        const initialStats: NetworkStats = {
          connectedPeers: 0,
          totalBytesIn: 0,
          totalBytesOut: 0,
          uptimeSeconds: 0,
        };
        
        export const useNetworkStore = create<NetworkState>((set, get) => ({
          // Initial state
          isRunning: false,
          status: "disconnected",
          connectedPeers: [],
          stats: initialStats,
          error: null,
          isLoading: false,
        
          // Start the network
          startNetwork: async () => {
            set({ isLoading: true, error: null, status: "connecting" });
            try {
              await networkService.startNetwork();
              set({ isRunning: true, status: "connected", isLoading: false });
              // Refresh peers and stats after starting
              await get().refreshPeers();
              await get().refreshStats();
            } catch (error) {
              set({
                error: String(error),
                isLoading: false,
                status: "disconnected",
              });
            }
          },
        
          // Stop the network
          stopNetwork: async () => {
            set({ isLoading: true, error: null });
            try {
              await networkService.stopNetwork();
              set({
                isRunning: false,
                status: "disconnected",
                connectedPeers: [],
                stats: initialStats,
                isLoading: false,
              });
            } catch (error) {
              set({ error: String(error), isLoading: false });
            }
          },
        
          // Check if network is running
          checkStatus: async () => {
            try {
              const isRunning = await networkService.isNetworkRunning();
              set({
                isRunning,
                status: isRunning ? "connected" : "disconnected",
              });
            } catch (error) {
              set({ error: String(error) });
            }
          },
        
          // Refresh connected peers list
          refreshPeers: async () => {
            try {
              const peers = await networkService.getConnectedPeers();
              set({ connectedPeers: peers });
            } catch (error) {
              // Don't show error for refresh failures - just log it
              console.error("Failed to refresh peers:", error);
            }
          },
        
          // Refresh network statistics
          refreshStats: async () => {
            try {
              const stats = await networkService.getNetworkStats();
              set({ stats });
            } catch (error) {
              // Don't show error for refresh failures - just log it
              console.error("Failed to refresh stats:", error);
            }
          },
        }));
        ```

      - ğŸ“„ **settings.ts**

        ğŸ“„ *File Path*: `.\src\stores\settings.ts`
        *Size*: 1505 bytes | *Modified*: 2026-01-17 06:27:33

        ```
        import { create } from "zustand";
        import { persist } from "zustand/middleware";
        
        interface SettingsState {
          // Network settings
          autoStartNetwork: boolean;
          localDiscovery: boolean;
        
          // Privacy settings
          showReadReceipts: boolean;
          showOnlineStatus: boolean;
          defaultVisibility: "contacts" | "public";
        
          // Profile settings
          avatarUrl: string | null;
        
          // Actions
          setAutoStartNetwork: (value: boolean) => void;
          setLocalDiscovery: (value: boolean) => void;
          setShowReadReceipts: (value: boolean) => void;
          setShowOnlineStatus: (value: boolean) => void;
          setDefaultVisibility: (value: "contacts" | "public") => void;
          setAvatarUrl: (url: string | null) => void;
        }
        
        export const useSettingsStore = create<SettingsState>()(
          persist(
            (set) => ({
              // Initial values
              autoStartNetwork: true,
              localDiscovery: true,
              showReadReceipts: true,
              showOnlineStatus: true,
              defaultVisibility: "contacts",
              avatarUrl: null,
        
              // Actions
              setAutoStartNetwork: (value) => set({ autoStartNetwork: value }),
              setLocalDiscovery: (value) => set({ localDiscovery: value }),
              setShowReadReceipts: (value) => set({ showReadReceipts: value }),
              setShowOnlineStatus: (value) => set({ showOnlineStatus: value }),
              setDefaultVisibility: (value) => set({ defaultVisibility: value }),
              setAvatarUrl: (url) => set({ avatarUrl: url }),
            }),
            {
              name: "harbor-settings",
            }
          )
        );
        ```

    - ğŸ“ **styles/**
      - ğŸ“„ **design-system.css**

        ğŸ“„ *File Path*: `.\src\styles\design-system.css`
        *Size*: 7915 bytes | *Modified*: 2026-01-17 04:33:06

        ```
        /* Harbor Design System
         * A modern, elegant design language for decentralized communication
         */
        
        /* ============================================
           CSS Custom Properties (Design Tokens)
           ============================================ */
        
        :root {
          /* Brand Colors */
          --harbor-primary: 220 91% 54%;        /* Vibrant blue */
          --harbor-primary-light: 220 91% 64%;
          --harbor-primary-dark: 220 91% 44%;
        
          /* Accent Colors */
          --harbor-accent: 262 83% 58%;         /* Purple accent */
          --harbor-success: 152 69% 40%;        /* Green */
          --harbor-warning: 38 92% 50%;         /* Amber */
          --harbor-error: 0 84% 60%;            /* Red */
        
          /* Neutral Colors - Light Mode */
          --harbor-bg-primary: 0 0% 100%;
          --harbor-bg-secondary: 220 14% 96%;
          --harbor-bg-tertiary: 220 13% 91%;
          --harbor-bg-elevated: 0 0% 100%;
        
          --harbor-surface-1: 220 14% 96%;
          --harbor-surface-2: 220 13% 91%;
          --harbor-surface-3: 220 12% 86%;
        
          --harbor-border: 220 13% 87%;
          --harbor-border-subtle: 220 13% 91%;
        
          --harbor-text-primary: 220 13% 13%;
          --harbor-text-secondary: 220 9% 46%;
          --harbor-text-tertiary: 220 9% 64%;
          --harbor-text-inverse: 0 0% 100%;
        
          /* Spacing Scale */
          --space-1: 0.25rem;   /* 4px */
          --space-2: 0.5rem;    /* 8px */
          --space-3: 0.75rem;   /* 12px */
          --space-4: 1rem;      /* 16px */
          --space-5: 1.25rem;   /* 20px */
          --space-6: 1.5rem;    /* 24px */
          --space-8: 2rem;      /* 32px */
          --space-10: 2.5rem;   /* 40px */
          --space-12: 3rem;     /* 48px */
          --space-16: 4rem;     /* 64px */
          --space-20: 5rem;     /* 80px */
        
          /* Typography Scale */
          --font-size-xs: 0.75rem;     /* 12px */
          --font-size-sm: 0.875rem;    /* 14px */
          --font-size-base: 1rem;      /* 16px */
          --font-size-lg: 1.125rem;    /* 18px */
          --font-size-xl: 1.25rem;     /* 20px */
          --font-size-2xl: 1.5rem;     /* 24px */
          --font-size-3xl: 1.875rem;   /* 30px */
          --font-size-4xl: 2.25rem;    /* 36px */
        
          --line-height-tight: 1.25;
          --line-height-snug: 1.375;
          --line-height-normal: 1.5;
          --line-height-relaxed: 1.625;
        
          --font-weight-normal: 400;
          --font-weight-medium: 500;
          --font-weight-semibold: 600;
          --font-weight-bold: 700;
        
          /* Border Radius */
          --radius-sm: 0.375rem;    /* 6px */
          --radius-md: 0.5rem;      /* 8px */
          --radius-lg: 0.75rem;     /* 12px */
          --radius-xl: 1rem;        /* 16px */
          --radius-2xl: 1.5rem;     /* 24px */
          --radius-full: 9999px;
        
          /* Shadows */
          --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
          --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
          --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
          --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
          --shadow-glow: 0 0 20px rgb(0 0 0 / 0.1);
        
          /* Transitions */
          --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
          --transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
          --transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);
          --transition-spring: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);
        
          /* Z-index Scale */
          --z-dropdown: 50;
          --z-sticky: 100;
          --z-modal-backdrop: 200;
          --z-modal: 300;
          --z-popover: 400;
          --z-tooltip: 500;
          --z-toast: 600;
        }
        
        /* Dark Mode */
        @media (prefers-color-scheme: dark) {
          :root {
            --harbor-bg-primary: 222 47% 8%;
            --harbor-bg-secondary: 222 47% 11%;
            --harbor-bg-tertiary: 222 41% 15%;
            --harbor-bg-elevated: 222 41% 13%;
        
            --harbor-surface-1: 222 41% 13%;
            --harbor-surface-2: 222 41% 17%;
            --harbor-surface-3: 222 41% 21%;
        
            --harbor-border: 222 30% 22%;
            --harbor-border-subtle: 222 30% 18%;
        
            --harbor-text-primary: 220 14% 96%;
            --harbor-text-secondary: 220 9% 70%;
            --harbor-text-tertiary: 220 9% 50%;
        
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.3);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.5), 0 4px 6px -4px rgb(0 0 0 / 0.4);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.5), 0 8px 10px -6px rgb(0 0 0 / 0.4);
          }
        }
        
        /* ============================================
           Base Styles
           ============================================ */
        
        * {
          box-sizing: border-box;
        }
        
        html {
          font-family: 'Inter', system-ui, -apple-system, sans-serif;
          font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        }
        
        body {
          margin: 0;
          background-color: hsl(var(--harbor-bg-primary));
          color: hsl(var(--harbor-text-primary));
          line-height: var(--line-height-normal);
        }
        
        /* ============================================
           Animations
           ============================================ */
        
        @keyframes fade-in {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        
        @keyframes fade-in-up {
          from {
            opacity: 0;
            transform: translateY(10px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        
        @keyframes fade-in-scale {
          from {
            opacity: 0;
            transform: scale(0.95);
          }
          to {
            opacity: 1;
            transform: scale(1);
          }
        }
        
        @keyframes slide-in-right {
          from {
            opacity: 0;
            transform: translateX(-20px);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }
        
        @keyframes pulse-soft {
          0%, 100% {
            opacity: 1;
          }
          50% {
            opacity: 0.7;
          }
        }
        
        @keyframes shimmer {
          0% {
            background-position: -200% 0;
          }
          100% {
            background-position: 200% 0;
          }
        }
        
        @keyframes spin {
          from {
            transform: rotate(0deg);
          }
          to {
            transform: rotate(360deg);
          }
        }
        
        /* Animation utility classes */
        .animate-fade-in {
          animation: fade-in var(--transition-base) ease-out;
        }
        
        .animate-fade-in-up {
          animation: fade-in-up var(--transition-slow) ease-out;
        }
        
        .animate-fade-in-scale {
          animation: fade-in-scale var(--transition-base) ease-out;
        }
        
        .animate-slide-in-right {
          animation: slide-in-right var(--transition-slow) ease-out;
        }
        
        .animate-pulse-soft {
          animation: pulse-soft 2s ease-in-out infinite;
        }
        
        .animate-shimmer {
          background: linear-gradient(
            90deg,
            hsl(var(--harbor-surface-1)) 25%,
            hsl(var(--harbor-surface-2)) 50%,
            hsl(var(--harbor-surface-1)) 75%
          );
          background-size: 200% 100%;
          animation: shimmer 1.5s infinite;
        }
        
        .animate-spin {
          animation: spin 1s linear infinite;
        }
        
        /* ============================================
           Custom Scrollbar
           ============================================ */
        
        ::-webkit-scrollbar {
          width: 8px;
          height: 8px;
        }
        
        ::-webkit-scrollbar-track {
          background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
          background: hsl(var(--harbor-border));
          border-radius: var(--radius-full);
        }
        
        ::-webkit-scrollbar-thumb:hover {
          background: hsl(var(--harbor-text-tertiary));
        }
        
        /* Firefox */
        * {
          scrollbar-width: thin;
          scrollbar-color: hsl(var(--harbor-border)) transparent;
        }
        
        /* ============================================
           Focus Styles
           ============================================ */
        
        :focus-visible {
          outline: 2px solid hsl(var(--harbor-primary));
          outline-offset: 2px;
        }
        
        /* ============================================
           Selection Styles
           ============================================ */
        
        ::selection {
          background-color: hsl(var(--harbor-primary) / 0.2);
          color: inherit;
        }
        
        /* ============================================
           Glass Effect
           ============================================ */
        
        .glass {
          background: hsl(var(--harbor-bg-elevated) / 0.8);
          backdrop-filter: blur(12px) saturate(180%);
          -webkit-backdrop-filter: blur(12px) saturate(180%);
        }
        
        .glass-strong {
          background: hsl(var(--harbor-bg-elevated) / 0.9);
          backdrop-filter: blur(20px) saturate(200%);
          -webkit-backdrop-filter: blur(20px) saturate(200%);
        }
        ```

    - ğŸ“ **types/**
      - ğŸ“„ **calling.ts**

        ğŸ“„ *File Path*: `.\src\types\calling.ts`
        *Size*: 990 bytes | *Modified*: 2026-01-17 04:25:22

        ```
        /** Call state */
        export type CallState = "ringing" | "incoming" | "connected" | "ended";
        
        /** Hangup reason */
        export type HangupReason = "normal" | "busy" | "declined" | "error";
        
        /** An outgoing offer result */
        export interface OfferResult {
          callId: string;
          callerPeerId: string;
          calleePeerId: string;
          sdp: string;
          timestamp: number;
          signature: number[];
        }
        
        /** An answer result */
        export interface AnswerResult {
          callId: string;
          callerPeerId: string;
          calleePeerId: string;
          sdp: string;
          timestamp: number;
          signature: number[];
        }
        
        /** An ICE candidate result */
        export interface IceResult {
          callId: string;
          senderPeerId: string;
          candidate: string;
          sdpMid: string | null;
          sdpMlineIndex: number | null;
          timestamp: number;
          signature: number[];
        }
        
        /** A hangup result */
        export interface HangupResult {
          callId: string;
          senderPeerId: string;
          reason: string;
          timestamp: number;
          signature: number[];
        }
        ```

      - ğŸ“„ **contacts.ts**

        ğŸ“„ *File Path*: `.\src\types\contacts.ts`
        *Size*: 605 bytes | *Modified*: 2026-01-16 21:42:27

        ```
        /** Contact information */
        export interface Contact {
          id: number;
          peerId: string;
          publicKey: string; // base64 encoded
          x25519Public: string; // base64 encoded
          displayName: string;
          avatarHash: string | null;
          bio: string | null;
          isBlocked: boolean;
          trustLevel: number;
          lastSeenAt: number | null;
          addedAt: number;
          updatedAt: number;
        }
        
        /** Data needed to add a new contact */
        export interface ContactData {
          peerId: string;
          publicKey: string; // base64 encoded
          x25519Public: string; // base64 encoded
          displayName: string;
          avatarHash?: string | null;
          bio?: string | null;
        }
        ```

      - ğŸ“„ **feed.ts**

        ğŸ“„ *File Path*: `.\src\types\feed.ts`
        *Size*: 328 bytes | *Modified*: 2026-01-17 04:19:19

        ```
        /** A feed item (post with author context) */
        export interface FeedItem {
          postId: string;
          authorPeerId: string;
          authorDisplayName: string | null;
          contentType: string;
          contentText: string | null;
          visibility: string;
          lamportClock: number;
          createdAt: number;
          updatedAt: number;
          isLocal: boolean;
        }
        ```

      - ğŸ“„ **identity.ts**

        ğŸ“„ *File Path*: `.\src\types\identity.ts`
        *Size*: 661 bytes | *Modified*: 2026-01-16 17:14:15

        ```
        /** Identity info returned from backend */
        export interface IdentityInfo {
          peerId: string;
          publicKey: string; // base64 encoded
          x25519Public: string; // base64 encoded
          displayName: string;
          avatarHash: string | null;
          bio: string | null;
          createdAt: number;
          updatedAt: number;
        }
        
        /** Request to create a new identity */
        export interface CreateIdentityRequest {
          displayName: string;
          passphrase: string;
          bio?: string;
        }
        
        /** Application state for identity */
        export type IdentityState =
          | { status: "loading" }
          | { status: "no_identity" }
          | { status: "locked"; identity: IdentityInfo }
          | { status: "unlocked"; identity: IdentityInfo };
        ```

      - ğŸ“„ **index.ts**

        ğŸ“„ *File Path*: `.\src\types\index.ts`
        *Size*: 219 bytes | *Modified*: 2026-01-17 04:25:40

        ```
        export * from "./identity";
        export * from "./network";
        export * from "./contacts";
        export * from "./permissions";
        export * from "./messaging";
        export * from "./posts";
        export * from "./feed";
        export * from "./calling";
        ```

      - ğŸ“„ **messaging.ts**

        ğŸ“„ *File Path*: `.\src\types\messaging.ts`
        *Size*: 771 bytes | *Modified*: 2026-01-16 22:58:22

        ```
        /** A message in a conversation */
        export interface Message {
          messageId: string;
          conversationId: string;
          senderPeerId: string;
          recipientPeerId: string;
          content: string;
          contentType: string;
          replyToMessageId: string | null;
          sentAt: number;
          deliveredAt: number | null;
          readAt: number | null;
          status: MessageStatus;
          isOutgoing: boolean;
        }
        
        /** Message delivery status */
        export type MessageStatus = "pending" | "sent" | "delivered" | "read" | "failed";
        
        /** A conversation summary */
        export interface Conversation {
          conversationId: string;
          peerId: string;
          lastMessageAt: number;
          unreadCount: number;
        }
        
        /** Result of sending a message */
        export interface SendMessageResult {
          messageId: string;
          conversationId: string;
          sentAt: number;
        }
        ```

      - ğŸ“„ **network.ts**

        ğŸ“„ *File Path*: `.\src\types\network.ts`
        *Size*: 1071 bytes | *Modified*: 2026-01-17 13:39:36

        ```
        /** Network connection status */
        export type ConnectionStatus = "disconnected" | "connecting" | "connected";
        
        /** Information about a peer */
        export interface PeerInfo {
          peerId: string;
          addresses: string[];
          protocolVersion: string | null;
          agentVersion: string | null;
          isConnected: boolean;
          lastSeen: number | null;
        }
        
        /** Network statistics */
        export interface NetworkStats {
          connectedPeers: number;
          totalBytesIn: number;
          totalBytesOut: number;
          uptimeSeconds: number;
        }
        
        /** Network events emitted by the backend */
        export type NetworkEvent =
          | { type: "peer_discovered"; peerId: string }
          | { type: "peer_expired"; peerId: string }
          | { type: "peer_connected"; peerId: string }
          | { type: "peer_disconnected"; peerId: string }
          | { type: "external_address_discovered"; address: string }
          | { type: "listening_on"; address: string }
          | { type: "message_received"; peerId: string; protocol: string; payload: number[] }
          | { type: "status_changed"; status: ConnectionStatus }
          | { type: "contact_added"; peerId: string; displayName: string };
        ```

      - ğŸ“„ **permissions.ts**

        ğŸ“„ *File Path*: `.\src\types\permissions.ts`
        *Size*: 496 bytes | *Modified*: 2026-01-16 21:42:35

        ```
        /** Permission capability types */
        export type Capability = "chat" | "wall_read" | "call";
        
        /** Permission info */
        export interface PermissionInfo {
          grantId: string;
          issuerPeerId: string;
          subjectPeerId: string;
          capability: string;
          issuedAt: number;
          expiresAt: number | null;
          isValid: boolean;
        }
        
        /** Result of granting a permission */
        export interface GrantResult {
          grantId: string;
          capability: string;
          subjectPeerId: string;
          issuedAt: number;
          expiresAt: number | null;
        }
        ```

      - ğŸ“„ **posts.ts**

        ğŸ“„ *File Path*: `.\src\types\posts.ts`
        *Size*: 783 bytes | *Modified*: 2026-01-16 23:48:27

        ```
        /** A wall/blog post */
        export interface Post {
          postId: string;
          authorPeerId: string;
          contentType: string;
          contentText: string | null;
          visibility: PostVisibility;
          lamportClock: number;
          createdAt: number;
          updatedAt: number;
          deletedAt: number | null;
          isLocal: boolean;
        }
        
        /** Post visibility setting */
        export type PostVisibility = "contacts" | "public";
        
        /** Post media attachment */
        export interface PostMedia {
          id: number;
          postId: string;
          mediaHash: string;
          mediaType: string;
          mimeType: string;
          fileName: string;
          fileSize: number;
          width: number | null;
          height: number | null;
          durationSeconds: number | null;
          sortOrder: number;
        }
        
        /** Result of creating a post */
        export interface CreatePostResult {
          postId: string;
          createdAt: number;
        }
        ```

    - ğŸ“„ **vite-env.d.ts**

      ğŸ“„ *File Path*: `.\src\vite-env.d.ts`
      *Size*: 39 bytes | *Modified*: 2026-01-16 17:05:55

      ```
      /// <reference types="vite/client" />
      ```

  - ğŸ“ **src-tauri/**
    - ğŸ“„ **Cargo.toml**

      ğŸ“„ *File Path*: `.\src-tauri\Cargo.toml`
      *Size*: 1514 bytes | *Modified*: 2026-01-16 22:04:46

      ```
      [package]
      name = "harbor"
      version = "0.1.0"
      description = "A decentralized P2P chat application with local-first data and permission-based sharing"
      authors = ["Harbor Contributors"]
      edition = "2021"
      
      [lib]
      name = "harbor_lib"
      crate-type = ["staticlib", "cdylib", "rlib"]
      
      [build-dependencies]
      tauri-build = { version = "2", features = [] }
      
      [dependencies]
      # Tauri
      tauri = { version = "2", features = [] }
      tauri-plugin-opener = "2"
      
      # Serialization
      serde = { version = "1", features = ["derive"] }
      serde_json = "1"
      ciborium = "0.2"  # CBOR for canonical serialization
      
      # Async runtime
      tokio = { version = "1", features = ["full"] }
      futures = "0.3"
      
      # Database
      rusqlite = { version = "0.31", features = ["bundled"] }
      
      # Cryptography
      ed25519-dalek = { version = "2.1", features = ["rand_core", "serde"] }
      x25519-dalek = { version = "2.0", features = ["static_secrets"] }
      aes-gcm = "0.10"
      argon2 = "0.5"
      sha2 = "0.10"
      hkdf = "0.12"
      rand = "0.8"
      
      # Utilities
      uuid = { version = "1", features = ["v4", "serde"] }
      chrono = { version = "0.4", features = ["serde"] }
      thiserror = "1.0"
      anyhow = "1.0"
      tracing = "0.1"
      tracing-subscriber = { version = "0.3", features = ["env-filter"] }
      base64 = "0.22"
      hex = "0.4"
      
      # P2P Networking
      libp2p = { version = "0.54", features = [
          "tokio",
          "tcp",
          "quic",
          "noise",
          "yamux",
          "kad",
          "mdns",
          "identify",
          "ping",
          "relay",
          "dcutr",
          "autonat",
          "request-response",
          "cbor",
          "macros",
          "serde",
      ] }
      multiaddr = "0.18"
      void = "1"
      ```

    - ğŸ“ **gen/**
      - ğŸ“ **schemas/**
        - ğŸ“„ **acl-manifests.json**

          ğŸ“„ *File Path*: `.\src-tauri\gen\schemas\acl-manifests.json`
          *Size*: 67644 bytes | *Modified*: 2026-01-16 17:26:01

          ```
          {"core":{"default_permission":{"identifier":"default","description":"Default core plugins set.","permissions":["core:path:default","core:event:default","core:window:default","core:webview:default","core:app:default","core:image:default","core:resources:default","core:menu:default","core:tray:default"]},"permissions":{},"permission_sets":{},"global_scope_schema":null},"core:app":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin.","permissions":["allow-version","allow-name","allow-tauri-version","allow-identifier","allow-bundle-type","allow-register-listener","allow-remove-listener"]},"permissions":{"allow-app-hide":{"identifier":"allow-app-hide","description":"Enables the app_hide command without any pre-configured scope.","commands":{"allow":["app_hide"],"deny":[]}},"allow-app-show":{"identifier":"allow-app-show","description":"Enables the app_show command without any pre-configured scope.","commands":{"allow":["app_show"],"deny":[]}},"allow-bundle-type":{"identifier":"allow-bundle-type","description":"Enables the bundle_type command without any pre-configured scope.","commands":{"allow":["bundle_type"],"deny":[]}},"allow-default-window-icon":{"identifier":"allow-default-window-icon","description":"Enables the default_window_icon command without any pre-configured scope.","commands":{"allow":["default_window_icon"],"deny":[]}},"allow-fetch-data-store-identifiers":{"identifier":"allow-fetch-data-store-identifiers","description":"Enables the fetch_data_store_identifiers command without any pre-configured scope.","commands":{"allow":["fetch_data_store_identifiers"],"deny":[]}},"allow-identifier":{"identifier":"allow-identifier","description":"Enables the identifier command without any pre-configured scope.","commands":{"allow":["identifier"],"deny":[]}},"allow-name":{"identifier":"allow-name","description":"Enables the name command without any pre-configured scope.","commands":{"allow":["name"],"deny":[]}},"allow-register-listener":{"identifier":"allow-register-listener","description":"Enables the register_listener command without any pre-configured scope.","commands":{"allow":["register_listener"],"deny":[]}},"allow-remove-data-store":{"identifier":"allow-remove-data-store","description":"Enables the remove_data_store command without any pre-configured scope.","commands":{"allow":["remove_data_store"],"deny":[]}},"allow-remove-listener":{"identifier":"allow-remove-listener","description":"Enables the remove_listener command without any pre-configured scope.","commands":{"allow":["remove_listener"],"deny":[]}},"allow-set-app-theme":{"identifier":"allow-set-app-theme","description":"Enables the set_app_theme command without any pre-configured scope.","commands":{"allow":["set_app_theme"],"deny":[]}},"allow-set-dock-visibility":{"identifier":"allow-set-dock-visibility","description":"Enables the set_dock_visibility command without any pre-configured scope.","commands":{"allow":["set_dock_visibility"],"deny":[]}},"allow-tauri-version":{"identifier":"allow-tauri-version","description":"Enables the tauri_version command without any pre-configured scope.","commands":{"allow":["tauri_version"],"deny":[]}},"allow-version":{"identifier":"allow-version","description":"Enables the version command without any pre-configured scope.","commands":{"allow":["version"],"deny":[]}},"deny-app-hide":{"identifier":"deny-app-hide","description":"Denies the app_hide command without any pre-configured scope.","commands":{"allow":[],"deny":["app_hide"]}},"deny-app-show":{"identifier":"deny-app-show","description":"Denies the app_show command without any pre-configured scope.","commands":{"allow":[],"deny":["app_show"]}},"deny-bundle-type":{"identifier":"deny-bundle-type","description":"Denies the bundle_type command without any pre-configured scope.","commands":{"allow":[],"deny":["bundle_type"]}},"deny-default-window-icon":{"identifier":"deny-default-window-icon","description":"Denies the default_window_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["default_window_icon"]}},"deny-fetch-data-store-identifiers":{"identifier":"deny-fetch-data-store-identifiers","description":"Denies the fetch_data_store_identifiers command without any pre-configured scope.","commands":{"allow":[],"deny":["fetch_data_store_identifiers"]}},"deny-identifier":{"identifier":"deny-identifier","description":"Denies the identifier command without any pre-configured scope.","commands":{"allow":[],"deny":["identifier"]}},"deny-name":{"identifier":"deny-name","description":"Denies the name command without any pre-configured scope.","commands":{"allow":[],"deny":["name"]}},"deny-register-listener":{"identifier":"deny-register-listener","description":"Denies the register_listener command without any pre-configured scope.","commands":{"allow":[],"deny":["register_listener"]}},"deny-remove-data-store":{"identifier":"deny-remove-data-store","description":"Denies the remove_data_store command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_data_store"]}},"deny-remove-listener":{"identifier":"deny-remove-listener","description":"Denies the remove_listener command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_listener"]}},"deny-set-app-theme":{"identifier":"deny-set-app-theme","description":"Denies the set_app_theme command without any pre-configured scope.","commands":{"allow":[],"deny":["set_app_theme"]}},"deny-set-dock-visibility":{"identifier":"deny-set-dock-visibility","description":"Denies the set_dock_visibility command without any pre-configured scope.","commands":{"allow":[],"deny":["set_dock_visibility"]}},"deny-tauri-version":{"identifier":"deny-tauri-version","description":"Denies the tauri_version command without any pre-configured scope.","commands":{"allow":[],"deny":["tauri_version"]}},"deny-version":{"identifier":"deny-version","description":"Denies the version command without any pre-configured scope.","commands":{"allow":[],"deny":["version"]}}},"permission_sets":{},"global_scope_schema":null},"core:event":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-listen","allow-unlisten","allow-emit","allow-emit-to"]},"permissions":{"allow-emit":{"identifier":"allow-emit","description":"Enables the emit command without any pre-configured scope.","commands":{"allow":["emit"],"deny":[]}},"allow-emit-to":{"identifier":"allow-emit-to","description":"Enables the emit_to command without any pre-configured scope.","commands":{"allow":["emit_to"],"deny":[]}},"allow-listen":{"identifier":"allow-listen","description":"Enables the listen command without any pre-configured scope.","commands":{"allow":["listen"],"deny":[]}},"allow-unlisten":{"identifier":"allow-unlisten","description":"Enables the unlisten command without any pre-configured scope.","commands":{"allow":["unlisten"],"deny":[]}},"deny-emit":{"identifier":"deny-emit","description":"Denies the emit command without any pre-configured scope.","commands":{"allow":[],"deny":["emit"]}},"deny-emit-to":{"identifier":"deny-emit-to","description":"Denies the emit_to command without any pre-configured scope.","commands":{"allow":[],"deny":["emit_to"]}},"deny-listen":{"identifier":"deny-listen","description":"Denies the listen command without any pre-configured scope.","commands":{"allow":[],"deny":["listen"]}},"deny-unlisten":{"identifier":"deny-unlisten","description":"Denies the unlisten command without any pre-configured scope.","commands":{"allow":[],"deny":["unlisten"]}}},"permission_sets":{},"global_scope_schema":null},"core:image":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-new","allow-from-bytes","allow-from-path","allow-rgba","allow-size"]},"permissions":{"allow-from-bytes":{"identifier":"allow-from-bytes","description":"Enables the from_bytes command without any pre-configured scope.","commands":{"allow":["from_bytes"],"deny":[]}},"allow-from-path":{"identifier":"allow-from-path","description":"Enables the from_path command without any pre-configured scope.","commands":{"allow":["from_path"],"deny":[]}},"allow-new":{"identifier":"allow-new","description":"Enables the new command without any pre-configured scope.","commands":{"allow":["new"],"deny":[]}},"allow-rgba":{"identifier":"allow-rgba","description":"Enables the rgba command without any pre-configured scope.","commands":{"allow":["rgba"],"deny":[]}},"allow-size":{"identifier":"allow-size","description":"Enables the size command without any pre-configured scope.","commands":{"allow":["size"],"deny":[]}},"deny-from-bytes":{"identifier":"deny-from-bytes","description":"Denies the from_bytes command without any pre-configured scope.","commands":{"allow":[],"deny":["from_bytes"]}},"deny-from-path":{"identifier":"deny-from-path","description":"Denies the from_path command without any pre-configured scope.","commands":{"allow":[],"deny":["from_path"]}},"deny-new":{"identifier":"deny-new","description":"Denies the new command without any pre-configured scope.","commands":{"allow":[],"deny":["new"]}},"deny-rgba":{"identifier":"deny-rgba","description":"Denies the rgba command without any pre-configured scope.","commands":{"allow":[],"deny":["rgba"]}},"deny-size":{"identifier":"deny-size","description":"Denies the size command without any pre-configured scope.","commands":{"allow":[],"deny":["size"]}}},"permission_sets":{},"global_scope_schema":null},"core:menu":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-new","allow-append","allow-prepend","allow-insert","allow-remove","allow-remove-at","allow-items","allow-get","allow-popup","allow-create-default","allow-set-as-app-menu","allow-set-as-window-menu","allow-text","allow-set-text","allow-is-enabled","allow-set-enabled","allow-set-accelerator","allow-set-as-windows-menu-for-nsapp","allow-set-as-help-menu-for-nsapp","allow-is-checked","allow-set-checked","allow-set-icon"]},"permissions":{"allow-append":{"identifier":"allow-append","description":"Enables the append command without any pre-configured scope.","commands":{"allow":["append"],"deny":[]}},"allow-create-default":{"identifier":"allow-create-default","description":"Enables the create_default command without any pre-configured scope.","commands":{"allow":["create_default"],"deny":[]}},"allow-get":{"identifier":"allow-get","description":"Enables the get command without any pre-configured scope.","commands":{"allow":["get"],"deny":[]}},"allow-insert":{"identifier":"allow-insert","description":"Enables the insert command without any pre-configured scope.","commands":{"allow":["insert"],"deny":[]}},"allow-is-checked":{"identifier":"allow-is-checked","description":"Enables the is_checked command without any pre-configured scope.","commands":{"allow":["is_checked"],"deny":[]}},"allow-is-enabled":{"identifier":"allow-is-enabled","description":"Enables the is_enabled command without any pre-configured scope.","commands":{"allow":["is_enabled"],"deny":[]}},"allow-items":{"identifier":"allow-items","description":"Enables the items command without any pre-configured scope.","commands":{"allow":["items"],"deny":[]}},"allow-new":{"identifier":"allow-new","description":"Enables the new command without any pre-configured scope.","commands":{"allow":["new"],"deny":[]}},"allow-popup":{"identifier":"allow-popup","description":"Enables the popup command without any pre-configured scope.","commands":{"allow":["popup"],"deny":[]}},"allow-prepend":{"identifier":"allow-prepend","description":"Enables the prepend command without any pre-configured scope.","commands":{"allow":["prepend"],"deny":[]}},"allow-remove":{"identifier":"allow-remove","description":"Enables the remove command without any pre-configured scope.","commands":{"allow":["remove"],"deny":[]}},"allow-remove-at":{"identifier":"allow-remove-at","description":"Enables the remove_at command without any pre-configured scope.","commands":{"allow":["remove_at"],"deny":[]}},"allow-set-accelerator":{"identifier":"allow-set-accelerator","description":"Enables the set_accelerator command without any pre-configured scope.","commands":{"allow":["set_accelerator"],"deny":[]}},"allow-set-as-app-menu":{"identifier":"allow-set-as-app-menu","description":"Enables the set_as_app_menu command without any pre-configured scope.","commands":{"allow":["set_as_app_menu"],"deny":[]}},"allow-set-as-help-menu-for-nsapp":{"identifier":"allow-set-as-help-menu-for-nsapp","description":"Enables the set_as_help_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":["set_as_help_menu_for_nsapp"],"deny":[]}},"allow-set-as-window-menu":{"identifier":"allow-set-as-window-menu","description":"Enables the set_as_window_menu command without any pre-configured scope.","commands":{"allow":["set_as_window_menu"],"deny":[]}},"allow-set-as-windows-menu-for-nsapp":{"identifier":"allow-set-as-windows-menu-for-nsapp","description":"Enables the set_as_windows_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":["set_as_windows_menu_for_nsapp"],"deny":[]}},"allow-set-checked":{"identifier":"allow-set-checked","description":"Enables the set_checked command without any pre-configured scope.","commands":{"allow":["set_checked"],"deny":[]}},"allow-set-enabled":{"identifier":"allow-set-enabled","description":"Enables the set_enabled command without any pre-configured scope.","commands":{"allow":["set_enabled"],"deny":[]}},"allow-set-icon":{"identifier":"allow-set-icon","description":"Enables the set_icon command without any pre-configured scope.","commands":{"allow":["set_icon"],"deny":[]}},"allow-set-text":{"identifier":"allow-set-text","description":"Enables the set_text command without any pre-configured scope.","commands":{"allow":["set_text"],"deny":[]}},"allow-text":{"identifier":"allow-text","description":"Enables the text command without any pre-configured scope.","commands":{"allow":["text"],"deny":[]}},"deny-append":{"identifier":"deny-append","description":"Denies the append command without any pre-configured scope.","commands":{"allow":[],"deny":["append"]}},"deny-create-default":{"identifier":"deny-create-default","description":"Denies the create_default command without any pre-configured scope.","commands":{"allow":[],"deny":["create_default"]}},"deny-get":{"identifier":"deny-get","description":"Denies the get command without any pre-configured scope.","commands":{"allow":[],"deny":["get"]}},"deny-insert":{"identifier":"deny-insert","description":"Denies the insert command without any pre-configured scope.","commands":{"allow":[],"deny":["insert"]}},"deny-is-checked":{"identifier":"deny-is-checked","description":"Denies the is_checked command without any pre-configured scope.","commands":{"allow":[],"deny":["is_checked"]}},"deny-is-enabled":{"identifier":"deny-is-enabled","description":"Denies the is_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["is_enabled"]}},"deny-items":{"identifier":"deny-items","description":"Denies the items command without any pre-configured scope.","commands":{"allow":[],"deny":["items"]}},"deny-new":{"identifier":"deny-new","description":"Denies the new command without any pre-configured scope.","commands":{"allow":[],"deny":["new"]}},"deny-popup":{"identifier":"deny-popup","description":"Denies the popup command without any pre-configured scope.","commands":{"allow":[],"deny":["popup"]}},"deny-prepend":{"identifier":"deny-prepend","description":"Denies the prepend command without any pre-configured scope.","commands":{"allow":[],"deny":["prepend"]}},"deny-remove":{"identifier":"deny-remove","description":"Denies the remove command without any pre-configured scope.","commands":{"allow":[],"deny":["remove"]}},"deny-remove-at":{"identifier":"deny-remove-at","description":"Denies the remove_at command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_at"]}},"deny-set-accelerator":{"identifier":"deny-set-accelerator","description":"Denies the set_accelerator command without any pre-configured scope.","commands":{"allow":[],"deny":["set_accelerator"]}},"deny-set-as-app-menu":{"identifier":"deny-set-as-app-menu","description":"Denies the set_as_app_menu command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_app_menu"]}},"deny-set-as-help-menu-for-nsapp":{"identifier":"deny-set-as-help-menu-for-nsapp","description":"Denies the set_as_help_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_help_menu_for_nsapp"]}},"deny-set-as-window-menu":{"identifier":"deny-set-as-window-menu","description":"Denies the set_as_window_menu command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_window_menu"]}},"deny-set-as-windows-menu-for-nsapp":{"identifier":"deny-set-as-windows-menu-for-nsapp","description":"Denies the set_as_windows_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_windows_menu_for_nsapp"]}},"deny-set-checked":{"identifier":"deny-set-checked","description":"Denies the set_checked command without any pre-configured scope.","commands":{"allow":[],"deny":["set_checked"]}},"deny-set-enabled":{"identifier":"deny-set-enabled","description":"Denies the set_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["set_enabled"]}},"deny-set-icon":{"identifier":"deny-set-icon","description":"Denies the set_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon"]}},"deny-set-text":{"identifier":"deny-set-text","description":"Denies the set_text command without any pre-configured scope.","commands":{"allow":[],"deny":["set_text"]}},"deny-text":{"identifier":"deny-text","description":"Denies the text command without any pre-configured scope.","commands":{"allow":[],"deny":["text"]}}},"permission_sets":{},"global_scope_schema":null},"core:path":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-resolve-directory","allow-resolve","allow-normalize","allow-join","allow-dirname","allow-extname","allow-basename","allow-is-absolute"]},"permissions":{"allow-basename":{"identifier":"allow-basename","description":"Enables the basename command without any pre-configured scope.","commands":{"allow":["basename"],"deny":[]}},"allow-dirname":{"identifier":"allow-dirname","description":"Enables the dirname command without any pre-configured scope.","commands":{"allow":["dirname"],"deny":[]}},"allow-extname":{"identifier":"allow-extname","description":"Enables the extname command without any pre-configured scope.","commands":{"allow":["extname"],"deny":[]}},"allow-is-absolute":{"identifier":"allow-is-absolute","description":"Enables the is_absolute command without any pre-configured scope.","commands":{"allow":["is_absolute"],"deny":[]}},"allow-join":{"identifier":"allow-join","description":"Enables the join command without any pre-configured scope.","commands":{"allow":["join"],"deny":[]}},"allow-normalize":{"identifier":"allow-normalize","description":"Enables the normalize command without any pre-configured scope.","commands":{"allow":["normalize"],"deny":[]}},"allow-resolve":{"identifier":"allow-resolve","description":"Enables the resolve command without any pre-configured scope.","commands":{"allow":["resolve"],"deny":[]}},"allow-resolve-directory":{"identifier":"allow-resolve-directory","description":"Enables the resolve_directory command without any pre-configured scope.","commands":{"allow":["resolve_directory"],"deny":[]}},"deny-basename":{"identifier":"deny-basename","description":"Denies the basename command without any pre-configured scope.","commands":{"allow":[],"deny":["basename"]}},"deny-dirname":{"identifier":"deny-dirname","description":"Denies the dirname command without any pre-configured scope.","commands":{"allow":[],"deny":["dirname"]}},"deny-extname":{"identifier":"deny-extname","description":"Denies the extname command without any pre-configured scope.","commands":{"allow":[],"deny":["extname"]}},"deny-is-absolute":{"identifier":"deny-is-absolute","description":"Denies the is_absolute command without any pre-configured scope.","commands":{"allow":[],"deny":["is_absolute"]}},"deny-join":{"identifier":"deny-join","description":"Denies the join command without any pre-configured scope.","commands":{"allow":[],"deny":["join"]}},"deny-normalize":{"identifier":"deny-normalize","description":"Denies the normalize command without any pre-configured scope.","commands":{"allow":[],"deny":["normalize"]}},"deny-resolve":{"identifier":"deny-resolve","description":"Denies the resolve command without any pre-configured scope.","commands":{"allow":[],"deny":["resolve"]}},"deny-resolve-directory":{"identifier":"deny-resolve-directory","description":"Denies the resolve_directory command without any pre-configured scope.","commands":{"allow":[],"deny":["resolve_directory"]}}},"permission_sets":{},"global_scope_schema":null},"core:resources":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-close"]},"permissions":{"allow-close":{"identifier":"allow-close","description":"Enables the close command without any pre-configured scope.","commands":{"allow":["close"],"deny":[]}},"deny-close":{"identifier":"deny-close","description":"Denies the close command without any pre-configured scope.","commands":{"allow":[],"deny":["close"]}}},"permission_sets":{},"global_scope_schema":null},"core:tray":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-new","allow-get-by-id","allow-remove-by-id","allow-set-icon","allow-set-menu","allow-set-tooltip","allow-set-title","allow-set-visible","allow-set-temp-dir-path","allow-set-icon-as-template","allow-set-show-menu-on-left-click"]},"permissions":{"allow-get-by-id":{"identifier":"allow-get-by-id","description":"Enables the get_by_id command without any pre-configured scope.","commands":{"allow":["get_by_id"],"deny":[]}},"allow-new":{"identifier":"allow-new","description":"Enables the new command without any pre-configured scope.","commands":{"allow":["new"],"deny":[]}},"allow-remove-by-id":{"identifier":"allow-remove-by-id","description":"Enables the remove_by_id command without any pre-configured scope.","commands":{"allow":["remove_by_id"],"deny":[]}},"allow-set-icon":{"identifier":"allow-set-icon","description":"Enables the set_icon command without any pre-configured scope.","commands":{"allow":["set_icon"],"deny":[]}},"allow-set-icon-as-template":{"identifier":"allow-set-icon-as-template","description":"Enables the set_icon_as_template command without any pre-configured scope.","commands":{"allow":["set_icon_as_template"],"deny":[]}},"allow-set-menu":{"identifier":"allow-set-menu","description":"Enables the set_menu command without any pre-configured scope.","commands":{"allow":["set_menu"],"deny":[]}},"allow-set-show-menu-on-left-click":{"identifier":"allow-set-show-menu-on-left-click","description":"Enables the set_show_menu_on_left_click command without any pre-configured scope.","commands":{"allow":["set_show_menu_on_left_click"],"deny":[]}},"allow-set-temp-dir-path":{"identifier":"allow-set-temp-dir-path","description":"Enables the set_temp_dir_path command without any pre-configured scope.","commands":{"allow":["set_temp_dir_path"],"deny":[]}},"allow-set-title":{"identifier":"allow-set-title","description":"Enables the set_title command without any pre-configured scope.","commands":{"allow":["set_title"],"deny":[]}},"allow-set-tooltip":{"identifier":"allow-set-tooltip","description":"Enables the set_tooltip command without any pre-configured scope.","commands":{"allow":["set_tooltip"],"deny":[]}},"allow-set-visible":{"identifier":"allow-set-visible","description":"Enables the set_visible command without any pre-configured scope.","commands":{"allow":["set_visible"],"deny":[]}},"deny-get-by-id":{"identifier":"deny-get-by-id","description":"Denies the get_by_id command without any pre-configured scope.","commands":{"allow":[],"deny":["get_by_id"]}},"deny-new":{"identifier":"deny-new","description":"Denies the new command without any pre-configured scope.","commands":{"allow":[],"deny":["new"]}},"deny-remove-by-id":{"identifier":"deny-remove-by-id","description":"Denies the remove_by_id command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_by_id"]}},"deny-set-icon":{"identifier":"deny-set-icon","description":"Denies the set_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon"]}},"deny-set-icon-as-template":{"identifier":"deny-set-icon-as-template","description":"Denies the set_icon_as_template command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon_as_template"]}},"deny-set-menu":{"identifier":"deny-set-menu","description":"Denies the set_menu command without any pre-configured scope.","commands":{"allow":[],"deny":["set_menu"]}},"deny-set-show-menu-on-left-click":{"identifier":"deny-set-show-menu-on-left-click","description":"Denies the set_show_menu_on_left_click command without any pre-configured scope.","commands":{"allow":[],"deny":["set_show_menu_on_left_click"]}},"deny-set-temp-dir-path":{"identifier":"deny-set-temp-dir-path","description":"Denies the set_temp_dir_path command without any pre-configured scope.","commands":{"allow":[],"deny":["set_temp_dir_path"]}},"deny-set-title":{"identifier":"deny-set-title","description":"Denies the set_title command without any pre-configured scope.","commands":{"allow":[],"deny":["set_title"]}},"deny-set-tooltip":{"identifier":"deny-set-tooltip","description":"Denies the set_tooltip command without any pre-configured scope.","commands":{"allow":[],"deny":["set_tooltip"]}},"deny-set-visible":{"identifier":"deny-set-visible","description":"Denies the set_visible command without any pre-configured scope.","commands":{"allow":[],"deny":["set_visible"]}}},"permission_sets":{},"global_scope_schema":null},"core:webview":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin.","permissions":["allow-get-all-webviews","allow-webview-position","allow-webview-size","allow-internal-toggle-devtools"]},"permissions":{"allow-clear-all-browsing-data":{"identifier":"allow-clear-all-browsing-data","description":"Enables the clear_all_browsing_data command without any pre-configured scope.","commands":{"allow":["clear_all_browsing_data"],"deny":[]}},"allow-create-webview":{"identifier":"allow-create-webview","description":"Enables the create_webview command without any pre-configured scope.","commands":{"allow":["create_webview"],"deny":[]}},"allow-create-webview-window":{"identifier":"allow-create-webview-window","description":"Enables the create_webview_window command without any pre-configured scope.","commands":{"allow":["create_webview_window"],"deny":[]}},"allow-get-all-webviews":{"identifier":"allow-get-all-webviews","description":"Enables the get_all_webviews command without any pre-configured scope.","commands":{"allow":["get_all_webviews"],"deny":[]}},"allow-internal-toggle-devtools":{"identifier":"allow-internal-toggle-devtools","description":"Enables the internal_toggle_devtools command without any pre-configured scope.","commands":{"allow":["internal_toggle_devtools"],"deny":[]}},"allow-print":{"identifier":"allow-print","description":"Enables the print command without any pre-configured scope.","commands":{"allow":["print"],"deny":[]}},"allow-reparent":{"identifier":"allow-reparent","description":"Enables the reparent command without any pre-configured scope.","commands":{"allow":["reparent"],"deny":[]}},"allow-set-webview-auto-resize":{"identifier":"allow-set-webview-auto-resize","description":"Enables the set_webview_auto_resize command without any pre-configured scope.","commands":{"allow":["set_webview_auto_resize"],"deny":[]}},"allow-set-webview-background-color":{"identifier":"allow-set-webview-background-color","description":"Enables the set_webview_background_color command without any pre-configured scope.","commands":{"allow":["set_webview_background_color"],"deny":[]}},"allow-set-webview-focus":{"identifier":"allow-set-webview-focus","description":"Enables the set_webview_focus command without any pre-configured scope.","commands":{"allow":["set_webview_focus"],"deny":[]}},"allow-set-webview-position":{"identifier":"allow-set-webview-position","description":"Enables the set_webview_position command without any pre-configured scope.","commands":{"allow":["set_webview_position"],"deny":[]}},"allow-set-webview-size":{"identifier":"allow-set-webview-size","description":"Enables the set_webview_size command without any pre-configured scope.","commands":{"allow":["set_webview_size"],"deny":[]}},"allow-set-webview-zoom":{"identifier":"allow-set-webview-zoom","description":"Enables the set_webview_zoom command without any pre-configured scope.","commands":{"allow":["set_webview_zoom"],"deny":[]}},"allow-webview-close":{"identifier":"allow-webview-close","description":"Enables the webview_close command without any pre-configured scope.","commands":{"allow":["webview_close"],"deny":[]}},"allow-webview-hide":{"identifier":"allow-webview-hide","description":"Enables the webview_hide command without any pre-configured scope.","commands":{"allow":["webview_hide"],"deny":[]}},"allow-webview-position":{"identifier":"allow-webview-position","description":"Enables the webview_position command without any pre-configured scope.","commands":{"allow":["webview_position"],"deny":[]}},"allow-webview-show":{"identifier":"allow-webview-show","description":"Enables the webview_show command without any pre-configured scope.","commands":{"allow":["webview_show"],"deny":[]}},"allow-webview-size":{"identifier":"allow-webview-size","description":"Enables the webview_size command without any pre-configured scope.","commands":{"allow":["webview_size"],"deny":[]}},"deny-clear-all-browsing-data":{"identifier":"deny-clear-all-browsing-data","description":"Denies the clear_all_browsing_data command without any pre-configured scope.","commands":{"allow":[],"deny":["clear_all_browsing_data"]}},"deny-create-webview":{"identifier":"deny-create-webview","description":"Denies the create_webview command without any pre-configured scope.","commands":{"allow":[],"deny":["create_webview"]}},"deny-create-webview-window":{"identifier":"deny-create-webview-window","description":"Denies the create_webview_window command without any pre-configured scope.","commands":{"allow":[],"deny":["create_webview_window"]}},"deny-get-all-webviews":{"identifier":"deny-get-all-webviews","description":"Denies the get_all_webviews command without any pre-configured scope.","commands":{"allow":[],"deny":["get_all_webviews"]}},"deny-internal-toggle-devtools":{"identifier":"deny-internal-toggle-devtools","description":"Denies the internal_toggle_devtools command without any pre-configured scope.","commands":{"allow":[],"deny":["internal_toggle_devtools"]}},"deny-print":{"identifier":"deny-print","description":"Denies the print command without any pre-configured scope.","commands":{"allow":[],"deny":["print"]}},"deny-reparent":{"identifier":"deny-reparent","description":"Denies the reparent command without any pre-configured scope.","commands":{"allow":[],"deny":["reparent"]}},"deny-set-webview-auto-resize":{"identifier":"deny-set-webview-auto-resize","description":"Denies the set_webview_auto_resize command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_auto_resize"]}},"deny-set-webview-background-color":{"identifier":"deny-set-webview-background-color","description":"Denies the set_webview_background_color command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_background_color"]}},"deny-set-webview-focus":{"identifier":"deny-set-webview-focus","description":"Denies the set_webview_focus command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_focus"]}},"deny-set-webview-position":{"identifier":"deny-set-webview-position","description":"Denies the set_webview_position command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_position"]}},"deny-set-webview-size":{"identifier":"deny-set-webview-size","description":"Denies the set_webview_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_size"]}},"deny-set-webview-zoom":{"identifier":"deny-set-webview-zoom","description":"Denies the set_webview_zoom command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_zoom"]}},"deny-webview-close":{"identifier":"deny-webview-close","description":"Denies the webview_close command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_close"]}},"deny-webview-hide":{"identifier":"deny-webview-hide","description":"Denies the webview_hide command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_hide"]}},"deny-webview-position":{"identifier":"deny-webview-position","description":"Denies the webview_position command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_position"]}},"deny-webview-show":{"identifier":"deny-webview-show","description":"Denies the webview_show command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_show"]}},"deny-webview-size":{"identifier":"deny-webview-size","description":"Denies the webview_size command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_size"]}}},"permission_sets":{},"global_scope_schema":null},"core:window":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin.","permissions":["allow-get-all-windows","allow-scale-factor","allow-inner-position","allow-outer-position","allow-inner-size","allow-outer-size","allow-is-fullscreen","allow-is-minimized","allow-is-maximized","allow-is-focused","allow-is-decorated","allow-is-resizable","allow-is-maximizable","allow-is-minimizable","allow-is-closable","allow-is-visible","allow-is-enabled","allow-title","allow-current-monitor","allow-primary-monitor","allow-monitor-from-point","allow-available-monitors","allow-cursor-position","allow-theme","allow-is-always-on-top","allow-internal-toggle-maximize"]},"permissions":{"allow-available-monitors":{"identifier":"allow-available-monitors","description":"Enables the available_monitors command without any pre-configured scope.","commands":{"allow":["available_monitors"],"deny":[]}},"allow-center":{"identifier":"allow-center","description":"Enables the center command without any pre-configured scope.","commands":{"allow":["center"],"deny":[]}},"allow-close":{"identifier":"allow-close","description":"Enables the close command without any pre-configured scope.","commands":{"allow":["close"],"deny":[]}},"allow-create":{"identifier":"allow-create","description":"Enables the create command without any pre-configured scope.","commands":{"allow":["create"],"deny":[]}},"allow-current-monitor":{"identifier":"allow-current-monitor","description":"Enables the current_monitor command without any pre-configured scope.","commands":{"allow":["current_monitor"],"deny":[]}},"allow-cursor-position":{"identifier":"allow-cursor-position","description":"Enables the cursor_position command without any pre-configured scope.","commands":{"allow":["cursor_position"],"deny":[]}},"allow-destroy":{"identifier":"allow-destroy","description":"Enables the destroy command without any pre-configured scope.","commands":{"allow":["destroy"],"deny":[]}},"allow-get-all-windows":{"identifier":"allow-get-all-windows","description":"Enables the get_all_windows command without any pre-configured scope.","commands":{"allow":["get_all_windows"],"deny":[]}},"allow-hide":{"identifier":"allow-hide","description":"Enables the hide command without any pre-configured scope.","commands":{"allow":["hide"],"deny":[]}},"allow-inner-position":{"identifier":"allow-inner-position","description":"Enables the inner_position command without any pre-configured scope.","commands":{"allow":["inner_position"],"deny":[]}},"allow-inner-size":{"identifier":"allow-inner-size","description":"Enables the inner_size command without any pre-configured scope.","commands":{"allow":["inner_size"],"deny":[]}},"allow-internal-toggle-maximize":{"identifier":"allow-internal-toggle-maximize","description":"Enables the internal_toggle_maximize command without any pre-configured scope.","commands":{"allow":["internal_toggle_maximize"],"deny":[]}},"allow-is-always-on-top":{"identifier":"allow-is-always-on-top","description":"Enables the is_always_on_top command without any pre-configured scope.","commands":{"allow":["is_always_on_top"],"deny":[]}},"allow-is-closable":{"identifier":"allow-is-closable","description":"Enables the is_closable command without any pre-configured scope.","commands":{"allow":["is_closable"],"deny":[]}},"allow-is-decorated":{"identifier":"allow-is-decorated","description":"Enables the is_decorated command without any pre-configured scope.","commands":{"allow":["is_decorated"],"deny":[]}},"allow-is-enabled":{"identifier":"allow-is-enabled","description":"Enables the is_enabled command without any pre-configured scope.","commands":{"allow":["is_enabled"],"deny":[]}},"allow-is-focused":{"identifier":"allow-is-focused","description":"Enables the is_focused command without any pre-configured scope.","commands":{"allow":["is_focused"],"deny":[]}},"allow-is-fullscreen":{"identifier":"allow-is-fullscreen","description":"Enables the is_fullscreen command without any pre-configured scope.","commands":{"allow":["is_fullscreen"],"deny":[]}},"allow-is-maximizable":{"identifier":"allow-is-maximizable","description":"Enables the is_maximizable command without any pre-configured scope.","commands":{"allow":["is_maximizable"],"deny":[]}},"allow-is-maximized":{"identifier":"allow-is-maximized","description":"Enables the is_maximized command without any pre-configured scope.","commands":{"allow":["is_maximized"],"deny":[]}},"allow-is-minimizable":{"identifier":"allow-is-minimizable","description":"Enables the is_minimizable command without any pre-configured scope.","commands":{"allow":["is_minimizable"],"deny":[]}},"allow-is-minimized":{"identifier":"allow-is-minimized","description":"Enables the is_minimized command without any pre-configured scope.","commands":{"allow":["is_minimized"],"deny":[]}},"allow-is-resizable":{"identifier":"allow-is-resizable","description":"Enables the is_resizable command without any pre-configured scope.","commands":{"allow":["is_resizable"],"deny":[]}},"allow-is-visible":{"identifier":"allow-is-visible","description":"Enables the is_visible command without any pre-configured scope.","commands":{"allow":["is_visible"],"deny":[]}},"allow-maximize":{"identifier":"allow-maximize","description":"Enables the maximize command without any pre-configured scope.","commands":{"allow":["maximize"],"deny":[]}},"allow-minimize":{"identifier":"allow-minimize","description":"Enables the minimize command without any pre-configured scope.","commands":{"allow":["minimize"],"deny":[]}},"allow-monitor-from-point":{"identifier":"allow-monitor-from-point","description":"Enables the monitor_from_point command without any pre-configured scope.","commands":{"allow":["monitor_from_point"],"deny":[]}},"allow-outer-position":{"identifier":"allow-outer-position","description":"Enables the outer_position command without any pre-configured scope.","commands":{"allow":["outer_position"],"deny":[]}},"allow-outer-size":{"identifier":"allow-outer-size","description":"Enables the outer_size command without any pre-configured scope.","commands":{"allow":["outer_size"],"deny":[]}},"allow-primary-monitor":{"identifier":"allow-primary-monitor","description":"Enables the primary_monitor command without any pre-configured scope.","commands":{"allow":["primary_monitor"],"deny":[]}},"allow-request-user-attention":{"identifier":"allow-request-user-attention","description":"Enables the request_user_attention command without any pre-configured scope.","commands":{"allow":["request_user_attention"],"deny":[]}},"allow-scale-factor":{"identifier":"allow-scale-factor","description":"Enables the scale_factor command without any pre-configured scope.","commands":{"allow":["scale_factor"],"deny":[]}},"allow-set-always-on-bottom":{"identifier":"allow-set-always-on-bottom","description":"Enables the set_always_on_bottom command without any pre-configured scope.","commands":{"allow":["set_always_on_bottom"],"deny":[]}},"allow-set-always-on-top":{"identifier":"allow-set-always-on-top","description":"Enables the set_always_on_top command without any pre-configured scope.","commands":{"allow":["set_always_on_top"],"deny":[]}},"allow-set-background-color":{"identifier":"allow-set-background-color","description":"Enables the set_background_color command without any pre-configured scope.","commands":{"allow":["set_background_color"],"deny":[]}},"allow-set-badge-count":{"identifier":"allow-set-badge-count","description":"Enables the set_badge_count command without any pre-configured scope.","commands":{"allow":["set_badge_count"],"deny":[]}},"allow-set-badge-label":{"identifier":"allow-set-badge-label","description":"Enables the set_badge_label command without any pre-configured scope.","commands":{"allow":["set_badge_label"],"deny":[]}},"allow-set-closable":{"identifier":"allow-set-closable","description":"Enables the set_closable command without any pre-configured scope.","commands":{"allow":["set_closable"],"deny":[]}},"allow-set-content-protected":{"identifier":"allow-set-content-protected","description":"Enables the set_content_protected command without any pre-configured scope.","commands":{"allow":["set_content_protected"],"deny":[]}},"allow-set-cursor-grab":{"identifier":"allow-set-cursor-grab","description":"Enables the set_cursor_grab command without any pre-configured scope.","commands":{"allow":["set_cursor_grab"],"deny":[]}},"allow-set-cursor-icon":{"identifier":"allow-set-cursor-icon","description":"Enables the set_cursor_icon command without any pre-configured scope.","commands":{"allow":["set_cursor_icon"],"deny":[]}},"allow-set-cursor-position":{"identifier":"allow-set-cursor-position","description":"Enables the set_cursor_position command without any pre-configured scope.","commands":{"allow":["set_cursor_position"],"deny":[]}},"allow-set-cursor-visible":{"identifier":"allow-set-cursor-visible","description":"Enables the set_cursor_visible command without any pre-configured scope.","commands":{"allow":["set_cursor_visible"],"deny":[]}},"allow-set-decorations":{"identifier":"allow-set-decorations","description":"Enables the set_decorations command without any pre-configured scope.","commands":{"allow":["set_decorations"],"deny":[]}},"allow-set-effects":{"identifier":"allow-set-effects","description":"Enables the set_effects command without any pre-configured scope.","commands":{"allow":["set_effects"],"deny":[]}},"allow-set-enabled":{"identifier":"allow-set-enabled","description":"Enables the set_enabled command without any pre-configured scope.","commands":{"allow":["set_enabled"],"deny":[]}},"allow-set-focus":{"identifier":"allow-set-focus","description":"Enables the set_focus command without any pre-configured scope.","commands":{"allow":["set_focus"],"deny":[]}},"allow-set-focusable":{"identifier":"allow-set-focusable","description":"Enables the set_focusable command without any pre-configured scope.","commands":{"allow":["set_focusable"],"deny":[]}},"allow-set-fullscreen":{"identifier":"allow-set-fullscreen","description":"Enables the set_fullscreen command without any pre-configured scope.","commands":{"allow":["set_fullscreen"],"deny":[]}},"allow-set-icon":{"identifier":"allow-set-icon","description":"Enables the set_icon command without any pre-configured scope.","commands":{"allow":["set_icon"],"deny":[]}},"allow-set-ignore-cursor-events":{"identifier":"allow-set-ignore-cursor-events","description":"Enables the set_ignore_cursor_events command without any pre-configured scope.","commands":{"allow":["set_ignore_cursor_events"],"deny":[]}},"allow-set-max-size":{"identifier":"allow-set-max-size","description":"Enables the set_max_size command without any pre-configured scope.","commands":{"allow":["set_max_size"],"deny":[]}},"allow-set-maximizable":{"identifier":"allow-set-maximizable","description":"Enables the set_maximizable command without any pre-configured scope.","commands":{"allow":["set_maximizable"],"deny":[]}},"allow-set-min-size":{"identifier":"allow-set-min-size","description":"Enables the set_min_size command without any pre-configured scope.","commands":{"allow":["set_min_size"],"deny":[]}},"allow-set-minimizable":{"identifier":"allow-set-minimizable","description":"Enables the set_minimizable command without any pre-configured scope.","commands":{"allow":["set_minimizable"],"deny":[]}},"allow-set-overlay-icon":{"identifier":"allow-set-overlay-icon","description":"Enables the set_overlay_icon command without any pre-configured scope.","commands":{"allow":["set_overlay_icon"],"deny":[]}},"allow-set-position":{"identifier":"allow-set-position","description":"Enables the set_position command without any pre-configured scope.","commands":{"allow":["set_position"],"deny":[]}},"allow-set-progress-bar":{"identifier":"allow-set-progress-bar","description":"Enables the set_progress_bar command without any pre-configured scope.","commands":{"allow":["set_progress_bar"],"deny":[]}},"allow-set-resizable":{"identifier":"allow-set-resizable","description":"Enables the set_resizable command without any pre-configured scope.","commands":{"allow":["set_resizable"],"deny":[]}},"allow-set-shadow":{"identifier":"allow-set-shadow","description":"Enables the set_shadow command without any pre-configured scope.","commands":{"allow":["set_shadow"],"deny":[]}},"allow-set-simple-fullscreen":{"identifier":"allow-set-simple-fullscreen","description":"Enables the set_simple_fullscreen command without any pre-configured scope.","commands":{"allow":["set_simple_fullscreen"],"deny":[]}},"allow-set-size":{"identifier":"allow-set-size","description":"Enables the set_size command without any pre-configured scope.","commands":{"allow":["set_size"],"deny":[]}},"allow-set-size-constraints":{"identifier":"allow-set-size-constraints","description":"Enables the set_size_constraints command without any pre-configured scope.","commands":{"allow":["set_size_constraints"],"deny":[]}},"allow-set-skip-taskbar":{"identifier":"allow-set-skip-taskbar","description":"Enables the set_skip_taskbar command without any pre-configured scope.","commands":{"allow":["set_skip_taskbar"],"deny":[]}},"allow-set-theme":{"identifier":"allow-set-theme","description":"Enables the set_theme command without any pre-configured scope.","commands":{"allow":["set_theme"],"deny":[]}},"allow-set-title":{"identifier":"allow-set-title","description":"Enables the set_title command without any pre-configured scope.","commands":{"allow":["set_title"],"deny":[]}},"allow-set-title-bar-style":{"identifier":"allow-set-title-bar-style","description":"Enables the set_title_bar_style command without any pre-configured scope.","commands":{"allow":["set_title_bar_style"],"deny":[]}},"allow-set-visible-on-all-workspaces":{"identifier":"allow-set-visible-on-all-workspaces","description":"Enables the set_visible_on_all_workspaces command without any pre-configured scope.","commands":{"allow":["set_visible_on_all_workspaces"],"deny":[]}},"allow-show":{"identifier":"allow-show","description":"Enables the show command without any pre-configured scope.","commands":{"allow":["show"],"deny":[]}},"allow-start-dragging":{"identifier":"allow-start-dragging","description":"Enables the start_dragging command without any pre-configured scope.","commands":{"allow":["start_dragging"],"deny":[]}},"allow-start-resize-dragging":{"identifier":"allow-start-resize-dragging","description":"Enables the start_resize_dragging command without any pre-configured scope.","commands":{"allow":["start_resize_dragging"],"deny":[]}},"allow-theme":{"identifier":"allow-theme","description":"Enables the theme command without any pre-configured scope.","commands":{"allow":["theme"],"deny":[]}},"allow-title":{"identifier":"allow-title","description":"Enables the title command without any pre-configured scope.","commands":{"allow":["title"],"deny":[]}},"allow-toggle-maximize":{"identifier":"allow-toggle-maximize","description":"Enables the toggle_maximize command without any pre-configured scope.","commands":{"allow":["toggle_maximize"],"deny":[]}},"allow-unmaximize":{"identifier":"allow-unmaximize","description":"Enables the unmaximize command without any pre-configured scope.","commands":{"allow":["unmaximize"],"deny":[]}},"allow-unminimize":{"identifier":"allow-unminimize","description":"Enables the unminimize command without any pre-configured scope.","commands":{"allow":["unminimize"],"deny":[]}},"deny-available-monitors":{"identifier":"deny-available-monitors","description":"Denies the available_monitors command without any pre-configured scope.","commands":{"allow":[],"deny":["available_monitors"]}},"deny-center":{"identifier":"deny-center","description":"Denies the center command without any pre-configured scope.","commands":{"allow":[],"deny":["center"]}},"deny-close":{"identifier":"deny-close","description":"Denies the close command without any pre-configured scope.","commands":{"allow":[],"deny":["close"]}},"deny-create":{"identifier":"deny-create","description":"Denies the create command without any pre-configured scope.","commands":{"allow":[],"deny":["create"]}},"deny-current-monitor":{"identifier":"deny-current-monitor","description":"Denies the current_monitor command without any pre-configured scope.","commands":{"allow":[],"deny":["current_monitor"]}},"deny-cursor-position":{"identifier":"deny-cursor-position","description":"Denies the cursor_position command without any pre-configured scope.","commands":{"allow":[],"deny":["cursor_position"]}},"deny-destroy":{"identifier":"deny-destroy","description":"Denies the destroy command without any pre-configured scope.","commands":{"allow":[],"deny":["destroy"]}},"deny-get-all-windows":{"identifier":"deny-get-all-windows","description":"Denies the get_all_windows command without any pre-configured scope.","commands":{"allow":[],"deny":["get_all_windows"]}},"deny-hide":{"identifier":"deny-hide","description":"Denies the hide command without any pre-configured scope.","commands":{"allow":[],"deny":["hide"]}},"deny-inner-position":{"identifier":"deny-inner-position","description":"Denies the inner_position command without any pre-configured scope.","commands":{"allow":[],"deny":["inner_position"]}},"deny-inner-size":{"identifier":"deny-inner-size","description":"Denies the inner_size command without any pre-configured scope.","commands":{"allow":[],"deny":["inner_size"]}},"deny-internal-toggle-maximize":{"identifier":"deny-internal-toggle-maximize","description":"Denies the internal_toggle_maximize command without any pre-configured scope.","commands":{"allow":[],"deny":["internal_toggle_maximize"]}},"deny-is-always-on-top":{"identifier":"deny-is-always-on-top","description":"Denies the is_always_on_top command without any pre-configured scope.","commands":{"allow":[],"deny":["is_always_on_top"]}},"deny-is-closable":{"identifier":"deny-is-closable","description":"Denies the is_closable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_closable"]}},"deny-is-decorated":{"identifier":"deny-is-decorated","description":"Denies the is_decorated command without any pre-configured scope.","commands":{"allow":[],"deny":["is_decorated"]}},"deny-is-enabled":{"identifier":"deny-is-enabled","description":"Denies the is_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["is_enabled"]}},"deny-is-focused":{"identifier":"deny-is-focused","description":"Denies the is_focused command without any pre-configured scope.","commands":{"allow":[],"deny":["is_focused"]}},"deny-is-fullscreen":{"identifier":"deny-is-fullscreen","description":"Denies the is_fullscreen command without any pre-configured scope.","commands":{"allow":[],"deny":["is_fullscreen"]}},"deny-is-maximizable":{"identifier":"deny-is-maximizable","description":"Denies the is_maximizable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_maximizable"]}},"deny-is-maximized":{"identifier":"deny-is-maximized","description":"Denies the is_maximized command without any pre-configured scope.","commands":{"allow":[],"deny":["is_maximized"]}},"deny-is-minimizable":{"identifier":"deny-is-minimizable","description":"Denies the is_minimizable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_minimizable"]}},"deny-is-minimized":{"identifier":"deny-is-minimized","description":"Denies the is_minimized command without any pre-configured scope.","commands":{"allow":[],"deny":["is_minimized"]}},"deny-is-resizable":{"identifier":"deny-is-resizable","description":"Denies the is_resizable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_resizable"]}},"deny-is-visible":{"identifier":"deny-is-visible","description":"Denies the is_visible command without any pre-configured scope.","commands":{"allow":[],"deny":["is_visible"]}},"deny-maximize":{"identifier":"deny-maximize","description":"Denies the maximize command without any pre-configured scope.","commands":{"allow":[],"deny":["maximize"]}},"deny-minimize":{"identifier":"deny-minimize","description":"Denies the minimize command without any pre-configured scope.","commands":{"allow":[],"deny":["minimize"]}},"deny-monitor-from-point":{"identifier":"deny-monitor-from-point","description":"Denies the monitor_from_point command without any pre-configured scope.","commands":{"allow":[],"deny":["monitor_from_point"]}},"deny-outer-position":{"identifier":"deny-outer-position","description":"Denies the outer_position command without any pre-configured scope.","commands":{"allow":[],"deny":["outer_position"]}},"deny-outer-size":{"identifier":"deny-outer-size","description":"Denies the outer_size command without any pre-configured scope.","commands":{"allow":[],"deny":["outer_size"]}},"deny-primary-monitor":{"identifier":"deny-primary-monitor","description":"Denies the primary_monitor command without any pre-configured scope.","commands":{"allow":[],"deny":["primary_monitor"]}},"deny-request-user-attention":{"identifier":"deny-request-user-attention","description":"Denies the request_user_attention command without any pre-configured scope.","commands":{"allow":[],"deny":["request_user_attention"]}},"deny-scale-factor":{"identifier":"deny-scale-factor","description":"Denies the scale_factor command without any pre-configured scope.","commands":{"allow":[],"deny":["scale_factor"]}},"deny-set-always-on-bottom":{"identifier":"deny-set-always-on-bottom","description":"Denies the set_always_on_bottom command without any pre-configured scope.","commands":{"allow":[],"deny":["set_always_on_bottom"]}},"deny-set-always-on-top":{"identifier":"deny-set-always-on-top","description":"Denies the set_always_on_top command without any pre-configured scope.","commands":{"allow":[],"deny":["set_always_on_top"]}},"deny-set-background-color":{"identifier":"deny-set-background-color","description":"Denies the set_background_color command without any pre-configured scope.","commands":{"allow":[],"deny":["set_background_color"]}},"deny-set-badge-count":{"identifier":"deny-set-badge-count","description":"Denies the set_badge_count command without any pre-configured scope.","commands":{"allow":[],"deny":["set_badge_count"]}},"deny-set-badge-label":{"identifier":"deny-set-badge-label","description":"Denies the set_badge_label command without any pre-configured scope.","commands":{"allow":[],"deny":["set_badge_label"]}},"deny-set-closable":{"identifier":"deny-set-closable","description":"Denies the set_closable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_closable"]}},"deny-set-content-protected":{"identifier":"deny-set-content-protected","description":"Denies the set_content_protected command without any pre-configured scope.","commands":{"allow":[],"deny":["set_content_protected"]}},"deny-set-cursor-grab":{"identifier":"deny-set-cursor-grab","description":"Denies the set_cursor_grab command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_grab"]}},"deny-set-cursor-icon":{"identifier":"deny-set-cursor-icon","description":"Denies the set_cursor_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_icon"]}},"deny-set-cursor-position":{"identifier":"deny-set-cursor-position","description":"Denies the set_cursor_position command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_position"]}},"deny-set-cursor-visible":{"identifier":"deny-set-cursor-visible","description":"Denies the set_cursor_visible command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_visible"]}},"deny-set-decorations":{"identifier":"deny-set-decorations","description":"Denies the set_decorations command without any pre-configured scope.","commands":{"allow":[],"deny":["set_decorations"]}},"deny-set-effects":{"identifier":"deny-set-effects","description":"Denies the set_effects command without any pre-configured scope.","commands":{"allow":[],"deny":["set_effects"]}},"deny-set-enabled":{"identifier":"deny-set-enabled","description":"Denies the set_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["set_enabled"]}},"deny-set-focus":{"identifier":"deny-set-focus","description":"Denies the set_focus command without any pre-configured scope.","commands":{"allow":[],"deny":["set_focus"]}},"deny-set-focusable":{"identifier":"deny-set-focusable","description":"Denies the set_focusable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_focusable"]}},"deny-set-fullscreen":{"identifier":"deny-set-fullscreen","description":"Denies the set_fullscreen command without any pre-configured scope.","commands":{"allow":[],"deny":["set_fullscreen"]}},"deny-set-icon":{"identifier":"deny-set-icon","description":"Denies the set_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon"]}},"deny-set-ignore-cursor-events":{"identifier":"deny-set-ignore-cursor-events","description":"Denies the set_ignore_cursor_events command without any pre-configured scope.","commands":{"allow":[],"deny":["set_ignore_cursor_events"]}},"deny-set-max-size":{"identifier":"deny-set-max-size","description":"Denies the set_max_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_max_size"]}},"deny-set-maximizable":{"identifier":"deny-set-maximizable","description":"Denies the set_maximizable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_maximizable"]}},"deny-set-min-size":{"identifier":"deny-set-min-size","description":"Denies the set_min_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_min_size"]}},"deny-set-minimizable":{"identifier":"deny-set-minimizable","description":"Denies the set_minimizable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_minimizable"]}},"deny-set-overlay-icon":{"identifier":"deny-set-overlay-icon","description":"Denies the set_overlay_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_overlay_icon"]}},"deny-set-position":{"identifier":"deny-set-position","description":"Denies the set_position command without any pre-configured scope.","commands":{"allow":[],"deny":["set_position"]}},"deny-set-progress-bar":{"identifier":"deny-set-progress-bar","description":"Denies the set_progress_bar command without any pre-configured scope.","commands":{"allow":[],"deny":["set_progress_bar"]}},"deny-set-resizable":{"identifier":"deny-set-resizable","description":"Denies the set_resizable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_resizable"]}},"deny-set-shadow":{"identifier":"deny-set-shadow","description":"Denies the set_shadow command without any pre-configured scope.","commands":{"allow":[],"deny":["set_shadow"]}},"deny-set-simple-fullscreen":{"identifier":"deny-set-simple-fullscreen","description":"Denies the set_simple_fullscreen command without any pre-configured scope.","commands":{"allow":[],"deny":["set_simple_fullscreen"]}},"deny-set-size":{"identifier":"deny-set-size","description":"Denies the set_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_size"]}},"deny-set-size-constraints":{"identifier":"deny-set-size-constraints","description":"Denies the set_size_constraints command without any pre-configured scope.","commands":{"allow":[],"deny":["set_size_constraints"]}},"deny-set-skip-taskbar":{"identifier":"deny-set-skip-taskbar","description":"Denies the set_skip_taskbar command without any pre-configured scope.","commands":{"allow":[],"deny":["set_skip_taskbar"]}},"deny-set-theme":{"identifier":"deny-set-theme","description":"Denies the set_theme command without any pre-configured scope.","commands":{"allow":[],"deny":["set_theme"]}},"deny-set-title":{"identifier":"deny-set-title","description":"Denies the set_title command without any pre-configured scope.","commands":{"allow":[],"deny":["set_title"]}},"deny-set-title-bar-style":{"identifier":"deny-set-title-bar-style","description":"Denies the set_title_bar_style command without any pre-configured scope.","commands":{"allow":[],"deny":["set_title_bar_style"]}},"deny-set-visible-on-all-workspaces":{"identifier":"deny-set-visible-on-all-workspaces","description":"Denies the set_visible_on_all_workspaces command without any pre-configured scope.","commands":{"allow":[],"deny":["set_visible_on_all_workspaces"]}},"deny-show":{"identifier":"deny-show","description":"Denies the show command without any pre-configured scope.","commands":{"allow":[],"deny":["show"]}},"deny-start-dragging":{"identifier":"deny-start-dragging","description":"Denies the start_dragging command without any pre-configured scope.","commands":{"allow":[],"deny":["start_dragging"]}},"deny-start-resize-dragging":{"identifier":"deny-start-resize-dragging","description":"Denies the start_resize_dragging command without any pre-configured scope.","commands":{"allow":[],"deny":["start_resize_dragging"]}},"deny-theme":{"identifier":"deny-theme","description":"Denies the theme command without any pre-configured scope.","commands":{"allow":[],"deny":["theme"]}},"deny-title":{"identifier":"deny-title","description":"Denies the title command without any pre-configured scope.","commands":{"allow":[],"deny":["title"]}},"deny-toggle-maximize":{"identifier":"deny-toggle-maximize","description":"Denies the toggle_maximize command without any pre-configured scope.","commands":{"allow":[],"deny":["toggle_maximize"]}},"deny-unmaximize":{"identifier":"deny-unmaximize","description":"Denies the unmaximize command without any pre-configured scope.","commands":{"allow":[],"deny":["unmaximize"]}},"deny-unminimize":{"identifier":"deny-unminimize","description":"Denies the unminimize command without any pre-configured scope.","commands":{"allow":[],"deny":["unminimize"]}}},"permission_sets":{},"global_scope_schema":null},"opener":{"default_permission":{"identifier":"default","description":"This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer","permissions":["allow-open-url","allow-reveal-item-in-dir","allow-default-urls"]},"permissions":{"allow-default-urls":{"identifier":"allow-default-urls","description":"This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"url":"mailto:*"},{"url":"tel:*"},{"url":"http://*"},{"url":"https://*"}]}},"allow-open-path":{"identifier":"allow-open-path","description":"Enables the open_path command without any pre-configured scope.","commands":{"allow":["open_path"],"deny":[]}},"allow-open-url":{"identifier":"allow-open-url","description":"Enables the open_url command without any pre-configured scope.","commands":{"allow":["open_url"],"deny":[]}},"allow-reveal-item-in-dir":{"identifier":"allow-reveal-item-in-dir","description":"Enables the reveal_item_in_dir command without any pre-configured scope.","commands":{"allow":["reveal_item_in_dir"],"deny":[]}},"deny-open-path":{"identifier":"deny-open-path","description":"Denies the open_path command without any pre-configured scope.","commands":{"allow":[],"deny":["open_path"]}},"deny-open-url":{"identifier":"deny-open-url","description":"Denies the open_url command without any pre-configured scope.","commands":{"allow":[],"deny":["open_url"]}},"deny-reveal-item-in-dir":{"identifier":"deny-reveal-item-in-dir","description":"Denies the reveal_item_in_dir command without any pre-configured scope.","commands":{"allow":[],"deny":["reveal_item_in_dir"]}}},"permission_sets":{},"global_scope_schema":{"$schema":"http://json-schema.org/draft-07/schema#","anyOf":[{"properties":{"app":{"allOf":[{"$ref":"#/definitions/Application"}],"description":"An application to open this url with, for example: firefox."},"url":{"description":"A URL that can be opened by the webview when using the Opener APIs.\n\nWildcards can be used following the UNIX glob pattern.\n\nExamples:\n\n- \"https://*\" : allows all HTTPS origin\n\n- \"https://*.github.com/tauri-apps/tauri\": allows any subdomain of \"github.com\" with the \"tauri-apps/api\" path\n\n- \"https://myapi.service.com/users/*\": allows access to any URLs that begins with \"https://myapi.service.com/users/\"","type":"string"}},"required":["url"],"type":"object"},{"properties":{"app":{"allOf":[{"$ref":"#/definitions/Application"}],"description":"An application to open this path with, for example: xdg-open."},"path":{"description":"A path that can be opened by the webview when using the Opener APIs.\n\nThe pattern can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.","type":"string"}},"required":["path"],"type":"object"}],"definitions":{"Application":{"anyOf":[{"description":"Open in default application.","type":"null"},{"description":"If true, allow open with any application.","type":"boolean"},{"description":"Allow specific application to open with.","type":"string"}],"description":"Opener scope application."}},"description":"Opener scope entry.","title":"OpenerScopeEntry"}}}
          ```

        - ğŸ“„ **desktop-schema.json**

          ğŸ“„ *File Path*: `.\src-tauri\gen\schemas\desktop-schema.json`
          *Size*: 126319 bytes | *Modified*: 2026-01-16 17:26:01

          ```
          {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "title": "CapabilityFile",
            "description": "Capability formats accepted in a capability file.",
            "anyOf": [
              {
                "description": "A single capability.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Capability"
                  }
                ]
              },
              {
                "description": "A list of capabilities.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Capability"
                }
              },
              {
                "description": "A list of capabilities.",
                "type": "object",
                "required": [
                  "capabilities"
                ],
                "properties": {
                  "capabilities": {
                    "description": "The list of capabilities.",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Capability"
                    }
                  }
                }
              }
            ],
            "definitions": {
              "Capability": {
                "description": "A grouping and boundary mechanism developers can use to isolate access to the IPC layer.\n\nIt controls application windows' and webviews' fine grained access to the Tauri core, application, or plugin commands. If a webview or its window is not matching any capability then it has no access to the IPC layer at all.\n\nThis can be done to create groups of windows, based on their required system access, which can reduce impact of frontend vulnerabilities in less privileged windows. Windows can be added to a capability by exact name (e.g. `main-window`) or glob patterns like `*` or `admin-*`. A Window can have none, one, or multiple associated capabilities.\n\n## Example\n\n```json { \"identifier\": \"main-user-files-write\", \"description\": \"This capability allows the `main` window on macOS and Windows access to `filesystem` write related commands and `dialog` commands to enable programmatic access to files selected by the user.\", \"windows\": [ \"main\" ], \"permissions\": [ \"core:default\", \"dialog:open\", { \"identifier\": \"fs:allow-write-text-file\", \"allow\": [{ \"path\": \"$HOME/test.txt\" }] }, ], \"platforms\": [\"macOS\",\"windows\"] } ```",
                "type": "object",
                "required": [
                  "identifier",
                  "permissions"
                ],
                "properties": {
                  "identifier": {
                    "description": "Identifier of the capability.\n\n## Example\n\n`main-user-files-write`",
                    "type": "string"
                  },
                  "description": {
                    "description": "Description of what the capability is intended to allow on associated windows.\n\nIt should contain a description of what the grouped permissions should allow.\n\n## Example\n\nThis capability allows the `main` window access to `filesystem` write related commands and `dialog` commands to enable programmatic access to files selected by the user.",
                    "default": "",
                    "type": "string"
                  },
                  "remote": {
                    "description": "Configure remote URLs that can use the capability permissions.\n\nThis setting is optional and defaults to not being set, as our default use case is that the content is served from our local application.\n\n:::caution Make sure you understand the security implications of providing remote sources with local system access. :::\n\n## Example\n\n```json { \"urls\": [\"https://*.mydomain.dev\"] } ```",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/CapabilityRemote"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "local": {
                    "description": "Whether this capability is enabled for local app URLs or not. Defaults to `true`.",
                    "default": true,
                    "type": "boolean"
                  },
                  "windows": {
                    "description": "List of windows that are affected by this capability. Can be a glob pattern.\n\nIf a window label matches any of the patterns in this list, the capability will be enabled on all the webviews of that window, regardless of the value of [`Self::webviews`].\n\nOn multiwebview windows, prefer specifying [`Self::webviews`] and omitting [`Self::windows`] for a fine grained access control.\n\n## Example\n\n`[\"main\"]`",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "webviews": {
                    "description": "List of webviews that are affected by this capability. Can be a glob pattern.\n\nThe capability will be enabled on all the webviews whose label matches any of the patterns in this list, regardless of whether the webview's window label matches a pattern in [`Self::windows`].\n\n## Example\n\n`[\"sub-webview-one\", \"sub-webview-two\"]`",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "permissions": {
                    "description": "List of permissions attached to this capability.\n\nMust include the plugin name as prefix in the form of `${plugin-name}:${permission-name}`. For commands directly implemented in the application itself only `${permission-name}` is required.\n\n## Example\n\n```json [ \"core:default\", \"shell:allow-open\", \"dialog:open\", { \"identifier\": \"fs:allow-write-text-file\", \"allow\": [{ \"path\": \"$HOME/test.txt\" }] } ] ```",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/PermissionEntry"
                    },
                    "uniqueItems": true
                  },
                  "platforms": {
                    "description": "Limit which target platforms this capability applies to.\n\nBy default all platforms are targeted.\n\n## Example\n\n`[\"macOS\",\"windows\"]`",
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "$ref": "#/definitions/Target"
                    }
                  }
                }
              },
              "CapabilityRemote": {
                "description": "Configuration for remote URLs that are associated with the capability.",
                "type": "object",
                "required": [
                  "urls"
                ],
                "properties": {
                  "urls": {
                    "description": "Remote domains this capability refers to using the [URLPattern standard](https://urlpattern.spec.whatwg.org/).\n\n## Examples\n\n- \"https://*.mydomain.dev\": allows subdomains of mydomain.dev - \"https://mydomain.dev/api/*\": allows any subpath of mydomain.dev/api",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              },
              "PermissionEntry": {
                "description": "An entry for a permission value in a [`Capability`] can be either a raw permission [`Identifier`] or an object that references a permission and extends its scope.",
                "anyOf": [
                  {
                    "description": "Reference a permission or permission set by identifier.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Identifier"
                      }
                    ]
                  },
                  {
                    "description": "Reference a permission or permission set by identifier and extends its scope.",
                    "type": "object",
                    "allOf": [
                      {
                        "if": {
                          "properties": {
                            "identifier": {
                              "anyOf": [
                                {
                                  "description": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`",
                                  "type": "string",
                                  "const": "opener:default",
                                  "markdownDescription": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`"
                                },
                                {
                                  "description": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application.",
                                  "type": "string",
                                  "const": "opener:allow-default-urls",
                                  "markdownDescription": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application."
                                },
                                {
                                  "description": "Enables the open_path command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:allow-open-path",
                                  "markdownDescription": "Enables the open_path command without any pre-configured scope."
                                },
                                {
                                  "description": "Enables the open_url command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:allow-open-url",
                                  "markdownDescription": "Enables the open_url command without any pre-configured scope."
                                },
                                {
                                  "description": "Enables the reveal_item_in_dir command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:allow-reveal-item-in-dir",
                                  "markdownDescription": "Enables the reveal_item_in_dir command without any pre-configured scope."
                                },
                                {
                                  "description": "Denies the open_path command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:deny-open-path",
                                  "markdownDescription": "Denies the open_path command without any pre-configured scope."
                                },
                                {
                                  "description": "Denies the open_url command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:deny-open-url",
                                  "markdownDescription": "Denies the open_url command without any pre-configured scope."
                                },
                                {
                                  "description": "Denies the reveal_item_in_dir command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:deny-reveal-item-in-dir",
                                  "markdownDescription": "Denies the reveal_item_in_dir command without any pre-configured scope."
                                }
                              ]
                            }
                          }
                        },
                        "then": {
                          "properties": {
                            "allow": {
                              "items": {
                                "title": "OpenerScopeEntry",
                                "description": "Opener scope entry.",
                                "anyOf": [
                                  {
                                    "type": "object",
                                    "required": [
                                      "url"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this url with, for example: firefox.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "url": {
                                        "description": "A URL that can be opened by the webview when using the Opener APIs.\n\nWildcards can be used following the UNIX glob pattern.\n\nExamples:\n\n- \"https://*\" : allows all HTTPS origin\n\n- \"https://*.github.com/tauri-apps/tauri\": allows any subdomain of \"github.com\" with the \"tauri-apps/api\" path\n\n- \"https://myapi.service.com/users/*\": allows access to any URLs that begins with \"https://myapi.service.com/users/\"",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  {
                                    "type": "object",
                                    "required": [
                                      "path"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this path with, for example: xdg-open.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "path": {
                                        "description": "A path that can be opened by the webview when using the Opener APIs.\n\nThe pattern can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                ]
                              }
                            },
                            "deny": {
                              "items": {
                                "title": "OpenerScopeEntry",
                                "description": "Opener scope entry.",
                                "anyOf": [
                                  {
                                    "type": "object",
                                    "required": [
                                      "url"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this url with, for example: firefox.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "url": {
                                        "description": "A URL that can be opened by the webview when using the Opener APIs.\n\nWildcards can be used following the UNIX glob pattern.\n\nExamples:\n\n- \"https://*\" : allows all HTTPS origin\n\n- \"https://*.github.com/tauri-apps/tauri\": allows any subdomain of \"github.com\" with the \"tauri-apps/api\" path\n\n- \"https://myapi.service.com/users/*\": allows access to any URLs that begins with \"https://myapi.service.com/users/\"",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  {
                                    "type": "object",
                                    "required": [
                                      "path"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this path with, for example: xdg-open.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "path": {
                                        "description": "A path that can be opened by the webview when using the Opener APIs.\n\nThe pattern can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                ]
                              }
                            }
                          }
                        },
                        "properties": {
                          "identifier": {
                            "description": "Identifier of the permission or permission set.",
                            "allOf": [
                              {
                                "$ref": "#/definitions/Identifier"
                              }
                            ]
                          }
                        }
                      },
                      {
                        "properties": {
                          "identifier": {
                            "description": "Identifier of the permission or permission set.",
                            "allOf": [
                              {
                                "$ref": "#/definitions/Identifier"
                              }
                            ]
                          },
                          "allow": {
                            "description": "Data that defines what is allowed by the scope.",
                            "type": [
                              "array",
                              "null"
                            ],
                            "items": {
                              "$ref": "#/definitions/Value"
                            }
                          },
                          "deny": {
                            "description": "Data that defines what is denied by the scope. This should be prioritized by validation logic.",
                            "type": [
                              "array",
                              "null"
                            ],
                            "items": {
                              "$ref": "#/definitions/Value"
                            }
                          }
                        }
                      }
                    ],
                    "required": [
                      "identifier"
                    ]
                  }
                ]
              },
              "Identifier": {
                "description": "Permission identifier",
                "oneOf": [
                  {
                    "description": "Default core plugins set.\n#### This default permission set includes:\n\n- `core:path:default`\n- `core:event:default`\n- `core:window:default`\n- `core:webview:default`\n- `core:app:default`\n- `core:image:default`\n- `core:resources:default`\n- `core:menu:default`\n- `core:tray:default`",
                    "type": "string",
                    "const": "core:default",
                    "markdownDescription": "Default core plugins set.\n#### This default permission set includes:\n\n- `core:path:default`\n- `core:event:default`\n- `core:window:default`\n- `core:webview:default`\n- `core:app:default`\n- `core:image:default`\n- `core:resources:default`\n- `core:menu:default`\n- `core:tray:default`"
                  },
                  {
                    "description": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-version`\n- `allow-name`\n- `allow-tauri-version`\n- `allow-identifier`\n- `allow-bundle-type`\n- `allow-register-listener`\n- `allow-remove-listener`",
                    "type": "string",
                    "const": "core:app:default",
                    "markdownDescription": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-version`\n- `allow-name`\n- `allow-tauri-version`\n- `allow-identifier`\n- `allow-bundle-type`\n- `allow-register-listener`\n- `allow-remove-listener`"
                  },
                  {
                    "description": "Enables the app_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-app-hide",
                    "markdownDescription": "Enables the app_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the app_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-app-show",
                    "markdownDescription": "Enables the app_show command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the bundle_type command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-bundle-type",
                    "markdownDescription": "Enables the bundle_type command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the default_window_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-default-window-icon",
                    "markdownDescription": "Enables the default_window_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the fetch_data_store_identifiers command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-fetch-data-store-identifiers",
                    "markdownDescription": "Enables the fetch_data_store_identifiers command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the identifier command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-identifier",
                    "markdownDescription": "Enables the identifier command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the name command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-name",
                    "markdownDescription": "Enables the name command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the register_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-register-listener",
                    "markdownDescription": "Enables the register_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_data_store command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-remove-data-store",
                    "markdownDescription": "Enables the remove_data_store command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-remove-listener",
                    "markdownDescription": "Enables the remove_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_app_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-set-app-theme",
                    "markdownDescription": "Enables the set_app_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_dock_visibility command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-set-dock-visibility",
                    "markdownDescription": "Enables the set_dock_visibility command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the tauri_version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-tauri-version",
                    "markdownDescription": "Enables the tauri_version command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-version",
                    "markdownDescription": "Enables the version command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the app_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-app-hide",
                    "markdownDescription": "Denies the app_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the app_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-app-show",
                    "markdownDescription": "Denies the app_show command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the bundle_type command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-bundle-type",
                    "markdownDescription": "Denies the bundle_type command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the default_window_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-default-window-icon",
                    "markdownDescription": "Denies the default_window_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the fetch_data_store_identifiers command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-fetch-data-store-identifiers",
                    "markdownDescription": "Denies the fetch_data_store_identifiers command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the identifier command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-identifier",
                    "markdownDescription": "Denies the identifier command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the name command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-name",
                    "markdownDescription": "Denies the name command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the register_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-register-listener",
                    "markdownDescription": "Denies the register_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_data_store command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-remove-data-store",
                    "markdownDescription": "Denies the remove_data_store command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-remove-listener",
                    "markdownDescription": "Denies the remove_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_app_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-set-app-theme",
                    "markdownDescription": "Denies the set_app_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_dock_visibility command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-set-dock-visibility",
                    "markdownDescription": "Denies the set_dock_visibility command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the tauri_version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-tauri-version",
                    "markdownDescription": "Denies the tauri_version command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-version",
                    "markdownDescription": "Denies the version command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-listen`\n- `allow-unlisten`\n- `allow-emit`\n- `allow-emit-to`",
                    "type": "string",
                    "const": "core:event:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-listen`\n- `allow-unlisten`\n- `allow-emit`\n- `allow-emit-to`"
                  },
                  {
                    "description": "Enables the emit command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-emit",
                    "markdownDescription": "Enables the emit command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the emit_to command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-emit-to",
                    "markdownDescription": "Enables the emit_to command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the listen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-listen",
                    "markdownDescription": "Enables the listen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the unlisten command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-unlisten",
                    "markdownDescription": "Enables the unlisten command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the emit command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-emit",
                    "markdownDescription": "Denies the emit command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the emit_to command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-emit-to",
                    "markdownDescription": "Denies the emit_to command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the listen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-listen",
                    "markdownDescription": "Denies the listen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the unlisten command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-unlisten",
                    "markdownDescription": "Denies the unlisten command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-from-bytes`\n- `allow-from-path`\n- `allow-rgba`\n- `allow-size`",
                    "type": "string",
                    "const": "core:image:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-from-bytes`\n- `allow-from-path`\n- `allow-rgba`\n- `allow-size`"
                  },
                  {
                    "description": "Enables the from_bytes command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-from-bytes",
                    "markdownDescription": "Enables the from_bytes command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the from_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-from-path",
                    "markdownDescription": "Enables the from_path command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-new",
                    "markdownDescription": "Enables the new command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the rgba command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-rgba",
                    "markdownDescription": "Enables the rgba command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-size",
                    "markdownDescription": "Enables the size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the from_bytes command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-from-bytes",
                    "markdownDescription": "Denies the from_bytes command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the from_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-from-path",
                    "markdownDescription": "Denies the from_path command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-new",
                    "markdownDescription": "Denies the new command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the rgba command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-rgba",
                    "markdownDescription": "Denies the rgba command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-size",
                    "markdownDescription": "Denies the size command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-append`\n- `allow-prepend`\n- `allow-insert`\n- `allow-remove`\n- `allow-remove-at`\n- `allow-items`\n- `allow-get`\n- `allow-popup`\n- `allow-create-default`\n- `allow-set-as-app-menu`\n- `allow-set-as-window-menu`\n- `allow-text`\n- `allow-set-text`\n- `allow-is-enabled`\n- `allow-set-enabled`\n- `allow-set-accelerator`\n- `allow-set-as-windows-menu-for-nsapp`\n- `allow-set-as-help-menu-for-nsapp`\n- `allow-is-checked`\n- `allow-set-checked`\n- `allow-set-icon`",
                    "type": "string",
                    "const": "core:menu:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-append`\n- `allow-prepend`\n- `allow-insert`\n- `allow-remove`\n- `allow-remove-at`\n- `allow-items`\n- `allow-get`\n- `allow-popup`\n- `allow-create-default`\n- `allow-set-as-app-menu`\n- `allow-set-as-window-menu`\n- `allow-text`\n- `allow-set-text`\n- `allow-is-enabled`\n- `allow-set-enabled`\n- `allow-set-accelerator`\n- `allow-set-as-windows-menu-for-nsapp`\n- `allow-set-as-help-menu-for-nsapp`\n- `allow-is-checked`\n- `allow-set-checked`\n- `allow-set-icon`"
                  },
                  {
                    "description": "Enables the append command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-append",
                    "markdownDescription": "Enables the append command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create_default command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-create-default",
                    "markdownDescription": "Enables the create_default command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the get command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-get",
                    "markdownDescription": "Enables the get command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the insert command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-insert",
                    "markdownDescription": "Enables the insert command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-is-checked",
                    "markdownDescription": "Enables the is_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-is-enabled",
                    "markdownDescription": "Enables the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the items command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-items",
                    "markdownDescription": "Enables the items command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-new",
                    "markdownDescription": "Enables the new command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the popup command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-popup",
                    "markdownDescription": "Enables the popup command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the prepend command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-prepend",
                    "markdownDescription": "Enables the prepend command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-remove",
                    "markdownDescription": "Enables the remove command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_at command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-remove-at",
                    "markdownDescription": "Enables the remove_at command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_accelerator command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-accelerator",
                    "markdownDescription": "Enables the set_accelerator command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_app_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-app-menu",
                    "markdownDescription": "Enables the set_as_app_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_help_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-help-menu-for-nsapp",
                    "markdownDescription": "Enables the set_as_help_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_window_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-window-menu",
                    "markdownDescription": "Enables the set_as_window_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_windows_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-windows-menu-for-nsapp",
                    "markdownDescription": "Enables the set_as_windows_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-checked",
                    "markdownDescription": "Enables the set_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-enabled",
                    "markdownDescription": "Enables the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-icon",
                    "markdownDescription": "Enables the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-text",
                    "markdownDescription": "Enables the set_text command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-text",
                    "markdownDescription": "Enables the text command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the append command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-append",
                    "markdownDescription": "Denies the append command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create_default command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-create-default",
                    "markdownDescription": "Denies the create_default command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-get",
                    "markdownDescription": "Denies the get command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the insert command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-insert",
                    "markdownDescription": "Denies the insert command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-is-checked",
                    "markdownDescription": "Denies the is_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-is-enabled",
                    "markdownDescription": "Denies the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the items command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-items",
                    "markdownDescription": "Denies the items command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-new",
                    "markdownDescription": "Denies the new command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the popup command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-popup",
                    "markdownDescription": "Denies the popup command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the prepend command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-prepend",
                    "markdownDescription": "Denies the prepend command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-remove",
                    "markdownDescription": "Denies the remove command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_at command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-remove-at",
                    "markdownDescription": "Denies the remove_at command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_accelerator command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-accelerator",
                    "markdownDescription": "Denies the set_accelerator command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_app_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-app-menu",
                    "markdownDescription": "Denies the set_as_app_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_help_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-help-menu-for-nsapp",
                    "markdownDescription": "Denies the set_as_help_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_window_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-window-menu",
                    "markdownDescription": "Denies the set_as_window_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_windows_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-windows-menu-for-nsapp",
                    "markdownDescription": "Denies the set_as_windows_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-checked",
                    "markdownDescription": "Denies the set_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-enabled",
                    "markdownDescription": "Denies the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-icon",
                    "markdownDescription": "Denies the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-text",
                    "markdownDescription": "Denies the set_text command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-text",
                    "markdownDescription": "Denies the text command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-resolve-directory`\n- `allow-resolve`\n- `allow-normalize`\n- `allow-join`\n- `allow-dirname`\n- `allow-extname`\n- `allow-basename`\n- `allow-is-absolute`",
                    "type": "string",
                    "const": "core:path:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-resolve-directory`\n- `allow-resolve`\n- `allow-normalize`\n- `allow-join`\n- `allow-dirname`\n- `allow-extname`\n- `allow-basename`\n- `allow-is-absolute`"
                  },
                  {
                    "description": "Enables the basename command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-basename",
                    "markdownDescription": "Enables the basename command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the dirname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-dirname",
                    "markdownDescription": "Enables the dirname command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the extname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-extname",
                    "markdownDescription": "Enables the extname command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_absolute command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-is-absolute",
                    "markdownDescription": "Enables the is_absolute command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the join command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-join",
                    "markdownDescription": "Enables the join command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the normalize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-normalize",
                    "markdownDescription": "Enables the normalize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the resolve command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-resolve",
                    "markdownDescription": "Enables the resolve command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the resolve_directory command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-resolve-directory",
                    "markdownDescription": "Enables the resolve_directory command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the basename command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-basename",
                    "markdownDescription": "Denies the basename command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the dirname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-dirname",
                    "markdownDescription": "Denies the dirname command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the extname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-extname",
                    "markdownDescription": "Denies the extname command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_absolute command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-is-absolute",
                    "markdownDescription": "Denies the is_absolute command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the join command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-join",
                    "markdownDescription": "Denies the join command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the normalize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-normalize",
                    "markdownDescription": "Denies the normalize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the resolve command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-resolve",
                    "markdownDescription": "Denies the resolve command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the resolve_directory command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-resolve-directory",
                    "markdownDescription": "Denies the resolve_directory command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-close`",
                    "type": "string",
                    "const": "core:resources:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-close`"
                  },
                  {
                    "description": "Enables the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:resources:allow-close",
                    "markdownDescription": "Enables the close command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:resources:deny-close",
                    "markdownDescription": "Denies the close command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-get-by-id`\n- `allow-remove-by-id`\n- `allow-set-icon`\n- `allow-set-menu`\n- `allow-set-tooltip`\n- `allow-set-title`\n- `allow-set-visible`\n- `allow-set-temp-dir-path`\n- `allow-set-icon-as-template`\n- `allow-set-show-menu-on-left-click`",
                    "type": "string",
                    "const": "core:tray:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-get-by-id`\n- `allow-remove-by-id`\n- `allow-set-icon`\n- `allow-set-menu`\n- `allow-set-tooltip`\n- `allow-set-title`\n- `allow-set-visible`\n- `allow-set-temp-dir-path`\n- `allow-set-icon-as-template`\n- `allow-set-show-menu-on-left-click`"
                  },
                  {
                    "description": "Enables the get_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-get-by-id",
                    "markdownDescription": "Enables the get_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-new",
                    "markdownDescription": "Enables the new command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-remove-by-id",
                    "markdownDescription": "Enables the remove_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-icon",
                    "markdownDescription": "Enables the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon_as_template command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-icon-as-template",
                    "markdownDescription": "Enables the set_icon_as_template command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-menu",
                    "markdownDescription": "Enables the set_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_show_menu_on_left_click command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-show-menu-on-left-click",
                    "markdownDescription": "Enables the set_show_menu_on_left_click command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_temp_dir_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-temp-dir-path",
                    "markdownDescription": "Enables the set_temp_dir_path command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-title",
                    "markdownDescription": "Enables the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_tooltip command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-tooltip",
                    "markdownDescription": "Enables the set_tooltip command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-visible",
                    "markdownDescription": "Enables the set_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-get-by-id",
                    "markdownDescription": "Denies the get_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-new",
                    "markdownDescription": "Denies the new command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-remove-by-id",
                    "markdownDescription": "Denies the remove_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-icon",
                    "markdownDescription": "Denies the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon_as_template command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-icon-as-template",
                    "markdownDescription": "Denies the set_icon_as_template command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-menu",
                    "markdownDescription": "Denies the set_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_show_menu_on_left_click command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-show-menu-on-left-click",
                    "markdownDescription": "Denies the set_show_menu_on_left_click command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_temp_dir_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-temp-dir-path",
                    "markdownDescription": "Denies the set_temp_dir_path command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-title",
                    "markdownDescription": "Denies the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_tooltip command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-tooltip",
                    "markdownDescription": "Denies the set_tooltip command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-visible",
                    "markdownDescription": "Denies the set_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-webviews`\n- `allow-webview-position`\n- `allow-webview-size`\n- `allow-internal-toggle-devtools`",
                    "type": "string",
                    "const": "core:webview:default",
                    "markdownDescription": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-webviews`\n- `allow-webview-position`\n- `allow-webview-size`\n- `allow-internal-toggle-devtools`"
                  },
                  {
                    "description": "Enables the clear_all_browsing_data command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-clear-all-browsing-data",
                    "markdownDescription": "Enables the clear_all_browsing_data command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create_webview command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-create-webview",
                    "markdownDescription": "Enables the create_webview command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create_webview_window command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-create-webview-window",
                    "markdownDescription": "Enables the create_webview_window command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the get_all_webviews command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-get-all-webviews",
                    "markdownDescription": "Enables the get_all_webviews command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the internal_toggle_devtools command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-internal-toggle-devtools",
                    "markdownDescription": "Enables the internal_toggle_devtools command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the print command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-print",
                    "markdownDescription": "Enables the print command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the reparent command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-reparent",
                    "markdownDescription": "Enables the reparent command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_auto_resize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-auto-resize",
                    "markdownDescription": "Enables the set_webview_auto_resize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-background-color",
                    "markdownDescription": "Enables the set_webview_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-focus",
                    "markdownDescription": "Enables the set_webview_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-position",
                    "markdownDescription": "Enables the set_webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-size",
                    "markdownDescription": "Enables the set_webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_zoom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-zoom",
                    "markdownDescription": "Enables the set_webview_zoom command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-close",
                    "markdownDescription": "Enables the webview_close command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-hide",
                    "markdownDescription": "Enables the webview_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-position",
                    "markdownDescription": "Enables the webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-show",
                    "markdownDescription": "Enables the webview_show command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-size",
                    "markdownDescription": "Enables the webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the clear_all_browsing_data command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-clear-all-browsing-data",
                    "markdownDescription": "Denies the clear_all_browsing_data command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create_webview command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-create-webview",
                    "markdownDescription": "Denies the create_webview command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create_webview_window command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-create-webview-window",
                    "markdownDescription": "Denies the create_webview_window command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get_all_webviews command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-get-all-webviews",
                    "markdownDescription": "Denies the get_all_webviews command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the internal_toggle_devtools command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-internal-toggle-devtools",
                    "markdownDescription": "Denies the internal_toggle_devtools command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the print command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-print",
                    "markdownDescription": "Denies the print command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the reparent command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-reparent",
                    "markdownDescription": "Denies the reparent command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_auto_resize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-auto-resize",
                    "markdownDescription": "Denies the set_webview_auto_resize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-background-color",
                    "markdownDescription": "Denies the set_webview_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-focus",
                    "markdownDescription": "Denies the set_webview_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-position",
                    "markdownDescription": "Denies the set_webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-size",
                    "markdownDescription": "Denies the set_webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_zoom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-zoom",
                    "markdownDescription": "Denies the set_webview_zoom command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-close",
                    "markdownDescription": "Denies the webview_close command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-hide",
                    "markdownDescription": "Denies the webview_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-position",
                    "markdownDescription": "Denies the webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-show",
                    "markdownDescription": "Denies the webview_show command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-size",
                    "markdownDescription": "Denies the webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-windows`\n- `allow-scale-factor`\n- `allow-inner-position`\n- `allow-outer-position`\n- `allow-inner-size`\n- `allow-outer-size`\n- `allow-is-fullscreen`\n- `allow-is-minimized`\n- `allow-is-maximized`\n- `allow-is-focused`\n- `allow-is-decorated`\n- `allow-is-resizable`\n- `allow-is-maximizable`\n- `allow-is-minimizable`\n- `allow-is-closable`\n- `allow-is-visible`\n- `allow-is-enabled`\n- `allow-title`\n- `allow-current-monitor`\n- `allow-primary-monitor`\n- `allow-monitor-from-point`\n- `allow-available-monitors`\n- `allow-cursor-position`\n- `allow-theme`\n- `allow-is-always-on-top`\n- `allow-internal-toggle-maximize`",
                    "type": "string",
                    "const": "core:window:default",
                    "markdownDescription": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-windows`\n- `allow-scale-factor`\n- `allow-inner-position`\n- `allow-outer-position`\n- `allow-inner-size`\n- `allow-outer-size`\n- `allow-is-fullscreen`\n- `allow-is-minimized`\n- `allow-is-maximized`\n- `allow-is-focused`\n- `allow-is-decorated`\n- `allow-is-resizable`\n- `allow-is-maximizable`\n- `allow-is-minimizable`\n- `allow-is-closable`\n- `allow-is-visible`\n- `allow-is-enabled`\n- `allow-title`\n- `allow-current-monitor`\n- `allow-primary-monitor`\n- `allow-monitor-from-point`\n- `allow-available-monitors`\n- `allow-cursor-position`\n- `allow-theme`\n- `allow-is-always-on-top`\n- `allow-internal-toggle-maximize`"
                  },
                  {
                    "description": "Enables the available_monitors command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-available-monitors",
                    "markdownDescription": "Enables the available_monitors command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the center command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-center",
                    "markdownDescription": "Enables the center command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-close",
                    "markdownDescription": "Enables the close command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-create",
                    "markdownDescription": "Enables the create command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the current_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-current-monitor",
                    "markdownDescription": "Enables the current_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-cursor-position",
                    "markdownDescription": "Enables the cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the destroy command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-destroy",
                    "markdownDescription": "Enables the destroy command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the get_all_windows command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-get-all-windows",
                    "markdownDescription": "Enables the get_all_windows command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-hide",
                    "markdownDescription": "Enables the hide command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the inner_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-inner-position",
                    "markdownDescription": "Enables the inner_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the inner_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-inner-size",
                    "markdownDescription": "Enables the inner_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the internal_toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-internal-toggle-maximize",
                    "markdownDescription": "Enables the internal_toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-always-on-top",
                    "markdownDescription": "Enables the is_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-closable",
                    "markdownDescription": "Enables the is_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_decorated command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-decorated",
                    "markdownDescription": "Enables the is_decorated command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-enabled",
                    "markdownDescription": "Enables the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_focused command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-focused",
                    "markdownDescription": "Enables the is_focused command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-fullscreen",
                    "markdownDescription": "Enables the is_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-maximizable",
                    "markdownDescription": "Enables the is_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_maximized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-maximized",
                    "markdownDescription": "Enables the is_maximized command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-minimizable",
                    "markdownDescription": "Enables the is_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_minimized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-minimized",
                    "markdownDescription": "Enables the is_minimized command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-resizable",
                    "markdownDescription": "Enables the is_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-visible",
                    "markdownDescription": "Enables the is_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-maximize",
                    "markdownDescription": "Enables the maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the minimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-minimize",
                    "markdownDescription": "Enables the minimize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the monitor_from_point command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-monitor-from-point",
                    "markdownDescription": "Enables the monitor_from_point command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the outer_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-outer-position",
                    "markdownDescription": "Enables the outer_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the outer_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-outer-size",
                    "markdownDescription": "Enables the outer_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the primary_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-primary-monitor",
                    "markdownDescription": "Enables the primary_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the request_user_attention command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-request-user-attention",
                    "markdownDescription": "Enables the request_user_attention command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the scale_factor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-scale-factor",
                    "markdownDescription": "Enables the scale_factor command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_always_on_bottom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-always-on-bottom",
                    "markdownDescription": "Enables the set_always_on_bottom command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-always-on-top",
                    "markdownDescription": "Enables the set_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-background-color",
                    "markdownDescription": "Enables the set_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_badge_count command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-badge-count",
                    "markdownDescription": "Enables the set_badge_count command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_badge_label command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-badge-label",
                    "markdownDescription": "Enables the set_badge_label command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-closable",
                    "markdownDescription": "Enables the set_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_content_protected command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-content-protected",
                    "markdownDescription": "Enables the set_content_protected command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_grab command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-grab",
                    "markdownDescription": "Enables the set_cursor_grab command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-icon",
                    "markdownDescription": "Enables the set_cursor_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-position",
                    "markdownDescription": "Enables the set_cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-visible",
                    "markdownDescription": "Enables the set_cursor_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_decorations command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-decorations",
                    "markdownDescription": "Enables the set_decorations command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_effects command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-effects",
                    "markdownDescription": "Enables the set_effects command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-enabled",
                    "markdownDescription": "Enables the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-focus",
                    "markdownDescription": "Enables the set_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_focusable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-focusable",
                    "markdownDescription": "Enables the set_focusable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-fullscreen",
                    "markdownDescription": "Enables the set_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-icon",
                    "markdownDescription": "Enables the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_ignore_cursor_events command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-ignore-cursor-events",
                    "markdownDescription": "Enables the set_ignore_cursor_events command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_max_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-max-size",
                    "markdownDescription": "Enables the set_max_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-maximizable",
                    "markdownDescription": "Enables the set_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_min_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-min-size",
                    "markdownDescription": "Enables the set_min_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-minimizable",
                    "markdownDescription": "Enables the set_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_overlay_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-overlay-icon",
                    "markdownDescription": "Enables the set_overlay_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-position",
                    "markdownDescription": "Enables the set_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_progress_bar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-progress-bar",
                    "markdownDescription": "Enables the set_progress_bar command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-resizable",
                    "markdownDescription": "Enables the set_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_shadow command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-shadow",
                    "markdownDescription": "Enables the set_shadow command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_simple_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-simple-fullscreen",
                    "markdownDescription": "Enables the set_simple_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-size",
                    "markdownDescription": "Enables the set_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_size_constraints command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-size-constraints",
                    "markdownDescription": "Enables the set_size_constraints command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_skip_taskbar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-skip-taskbar",
                    "markdownDescription": "Enables the set_skip_taskbar command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-theme",
                    "markdownDescription": "Enables the set_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-title",
                    "markdownDescription": "Enables the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_title_bar_style command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-title-bar-style",
                    "markdownDescription": "Enables the set_title_bar_style command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_visible_on_all_workspaces command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-visible-on-all-workspaces",
                    "markdownDescription": "Enables the set_visible_on_all_workspaces command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-show",
                    "markdownDescription": "Enables the show command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the start_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-start-dragging",
                    "markdownDescription": "Enables the start_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the start_resize_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-start-resize-dragging",
                    "markdownDescription": "Enables the start_resize_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-theme",
                    "markdownDescription": "Enables the theme command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-title",
                    "markdownDescription": "Enables the title command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-toggle-maximize",
                    "markdownDescription": "Enables the toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the unmaximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-unmaximize",
                    "markdownDescription": "Enables the unmaximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the unminimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-unminimize",
                    "markdownDescription": "Enables the unminimize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the available_monitors command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-available-monitors",
                    "markdownDescription": "Denies the available_monitors command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the center command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-center",
                    "markdownDescription": "Denies the center command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-close",
                    "markdownDescription": "Denies the close command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-create",
                    "markdownDescription": "Denies the create command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the current_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-current-monitor",
                    "markdownDescription": "Denies the current_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-cursor-position",
                    "markdownDescription": "Denies the cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the destroy command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-destroy",
                    "markdownDescription": "Denies the destroy command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get_all_windows command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-get-all-windows",
                    "markdownDescription": "Denies the get_all_windows command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-hide",
                    "markdownDescription": "Denies the hide command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the inner_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-inner-position",
                    "markdownDescription": "Denies the inner_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the inner_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-inner-size",
                    "markdownDescription": "Denies the inner_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the internal_toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-internal-toggle-maximize",
                    "markdownDescription": "Denies the internal_toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-always-on-top",
                    "markdownDescription": "Denies the is_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-closable",
                    "markdownDescription": "Denies the is_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_decorated command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-decorated",
                    "markdownDescription": "Denies the is_decorated command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-enabled",
                    "markdownDescription": "Denies the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_focused command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-focused",
                    "markdownDescription": "Denies the is_focused command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-fullscreen",
                    "markdownDescription": "Denies the is_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-maximizable",
                    "markdownDescription": "Denies the is_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_maximized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-maximized",
                    "markdownDescription": "Denies the is_maximized command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-minimizable",
                    "markdownDescription": "Denies the is_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_minimized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-minimized",
                    "markdownDescription": "Denies the is_minimized command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-resizable",
                    "markdownDescription": "Denies the is_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-visible",
                    "markdownDescription": "Denies the is_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-maximize",
                    "markdownDescription": "Denies the maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the minimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-minimize",
                    "markdownDescription": "Denies the minimize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the monitor_from_point command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-monitor-from-point",
                    "markdownDescription": "Denies the monitor_from_point command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the outer_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-outer-position",
                    "markdownDescription": "Denies the outer_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the outer_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-outer-size",
                    "markdownDescription": "Denies the outer_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the primary_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-primary-monitor",
                    "markdownDescription": "Denies the primary_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the request_user_attention command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-request-user-attention",
                    "markdownDescription": "Denies the request_user_attention command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the scale_factor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-scale-factor",
                    "markdownDescription": "Denies the scale_factor command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_always_on_bottom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-always-on-bottom",
                    "markdownDescription": "Denies the set_always_on_bottom command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-always-on-top",
                    "markdownDescription": "Denies the set_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-background-color",
                    "markdownDescription": "Denies the set_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_badge_count command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-badge-count",
                    "markdownDescription": "Denies the set_badge_count command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_badge_label command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-badge-label",
                    "markdownDescription": "Denies the set_badge_label command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-closable",
                    "markdownDescription": "Denies the set_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_content_protected command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-content-protected",
                    "markdownDescription": "Denies the set_content_protected command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_grab command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-grab",
                    "markdownDescription": "Denies the set_cursor_grab command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-icon",
                    "markdownDescription": "Denies the set_cursor_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-position",
                    "markdownDescription": "Denies the set_cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-visible",
                    "markdownDescription": "Denies the set_cursor_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_decorations command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-decorations",
                    "markdownDescription": "Denies the set_decorations command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_effects command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-effects",
                    "markdownDescription": "Denies the set_effects command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-enabled",
                    "markdownDescription": "Denies the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-focus",
                    "markdownDescription": "Denies the set_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_focusable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-focusable",
                    "markdownDescription": "Denies the set_focusable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-fullscreen",
                    "markdownDescription": "Denies the set_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-icon",
                    "markdownDescription": "Denies the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_ignore_cursor_events command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-ignore-cursor-events",
                    "markdownDescription": "Denies the set_ignore_cursor_events command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_max_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-max-size",
                    "markdownDescription": "Denies the set_max_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-maximizable",
                    "markdownDescription": "Denies the set_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_min_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-min-size",
                    "markdownDescription": "Denies the set_min_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-minimizable",
                    "markdownDescription": "Denies the set_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_overlay_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-overlay-icon",
                    "markdownDescription": "Denies the set_overlay_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-position",
                    "markdownDescription": "Denies the set_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_progress_bar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-progress-bar",
                    "markdownDescription": "Denies the set_progress_bar command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-resizable",
                    "markdownDescription": "Denies the set_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_shadow command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-shadow",
                    "markdownDescription": "Denies the set_shadow command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_simple_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-simple-fullscreen",
                    "markdownDescription": "Denies the set_simple_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-size",
                    "markdownDescription": "Denies the set_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_size_constraints command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-size-constraints",
                    "markdownDescription": "Denies the set_size_constraints command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_skip_taskbar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-skip-taskbar",
                    "markdownDescription": "Denies the set_skip_taskbar command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-theme",
                    "markdownDescription": "Denies the set_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-title",
                    "markdownDescription": "Denies the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_title_bar_style command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-title-bar-style",
                    "markdownDescription": "Denies the set_title_bar_style command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_visible_on_all_workspaces command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-visible-on-all-workspaces",
                    "markdownDescription": "Denies the set_visible_on_all_workspaces command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-show",
                    "markdownDescription": "Denies the show command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the start_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-start-dragging",
                    "markdownDescription": "Denies the start_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the start_resize_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-start-resize-dragging",
                    "markdownDescription": "Denies the start_resize_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-theme",
                    "markdownDescription": "Denies the theme command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-title",
                    "markdownDescription": "Denies the title command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-toggle-maximize",
                    "markdownDescription": "Denies the toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the unmaximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-unmaximize",
                    "markdownDescription": "Denies the unmaximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the unminimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-unminimize",
                    "markdownDescription": "Denies the unminimize command without any pre-configured scope."
                  },
                  {
                    "description": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`",
                    "type": "string",
                    "const": "opener:default",
                    "markdownDescription": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`"
                  },
                  {
                    "description": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application.",
                    "type": "string",
                    "const": "opener:allow-default-urls",
                    "markdownDescription": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application."
                  },
                  {
                    "description": "Enables the open_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:allow-open-path",
                    "markdownDescription": "Enables the open_path command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the open_url command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:allow-open-url",
                    "markdownDescription": "Enables the open_url command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the reveal_item_in_dir command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:allow-reveal-item-in-dir",
                    "markdownDescription": "Enables the reveal_item_in_dir command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the open_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:deny-open-path",
                    "markdownDescription": "Denies the open_path command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the open_url command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:deny-open-url",
                    "markdownDescription": "Denies the open_url command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the reveal_item_in_dir command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:deny-reveal-item-in-dir",
                    "markdownDescription": "Denies the reveal_item_in_dir command without any pre-configured scope."
                  }
                ]
              },
              "Value": {
                "description": "All supported ACL values.",
                "anyOf": [
                  {
                    "description": "Represents a null JSON value.",
                    "type": "null"
                  },
                  {
                    "description": "Represents a [`bool`].",
                    "type": "boolean"
                  },
                  {
                    "description": "Represents a valid ACL [`Number`].",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Number"
                      }
                    ]
                  },
                  {
                    "description": "Represents a [`String`].",
                    "type": "string"
                  },
                  {
                    "description": "Represents a list of other [`Value`]s.",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Value"
                    }
                  },
                  {
                    "description": "Represents a map of [`String`] keys to [`Value`]s.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/definitions/Value"
                    }
                  }
                ]
              },
              "Number": {
                "description": "A valid ACL number.",
                "anyOf": [
                  {
                    "description": "Represents an [`i64`].",
                    "type": "integer",
                    "format": "int64"
                  },
                  {
                    "description": "Represents a [`f64`].",
                    "type": "number",
                    "format": "double"
                  }
                ]
              },
              "Target": {
                "description": "Platform target.",
                "oneOf": [
                  {
                    "description": "MacOS.",
                    "type": "string",
                    "enum": [
                      "macOS"
                    ]
                  },
                  {
                    "description": "Windows.",
                    "type": "string",
                    "enum": [
                      "windows"
                    ]
                  },
                  {
                    "description": "Linux.",
                    "type": "string",
                    "enum": [
                      "linux"
                    ]
                  },
                  {
                    "description": "Android.",
                    "type": "string",
                    "enum": [
                      "android"
                    ]
                  },
                  {
                    "description": "iOS.",
                    "type": "string",
                    "enum": [
                      "iOS"
                    ]
                  }
                ]
              },
              "Application": {
                "description": "Opener scope application.",
                "anyOf": [
                  {
                    "description": "Open in default application.",
                    "type": "null"
                  },
                  {
                    "description": "If true, allow open with any application.",
                    "type": "boolean"
                  },
                  {
                    "description": "Allow specific application to open with.",
                    "type": "string"
                  }
                ]
              }
            }
          }
          ```

        - ğŸ“„ **windows-schema.json**

          ğŸ“„ *File Path*: `.\src-tauri\gen\schemas\windows-schema.json`
          *Size*: 126319 bytes | *Modified*: 2026-01-16 17:26:01

          ```
          {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "title": "CapabilityFile",
            "description": "Capability formats accepted in a capability file.",
            "anyOf": [
              {
                "description": "A single capability.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Capability"
                  }
                ]
              },
              {
                "description": "A list of capabilities.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Capability"
                }
              },
              {
                "description": "A list of capabilities.",
                "type": "object",
                "required": [
                  "capabilities"
                ],
                "properties": {
                  "capabilities": {
                    "description": "The list of capabilities.",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Capability"
                    }
                  }
                }
              }
            ],
            "definitions": {
              "Capability": {
                "description": "A grouping and boundary mechanism developers can use to isolate access to the IPC layer.\n\nIt controls application windows' and webviews' fine grained access to the Tauri core, application, or plugin commands. If a webview or its window is not matching any capability then it has no access to the IPC layer at all.\n\nThis can be done to create groups of windows, based on their required system access, which can reduce impact of frontend vulnerabilities in less privileged windows. Windows can be added to a capability by exact name (e.g. `main-window`) or glob patterns like `*` or `admin-*`. A Window can have none, one, or multiple associated capabilities.\n\n## Example\n\n```json { \"identifier\": \"main-user-files-write\", \"description\": \"This capability allows the `main` window on macOS and Windows access to `filesystem` write related commands and `dialog` commands to enable programmatic access to files selected by the user.\", \"windows\": [ \"main\" ], \"permissions\": [ \"core:default\", \"dialog:open\", { \"identifier\": \"fs:allow-write-text-file\", \"allow\": [{ \"path\": \"$HOME/test.txt\" }] }, ], \"platforms\": [\"macOS\",\"windows\"] } ```",
                "type": "object",
                "required": [
                  "identifier",
                  "permissions"
                ],
                "properties": {
                  "identifier": {
                    "description": "Identifier of the capability.\n\n## Example\n\n`main-user-files-write`",
                    "type": "string"
                  },
                  "description": {
                    "description": "Description of what the capability is intended to allow on associated windows.\n\nIt should contain a description of what the grouped permissions should allow.\n\n## Example\n\nThis capability allows the `main` window access to `filesystem` write related commands and `dialog` commands to enable programmatic access to files selected by the user.",
                    "default": "",
                    "type": "string"
                  },
                  "remote": {
                    "description": "Configure remote URLs that can use the capability permissions.\n\nThis setting is optional and defaults to not being set, as our default use case is that the content is served from our local application.\n\n:::caution Make sure you understand the security implications of providing remote sources with local system access. :::\n\n## Example\n\n```json { \"urls\": [\"https://*.mydomain.dev\"] } ```",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/CapabilityRemote"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "local": {
                    "description": "Whether this capability is enabled for local app URLs or not. Defaults to `true`.",
                    "default": true,
                    "type": "boolean"
                  },
                  "windows": {
                    "description": "List of windows that are affected by this capability. Can be a glob pattern.\n\nIf a window label matches any of the patterns in this list, the capability will be enabled on all the webviews of that window, regardless of the value of [`Self::webviews`].\n\nOn multiwebview windows, prefer specifying [`Self::webviews`] and omitting [`Self::windows`] for a fine grained access control.\n\n## Example\n\n`[\"main\"]`",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "webviews": {
                    "description": "List of webviews that are affected by this capability. Can be a glob pattern.\n\nThe capability will be enabled on all the webviews whose label matches any of the patterns in this list, regardless of whether the webview's window label matches a pattern in [`Self::windows`].\n\n## Example\n\n`[\"sub-webview-one\", \"sub-webview-two\"]`",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "permissions": {
                    "description": "List of permissions attached to this capability.\n\nMust include the plugin name as prefix in the form of `${plugin-name}:${permission-name}`. For commands directly implemented in the application itself only `${permission-name}` is required.\n\n## Example\n\n```json [ \"core:default\", \"shell:allow-open\", \"dialog:open\", { \"identifier\": \"fs:allow-write-text-file\", \"allow\": [{ \"path\": \"$HOME/test.txt\" }] } ] ```",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/PermissionEntry"
                    },
                    "uniqueItems": true
                  },
                  "platforms": {
                    "description": "Limit which target platforms this capability applies to.\n\nBy default all platforms are targeted.\n\n## Example\n\n`[\"macOS\",\"windows\"]`",
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "$ref": "#/definitions/Target"
                    }
                  }
                }
              },
              "CapabilityRemote": {
                "description": "Configuration for remote URLs that are associated with the capability.",
                "type": "object",
                "required": [
                  "urls"
                ],
                "properties": {
                  "urls": {
                    "description": "Remote domains this capability refers to using the [URLPattern standard](https://urlpattern.spec.whatwg.org/).\n\n## Examples\n\n- \"https://*.mydomain.dev\": allows subdomains of mydomain.dev - \"https://mydomain.dev/api/*\": allows any subpath of mydomain.dev/api",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              },
              "PermissionEntry": {
                "description": "An entry for a permission value in a [`Capability`] can be either a raw permission [`Identifier`] or an object that references a permission and extends its scope.",
                "anyOf": [
                  {
                    "description": "Reference a permission or permission set by identifier.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Identifier"
                      }
                    ]
                  },
                  {
                    "description": "Reference a permission or permission set by identifier and extends its scope.",
                    "type": "object",
                    "allOf": [
                      {
                        "if": {
                          "properties": {
                            "identifier": {
                              "anyOf": [
                                {
                                  "description": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`",
                                  "type": "string",
                                  "const": "opener:default",
                                  "markdownDescription": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`"
                                },
                                {
                                  "description": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application.",
                                  "type": "string",
                                  "const": "opener:allow-default-urls",
                                  "markdownDescription": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application."
                                },
                                {
                                  "description": "Enables the open_path command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:allow-open-path",
                                  "markdownDescription": "Enables the open_path command without any pre-configured scope."
                                },
                                {
                                  "description": "Enables the open_url command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:allow-open-url",
                                  "markdownDescription": "Enables the open_url command without any pre-configured scope."
                                },
                                {
                                  "description": "Enables the reveal_item_in_dir command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:allow-reveal-item-in-dir",
                                  "markdownDescription": "Enables the reveal_item_in_dir command without any pre-configured scope."
                                },
                                {
                                  "description": "Denies the open_path command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:deny-open-path",
                                  "markdownDescription": "Denies the open_path command without any pre-configured scope."
                                },
                                {
                                  "description": "Denies the open_url command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:deny-open-url",
                                  "markdownDescription": "Denies the open_url command without any pre-configured scope."
                                },
                                {
                                  "description": "Denies the reveal_item_in_dir command without any pre-configured scope.",
                                  "type": "string",
                                  "const": "opener:deny-reveal-item-in-dir",
                                  "markdownDescription": "Denies the reveal_item_in_dir command without any pre-configured scope."
                                }
                              ]
                            }
                          }
                        },
                        "then": {
                          "properties": {
                            "allow": {
                              "items": {
                                "title": "OpenerScopeEntry",
                                "description": "Opener scope entry.",
                                "anyOf": [
                                  {
                                    "type": "object",
                                    "required": [
                                      "url"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this url with, for example: firefox.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "url": {
                                        "description": "A URL that can be opened by the webview when using the Opener APIs.\n\nWildcards can be used following the UNIX glob pattern.\n\nExamples:\n\n- \"https://*\" : allows all HTTPS origin\n\n- \"https://*.github.com/tauri-apps/tauri\": allows any subdomain of \"github.com\" with the \"tauri-apps/api\" path\n\n- \"https://myapi.service.com/users/*\": allows access to any URLs that begins with \"https://myapi.service.com/users/\"",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  {
                                    "type": "object",
                                    "required": [
                                      "path"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this path with, for example: xdg-open.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "path": {
                                        "description": "A path that can be opened by the webview when using the Opener APIs.\n\nThe pattern can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                ]
                              }
                            },
                            "deny": {
                              "items": {
                                "title": "OpenerScopeEntry",
                                "description": "Opener scope entry.",
                                "anyOf": [
                                  {
                                    "type": "object",
                                    "required": [
                                      "url"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this url with, for example: firefox.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "url": {
                                        "description": "A URL that can be opened by the webview when using the Opener APIs.\n\nWildcards can be used following the UNIX glob pattern.\n\nExamples:\n\n- \"https://*\" : allows all HTTPS origin\n\n- \"https://*.github.com/tauri-apps/tauri\": allows any subdomain of \"github.com\" with the \"tauri-apps/api\" path\n\n- \"https://myapi.service.com/users/*\": allows access to any URLs that begins with \"https://myapi.service.com/users/\"",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  {
                                    "type": "object",
                                    "required": [
                                      "path"
                                    ],
                                    "properties": {
                                      "app": {
                                        "description": "An application to open this path with, for example: xdg-open.",
                                        "allOf": [
                                          {
                                            "$ref": "#/definitions/Application"
                                          }
                                        ]
                                      },
                                      "path": {
                                        "description": "A path that can be opened by the webview when using the Opener APIs.\n\nThe pattern can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                ]
                              }
                            }
                          }
                        },
                        "properties": {
                          "identifier": {
                            "description": "Identifier of the permission or permission set.",
                            "allOf": [
                              {
                                "$ref": "#/definitions/Identifier"
                              }
                            ]
                          }
                        }
                      },
                      {
                        "properties": {
                          "identifier": {
                            "description": "Identifier of the permission or permission set.",
                            "allOf": [
                              {
                                "$ref": "#/definitions/Identifier"
                              }
                            ]
                          },
                          "allow": {
                            "description": "Data that defines what is allowed by the scope.",
                            "type": [
                              "array",
                              "null"
                            ],
                            "items": {
                              "$ref": "#/definitions/Value"
                            }
                          },
                          "deny": {
                            "description": "Data that defines what is denied by the scope. This should be prioritized by validation logic.",
                            "type": [
                              "array",
                              "null"
                            ],
                            "items": {
                              "$ref": "#/definitions/Value"
                            }
                          }
                        }
                      }
                    ],
                    "required": [
                      "identifier"
                    ]
                  }
                ]
              },
              "Identifier": {
                "description": "Permission identifier",
                "oneOf": [
                  {
                    "description": "Default core plugins set.\n#### This default permission set includes:\n\n- `core:path:default`\n- `core:event:default`\n- `core:window:default`\n- `core:webview:default`\n- `core:app:default`\n- `core:image:default`\n- `core:resources:default`\n- `core:menu:default`\n- `core:tray:default`",
                    "type": "string",
                    "const": "core:default",
                    "markdownDescription": "Default core plugins set.\n#### This default permission set includes:\n\n- `core:path:default`\n- `core:event:default`\n- `core:window:default`\n- `core:webview:default`\n- `core:app:default`\n- `core:image:default`\n- `core:resources:default`\n- `core:menu:default`\n- `core:tray:default`"
                  },
                  {
                    "description": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-version`\n- `allow-name`\n- `allow-tauri-version`\n- `allow-identifier`\n- `allow-bundle-type`\n- `allow-register-listener`\n- `allow-remove-listener`",
                    "type": "string",
                    "const": "core:app:default",
                    "markdownDescription": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-version`\n- `allow-name`\n- `allow-tauri-version`\n- `allow-identifier`\n- `allow-bundle-type`\n- `allow-register-listener`\n- `allow-remove-listener`"
                  },
                  {
                    "description": "Enables the app_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-app-hide",
                    "markdownDescription": "Enables the app_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the app_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-app-show",
                    "markdownDescription": "Enables the app_show command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the bundle_type command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-bundle-type",
                    "markdownDescription": "Enables the bundle_type command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the default_window_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-default-window-icon",
                    "markdownDescription": "Enables the default_window_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the fetch_data_store_identifiers command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-fetch-data-store-identifiers",
                    "markdownDescription": "Enables the fetch_data_store_identifiers command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the identifier command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-identifier",
                    "markdownDescription": "Enables the identifier command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the name command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-name",
                    "markdownDescription": "Enables the name command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the register_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-register-listener",
                    "markdownDescription": "Enables the register_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_data_store command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-remove-data-store",
                    "markdownDescription": "Enables the remove_data_store command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-remove-listener",
                    "markdownDescription": "Enables the remove_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_app_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-set-app-theme",
                    "markdownDescription": "Enables the set_app_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_dock_visibility command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-set-dock-visibility",
                    "markdownDescription": "Enables the set_dock_visibility command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the tauri_version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-tauri-version",
                    "markdownDescription": "Enables the tauri_version command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:allow-version",
                    "markdownDescription": "Enables the version command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the app_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-app-hide",
                    "markdownDescription": "Denies the app_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the app_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-app-show",
                    "markdownDescription": "Denies the app_show command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the bundle_type command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-bundle-type",
                    "markdownDescription": "Denies the bundle_type command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the default_window_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-default-window-icon",
                    "markdownDescription": "Denies the default_window_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the fetch_data_store_identifiers command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-fetch-data-store-identifiers",
                    "markdownDescription": "Denies the fetch_data_store_identifiers command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the identifier command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-identifier",
                    "markdownDescription": "Denies the identifier command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the name command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-name",
                    "markdownDescription": "Denies the name command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the register_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-register-listener",
                    "markdownDescription": "Denies the register_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_data_store command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-remove-data-store",
                    "markdownDescription": "Denies the remove_data_store command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_listener command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-remove-listener",
                    "markdownDescription": "Denies the remove_listener command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_app_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-set-app-theme",
                    "markdownDescription": "Denies the set_app_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_dock_visibility command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-set-dock-visibility",
                    "markdownDescription": "Denies the set_dock_visibility command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the tauri_version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-tauri-version",
                    "markdownDescription": "Denies the tauri_version command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the version command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:app:deny-version",
                    "markdownDescription": "Denies the version command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-listen`\n- `allow-unlisten`\n- `allow-emit`\n- `allow-emit-to`",
                    "type": "string",
                    "const": "core:event:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-listen`\n- `allow-unlisten`\n- `allow-emit`\n- `allow-emit-to`"
                  },
                  {
                    "description": "Enables the emit command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-emit",
                    "markdownDescription": "Enables the emit command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the emit_to command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-emit-to",
                    "markdownDescription": "Enables the emit_to command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the listen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-listen",
                    "markdownDescription": "Enables the listen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the unlisten command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:allow-unlisten",
                    "markdownDescription": "Enables the unlisten command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the emit command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-emit",
                    "markdownDescription": "Denies the emit command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the emit_to command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-emit-to",
                    "markdownDescription": "Denies the emit_to command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the listen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-listen",
                    "markdownDescription": "Denies the listen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the unlisten command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:event:deny-unlisten",
                    "markdownDescription": "Denies the unlisten command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-from-bytes`\n- `allow-from-path`\n- `allow-rgba`\n- `allow-size`",
                    "type": "string",
                    "const": "core:image:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-from-bytes`\n- `allow-from-path`\n- `allow-rgba`\n- `allow-size`"
                  },
                  {
                    "description": "Enables the from_bytes command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-from-bytes",
                    "markdownDescription": "Enables the from_bytes command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the from_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-from-path",
                    "markdownDescription": "Enables the from_path command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-new",
                    "markdownDescription": "Enables the new command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the rgba command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-rgba",
                    "markdownDescription": "Enables the rgba command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:allow-size",
                    "markdownDescription": "Enables the size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the from_bytes command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-from-bytes",
                    "markdownDescription": "Denies the from_bytes command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the from_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-from-path",
                    "markdownDescription": "Denies the from_path command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-new",
                    "markdownDescription": "Denies the new command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the rgba command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-rgba",
                    "markdownDescription": "Denies the rgba command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:image:deny-size",
                    "markdownDescription": "Denies the size command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-append`\n- `allow-prepend`\n- `allow-insert`\n- `allow-remove`\n- `allow-remove-at`\n- `allow-items`\n- `allow-get`\n- `allow-popup`\n- `allow-create-default`\n- `allow-set-as-app-menu`\n- `allow-set-as-window-menu`\n- `allow-text`\n- `allow-set-text`\n- `allow-is-enabled`\n- `allow-set-enabled`\n- `allow-set-accelerator`\n- `allow-set-as-windows-menu-for-nsapp`\n- `allow-set-as-help-menu-for-nsapp`\n- `allow-is-checked`\n- `allow-set-checked`\n- `allow-set-icon`",
                    "type": "string",
                    "const": "core:menu:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-append`\n- `allow-prepend`\n- `allow-insert`\n- `allow-remove`\n- `allow-remove-at`\n- `allow-items`\n- `allow-get`\n- `allow-popup`\n- `allow-create-default`\n- `allow-set-as-app-menu`\n- `allow-set-as-window-menu`\n- `allow-text`\n- `allow-set-text`\n- `allow-is-enabled`\n- `allow-set-enabled`\n- `allow-set-accelerator`\n- `allow-set-as-windows-menu-for-nsapp`\n- `allow-set-as-help-menu-for-nsapp`\n- `allow-is-checked`\n- `allow-set-checked`\n- `allow-set-icon`"
                  },
                  {
                    "description": "Enables the append command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-append",
                    "markdownDescription": "Enables the append command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create_default command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-create-default",
                    "markdownDescription": "Enables the create_default command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the get command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-get",
                    "markdownDescription": "Enables the get command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the insert command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-insert",
                    "markdownDescription": "Enables the insert command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-is-checked",
                    "markdownDescription": "Enables the is_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-is-enabled",
                    "markdownDescription": "Enables the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the items command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-items",
                    "markdownDescription": "Enables the items command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-new",
                    "markdownDescription": "Enables the new command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the popup command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-popup",
                    "markdownDescription": "Enables the popup command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the prepend command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-prepend",
                    "markdownDescription": "Enables the prepend command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-remove",
                    "markdownDescription": "Enables the remove command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_at command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-remove-at",
                    "markdownDescription": "Enables the remove_at command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_accelerator command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-accelerator",
                    "markdownDescription": "Enables the set_accelerator command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_app_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-app-menu",
                    "markdownDescription": "Enables the set_as_app_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_help_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-help-menu-for-nsapp",
                    "markdownDescription": "Enables the set_as_help_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_window_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-window-menu",
                    "markdownDescription": "Enables the set_as_window_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_as_windows_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-as-windows-menu-for-nsapp",
                    "markdownDescription": "Enables the set_as_windows_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-checked",
                    "markdownDescription": "Enables the set_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-enabled",
                    "markdownDescription": "Enables the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-icon",
                    "markdownDescription": "Enables the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-set-text",
                    "markdownDescription": "Enables the set_text command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:allow-text",
                    "markdownDescription": "Enables the text command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the append command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-append",
                    "markdownDescription": "Denies the append command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create_default command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-create-default",
                    "markdownDescription": "Denies the create_default command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-get",
                    "markdownDescription": "Denies the get command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the insert command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-insert",
                    "markdownDescription": "Denies the insert command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-is-checked",
                    "markdownDescription": "Denies the is_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-is-enabled",
                    "markdownDescription": "Denies the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the items command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-items",
                    "markdownDescription": "Denies the items command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-new",
                    "markdownDescription": "Denies the new command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the popup command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-popup",
                    "markdownDescription": "Denies the popup command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the prepend command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-prepend",
                    "markdownDescription": "Denies the prepend command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-remove",
                    "markdownDescription": "Denies the remove command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_at command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-remove-at",
                    "markdownDescription": "Denies the remove_at command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_accelerator command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-accelerator",
                    "markdownDescription": "Denies the set_accelerator command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_app_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-app-menu",
                    "markdownDescription": "Denies the set_as_app_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_help_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-help-menu-for-nsapp",
                    "markdownDescription": "Denies the set_as_help_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_window_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-window-menu",
                    "markdownDescription": "Denies the set_as_window_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_as_windows_menu_for_nsapp command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-as-windows-menu-for-nsapp",
                    "markdownDescription": "Denies the set_as_windows_menu_for_nsapp command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_checked command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-checked",
                    "markdownDescription": "Denies the set_checked command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-enabled",
                    "markdownDescription": "Denies the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-icon",
                    "markdownDescription": "Denies the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-set-text",
                    "markdownDescription": "Denies the set_text command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the text command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:menu:deny-text",
                    "markdownDescription": "Denies the text command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-resolve-directory`\n- `allow-resolve`\n- `allow-normalize`\n- `allow-join`\n- `allow-dirname`\n- `allow-extname`\n- `allow-basename`\n- `allow-is-absolute`",
                    "type": "string",
                    "const": "core:path:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-resolve-directory`\n- `allow-resolve`\n- `allow-normalize`\n- `allow-join`\n- `allow-dirname`\n- `allow-extname`\n- `allow-basename`\n- `allow-is-absolute`"
                  },
                  {
                    "description": "Enables the basename command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-basename",
                    "markdownDescription": "Enables the basename command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the dirname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-dirname",
                    "markdownDescription": "Enables the dirname command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the extname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-extname",
                    "markdownDescription": "Enables the extname command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_absolute command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-is-absolute",
                    "markdownDescription": "Enables the is_absolute command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the join command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-join",
                    "markdownDescription": "Enables the join command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the normalize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-normalize",
                    "markdownDescription": "Enables the normalize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the resolve command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-resolve",
                    "markdownDescription": "Enables the resolve command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the resolve_directory command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:allow-resolve-directory",
                    "markdownDescription": "Enables the resolve_directory command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the basename command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-basename",
                    "markdownDescription": "Denies the basename command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the dirname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-dirname",
                    "markdownDescription": "Denies the dirname command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the extname command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-extname",
                    "markdownDescription": "Denies the extname command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_absolute command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-is-absolute",
                    "markdownDescription": "Denies the is_absolute command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the join command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-join",
                    "markdownDescription": "Denies the join command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the normalize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-normalize",
                    "markdownDescription": "Denies the normalize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the resolve command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-resolve",
                    "markdownDescription": "Denies the resolve command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the resolve_directory command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:path:deny-resolve-directory",
                    "markdownDescription": "Denies the resolve_directory command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-close`",
                    "type": "string",
                    "const": "core:resources:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-close`"
                  },
                  {
                    "description": "Enables the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:resources:allow-close",
                    "markdownDescription": "Enables the close command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:resources:deny-close",
                    "markdownDescription": "Denies the close command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-get-by-id`\n- `allow-remove-by-id`\n- `allow-set-icon`\n- `allow-set-menu`\n- `allow-set-tooltip`\n- `allow-set-title`\n- `allow-set-visible`\n- `allow-set-temp-dir-path`\n- `allow-set-icon-as-template`\n- `allow-set-show-menu-on-left-click`",
                    "type": "string",
                    "const": "core:tray:default",
                    "markdownDescription": "Default permissions for the plugin, which enables all commands.\n#### This default permission set includes:\n\n- `allow-new`\n- `allow-get-by-id`\n- `allow-remove-by-id`\n- `allow-set-icon`\n- `allow-set-menu`\n- `allow-set-tooltip`\n- `allow-set-title`\n- `allow-set-visible`\n- `allow-set-temp-dir-path`\n- `allow-set-icon-as-template`\n- `allow-set-show-menu-on-left-click`"
                  },
                  {
                    "description": "Enables the get_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-get-by-id",
                    "markdownDescription": "Enables the get_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-new",
                    "markdownDescription": "Enables the new command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the remove_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-remove-by-id",
                    "markdownDescription": "Enables the remove_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-icon",
                    "markdownDescription": "Enables the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon_as_template command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-icon-as-template",
                    "markdownDescription": "Enables the set_icon_as_template command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-menu",
                    "markdownDescription": "Enables the set_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_show_menu_on_left_click command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-show-menu-on-left-click",
                    "markdownDescription": "Enables the set_show_menu_on_left_click command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_temp_dir_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-temp-dir-path",
                    "markdownDescription": "Enables the set_temp_dir_path command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-title",
                    "markdownDescription": "Enables the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_tooltip command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-tooltip",
                    "markdownDescription": "Enables the set_tooltip command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:allow-set-visible",
                    "markdownDescription": "Enables the set_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-get-by-id",
                    "markdownDescription": "Denies the get_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the new command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-new",
                    "markdownDescription": "Denies the new command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the remove_by_id command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-remove-by-id",
                    "markdownDescription": "Denies the remove_by_id command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-icon",
                    "markdownDescription": "Denies the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon_as_template command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-icon-as-template",
                    "markdownDescription": "Denies the set_icon_as_template command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_menu command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-menu",
                    "markdownDescription": "Denies the set_menu command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_show_menu_on_left_click command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-show-menu-on-left-click",
                    "markdownDescription": "Denies the set_show_menu_on_left_click command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_temp_dir_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-temp-dir-path",
                    "markdownDescription": "Denies the set_temp_dir_path command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-title",
                    "markdownDescription": "Denies the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_tooltip command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-tooltip",
                    "markdownDescription": "Denies the set_tooltip command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:tray:deny-set-visible",
                    "markdownDescription": "Denies the set_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-webviews`\n- `allow-webview-position`\n- `allow-webview-size`\n- `allow-internal-toggle-devtools`",
                    "type": "string",
                    "const": "core:webview:default",
                    "markdownDescription": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-webviews`\n- `allow-webview-position`\n- `allow-webview-size`\n- `allow-internal-toggle-devtools`"
                  },
                  {
                    "description": "Enables the clear_all_browsing_data command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-clear-all-browsing-data",
                    "markdownDescription": "Enables the clear_all_browsing_data command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create_webview command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-create-webview",
                    "markdownDescription": "Enables the create_webview command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create_webview_window command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-create-webview-window",
                    "markdownDescription": "Enables the create_webview_window command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the get_all_webviews command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-get-all-webviews",
                    "markdownDescription": "Enables the get_all_webviews command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the internal_toggle_devtools command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-internal-toggle-devtools",
                    "markdownDescription": "Enables the internal_toggle_devtools command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the print command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-print",
                    "markdownDescription": "Enables the print command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the reparent command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-reparent",
                    "markdownDescription": "Enables the reparent command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_auto_resize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-auto-resize",
                    "markdownDescription": "Enables the set_webview_auto_resize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-background-color",
                    "markdownDescription": "Enables the set_webview_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-focus",
                    "markdownDescription": "Enables the set_webview_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-position",
                    "markdownDescription": "Enables the set_webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-size",
                    "markdownDescription": "Enables the set_webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_webview_zoom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-set-webview-zoom",
                    "markdownDescription": "Enables the set_webview_zoom command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-close",
                    "markdownDescription": "Enables the webview_close command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-hide",
                    "markdownDescription": "Enables the webview_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-position",
                    "markdownDescription": "Enables the webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-show",
                    "markdownDescription": "Enables the webview_show command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:allow-webview-size",
                    "markdownDescription": "Enables the webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the clear_all_browsing_data command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-clear-all-browsing-data",
                    "markdownDescription": "Denies the clear_all_browsing_data command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create_webview command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-create-webview",
                    "markdownDescription": "Denies the create_webview command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create_webview_window command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-create-webview-window",
                    "markdownDescription": "Denies the create_webview_window command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get_all_webviews command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-get-all-webviews",
                    "markdownDescription": "Denies the get_all_webviews command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the internal_toggle_devtools command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-internal-toggle-devtools",
                    "markdownDescription": "Denies the internal_toggle_devtools command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the print command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-print",
                    "markdownDescription": "Denies the print command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the reparent command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-reparent",
                    "markdownDescription": "Denies the reparent command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_auto_resize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-auto-resize",
                    "markdownDescription": "Denies the set_webview_auto_resize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-background-color",
                    "markdownDescription": "Denies the set_webview_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-focus",
                    "markdownDescription": "Denies the set_webview_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-position",
                    "markdownDescription": "Denies the set_webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-size",
                    "markdownDescription": "Denies the set_webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_webview_zoom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-set-webview-zoom",
                    "markdownDescription": "Denies the set_webview_zoom command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-close",
                    "markdownDescription": "Denies the webview_close command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-hide",
                    "markdownDescription": "Denies the webview_hide command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-position",
                    "markdownDescription": "Denies the webview_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-show",
                    "markdownDescription": "Denies the webview_show command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the webview_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:webview:deny-webview-size",
                    "markdownDescription": "Denies the webview_size command without any pre-configured scope."
                  },
                  {
                    "description": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-windows`\n- `allow-scale-factor`\n- `allow-inner-position`\n- `allow-outer-position`\n- `allow-inner-size`\n- `allow-outer-size`\n- `allow-is-fullscreen`\n- `allow-is-minimized`\n- `allow-is-maximized`\n- `allow-is-focused`\n- `allow-is-decorated`\n- `allow-is-resizable`\n- `allow-is-maximizable`\n- `allow-is-minimizable`\n- `allow-is-closable`\n- `allow-is-visible`\n- `allow-is-enabled`\n- `allow-title`\n- `allow-current-monitor`\n- `allow-primary-monitor`\n- `allow-monitor-from-point`\n- `allow-available-monitors`\n- `allow-cursor-position`\n- `allow-theme`\n- `allow-is-always-on-top`\n- `allow-internal-toggle-maximize`",
                    "type": "string",
                    "const": "core:window:default",
                    "markdownDescription": "Default permissions for the plugin.\n#### This default permission set includes:\n\n- `allow-get-all-windows`\n- `allow-scale-factor`\n- `allow-inner-position`\n- `allow-outer-position`\n- `allow-inner-size`\n- `allow-outer-size`\n- `allow-is-fullscreen`\n- `allow-is-minimized`\n- `allow-is-maximized`\n- `allow-is-focused`\n- `allow-is-decorated`\n- `allow-is-resizable`\n- `allow-is-maximizable`\n- `allow-is-minimizable`\n- `allow-is-closable`\n- `allow-is-visible`\n- `allow-is-enabled`\n- `allow-title`\n- `allow-current-monitor`\n- `allow-primary-monitor`\n- `allow-monitor-from-point`\n- `allow-available-monitors`\n- `allow-cursor-position`\n- `allow-theme`\n- `allow-is-always-on-top`\n- `allow-internal-toggle-maximize`"
                  },
                  {
                    "description": "Enables the available_monitors command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-available-monitors",
                    "markdownDescription": "Enables the available_monitors command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the center command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-center",
                    "markdownDescription": "Enables the center command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-close",
                    "markdownDescription": "Enables the close command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the create command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-create",
                    "markdownDescription": "Enables the create command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the current_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-current-monitor",
                    "markdownDescription": "Enables the current_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-cursor-position",
                    "markdownDescription": "Enables the cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the destroy command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-destroy",
                    "markdownDescription": "Enables the destroy command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the get_all_windows command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-get-all-windows",
                    "markdownDescription": "Enables the get_all_windows command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-hide",
                    "markdownDescription": "Enables the hide command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the inner_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-inner-position",
                    "markdownDescription": "Enables the inner_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the inner_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-inner-size",
                    "markdownDescription": "Enables the inner_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the internal_toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-internal-toggle-maximize",
                    "markdownDescription": "Enables the internal_toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-always-on-top",
                    "markdownDescription": "Enables the is_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-closable",
                    "markdownDescription": "Enables the is_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_decorated command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-decorated",
                    "markdownDescription": "Enables the is_decorated command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-enabled",
                    "markdownDescription": "Enables the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_focused command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-focused",
                    "markdownDescription": "Enables the is_focused command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-fullscreen",
                    "markdownDescription": "Enables the is_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-maximizable",
                    "markdownDescription": "Enables the is_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_maximized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-maximized",
                    "markdownDescription": "Enables the is_maximized command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-minimizable",
                    "markdownDescription": "Enables the is_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_minimized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-minimized",
                    "markdownDescription": "Enables the is_minimized command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-resizable",
                    "markdownDescription": "Enables the is_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the is_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-is-visible",
                    "markdownDescription": "Enables the is_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-maximize",
                    "markdownDescription": "Enables the maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the minimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-minimize",
                    "markdownDescription": "Enables the minimize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the monitor_from_point command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-monitor-from-point",
                    "markdownDescription": "Enables the monitor_from_point command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the outer_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-outer-position",
                    "markdownDescription": "Enables the outer_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the outer_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-outer-size",
                    "markdownDescription": "Enables the outer_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the primary_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-primary-monitor",
                    "markdownDescription": "Enables the primary_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the request_user_attention command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-request-user-attention",
                    "markdownDescription": "Enables the request_user_attention command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the scale_factor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-scale-factor",
                    "markdownDescription": "Enables the scale_factor command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_always_on_bottom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-always-on-bottom",
                    "markdownDescription": "Enables the set_always_on_bottom command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-always-on-top",
                    "markdownDescription": "Enables the set_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-background-color",
                    "markdownDescription": "Enables the set_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_badge_count command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-badge-count",
                    "markdownDescription": "Enables the set_badge_count command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_badge_label command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-badge-label",
                    "markdownDescription": "Enables the set_badge_label command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-closable",
                    "markdownDescription": "Enables the set_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_content_protected command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-content-protected",
                    "markdownDescription": "Enables the set_content_protected command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_grab command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-grab",
                    "markdownDescription": "Enables the set_cursor_grab command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-icon",
                    "markdownDescription": "Enables the set_cursor_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-position",
                    "markdownDescription": "Enables the set_cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_cursor_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-cursor-visible",
                    "markdownDescription": "Enables the set_cursor_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_decorations command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-decorations",
                    "markdownDescription": "Enables the set_decorations command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_effects command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-effects",
                    "markdownDescription": "Enables the set_effects command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-enabled",
                    "markdownDescription": "Enables the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-focus",
                    "markdownDescription": "Enables the set_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_focusable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-focusable",
                    "markdownDescription": "Enables the set_focusable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-fullscreen",
                    "markdownDescription": "Enables the set_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-icon",
                    "markdownDescription": "Enables the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_ignore_cursor_events command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-ignore-cursor-events",
                    "markdownDescription": "Enables the set_ignore_cursor_events command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_max_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-max-size",
                    "markdownDescription": "Enables the set_max_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-maximizable",
                    "markdownDescription": "Enables the set_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_min_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-min-size",
                    "markdownDescription": "Enables the set_min_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-minimizable",
                    "markdownDescription": "Enables the set_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_overlay_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-overlay-icon",
                    "markdownDescription": "Enables the set_overlay_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-position",
                    "markdownDescription": "Enables the set_position command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_progress_bar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-progress-bar",
                    "markdownDescription": "Enables the set_progress_bar command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-resizable",
                    "markdownDescription": "Enables the set_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_shadow command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-shadow",
                    "markdownDescription": "Enables the set_shadow command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_simple_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-simple-fullscreen",
                    "markdownDescription": "Enables the set_simple_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-size",
                    "markdownDescription": "Enables the set_size command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_size_constraints command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-size-constraints",
                    "markdownDescription": "Enables the set_size_constraints command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_skip_taskbar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-skip-taskbar",
                    "markdownDescription": "Enables the set_skip_taskbar command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-theme",
                    "markdownDescription": "Enables the set_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-title",
                    "markdownDescription": "Enables the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_title_bar_style command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-title-bar-style",
                    "markdownDescription": "Enables the set_title_bar_style command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the set_visible_on_all_workspaces command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-set-visible-on-all-workspaces",
                    "markdownDescription": "Enables the set_visible_on_all_workspaces command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-show",
                    "markdownDescription": "Enables the show command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the start_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-start-dragging",
                    "markdownDescription": "Enables the start_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the start_resize_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-start-resize-dragging",
                    "markdownDescription": "Enables the start_resize_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-theme",
                    "markdownDescription": "Enables the theme command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-title",
                    "markdownDescription": "Enables the title command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-toggle-maximize",
                    "markdownDescription": "Enables the toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the unmaximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-unmaximize",
                    "markdownDescription": "Enables the unmaximize command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the unminimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:allow-unminimize",
                    "markdownDescription": "Enables the unminimize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the available_monitors command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-available-monitors",
                    "markdownDescription": "Denies the available_monitors command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the center command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-center",
                    "markdownDescription": "Denies the center command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the close command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-close",
                    "markdownDescription": "Denies the close command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the create command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-create",
                    "markdownDescription": "Denies the create command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the current_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-current-monitor",
                    "markdownDescription": "Denies the current_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-cursor-position",
                    "markdownDescription": "Denies the cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the destroy command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-destroy",
                    "markdownDescription": "Denies the destroy command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the get_all_windows command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-get-all-windows",
                    "markdownDescription": "Denies the get_all_windows command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the hide command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-hide",
                    "markdownDescription": "Denies the hide command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the inner_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-inner-position",
                    "markdownDescription": "Denies the inner_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the inner_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-inner-size",
                    "markdownDescription": "Denies the inner_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the internal_toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-internal-toggle-maximize",
                    "markdownDescription": "Denies the internal_toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-always-on-top",
                    "markdownDescription": "Denies the is_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-closable",
                    "markdownDescription": "Denies the is_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_decorated command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-decorated",
                    "markdownDescription": "Denies the is_decorated command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-enabled",
                    "markdownDescription": "Denies the is_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_focused command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-focused",
                    "markdownDescription": "Denies the is_focused command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-fullscreen",
                    "markdownDescription": "Denies the is_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-maximizable",
                    "markdownDescription": "Denies the is_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_maximized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-maximized",
                    "markdownDescription": "Denies the is_maximized command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-minimizable",
                    "markdownDescription": "Denies the is_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_minimized command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-minimized",
                    "markdownDescription": "Denies the is_minimized command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-resizable",
                    "markdownDescription": "Denies the is_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the is_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-is-visible",
                    "markdownDescription": "Denies the is_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-maximize",
                    "markdownDescription": "Denies the maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the minimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-minimize",
                    "markdownDescription": "Denies the minimize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the monitor_from_point command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-monitor-from-point",
                    "markdownDescription": "Denies the monitor_from_point command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the outer_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-outer-position",
                    "markdownDescription": "Denies the outer_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the outer_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-outer-size",
                    "markdownDescription": "Denies the outer_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the primary_monitor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-primary-monitor",
                    "markdownDescription": "Denies the primary_monitor command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the request_user_attention command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-request-user-attention",
                    "markdownDescription": "Denies the request_user_attention command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the scale_factor command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-scale-factor",
                    "markdownDescription": "Denies the scale_factor command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_always_on_bottom command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-always-on-bottom",
                    "markdownDescription": "Denies the set_always_on_bottom command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_always_on_top command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-always-on-top",
                    "markdownDescription": "Denies the set_always_on_top command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_background_color command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-background-color",
                    "markdownDescription": "Denies the set_background_color command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_badge_count command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-badge-count",
                    "markdownDescription": "Denies the set_badge_count command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_badge_label command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-badge-label",
                    "markdownDescription": "Denies the set_badge_label command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_closable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-closable",
                    "markdownDescription": "Denies the set_closable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_content_protected command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-content-protected",
                    "markdownDescription": "Denies the set_content_protected command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_grab command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-grab",
                    "markdownDescription": "Denies the set_cursor_grab command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-icon",
                    "markdownDescription": "Denies the set_cursor_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-position",
                    "markdownDescription": "Denies the set_cursor_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_cursor_visible command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-cursor-visible",
                    "markdownDescription": "Denies the set_cursor_visible command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_decorations command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-decorations",
                    "markdownDescription": "Denies the set_decorations command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_effects command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-effects",
                    "markdownDescription": "Denies the set_effects command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_enabled command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-enabled",
                    "markdownDescription": "Denies the set_enabled command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_focus command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-focus",
                    "markdownDescription": "Denies the set_focus command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_focusable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-focusable",
                    "markdownDescription": "Denies the set_focusable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-fullscreen",
                    "markdownDescription": "Denies the set_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-icon",
                    "markdownDescription": "Denies the set_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_ignore_cursor_events command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-ignore-cursor-events",
                    "markdownDescription": "Denies the set_ignore_cursor_events command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_max_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-max-size",
                    "markdownDescription": "Denies the set_max_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_maximizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-maximizable",
                    "markdownDescription": "Denies the set_maximizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_min_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-min-size",
                    "markdownDescription": "Denies the set_min_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_minimizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-minimizable",
                    "markdownDescription": "Denies the set_minimizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_overlay_icon command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-overlay-icon",
                    "markdownDescription": "Denies the set_overlay_icon command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_position command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-position",
                    "markdownDescription": "Denies the set_position command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_progress_bar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-progress-bar",
                    "markdownDescription": "Denies the set_progress_bar command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_resizable command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-resizable",
                    "markdownDescription": "Denies the set_resizable command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_shadow command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-shadow",
                    "markdownDescription": "Denies the set_shadow command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_simple_fullscreen command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-simple-fullscreen",
                    "markdownDescription": "Denies the set_simple_fullscreen command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_size command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-size",
                    "markdownDescription": "Denies the set_size command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_size_constraints command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-size-constraints",
                    "markdownDescription": "Denies the set_size_constraints command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_skip_taskbar command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-skip-taskbar",
                    "markdownDescription": "Denies the set_skip_taskbar command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-theme",
                    "markdownDescription": "Denies the set_theme command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-title",
                    "markdownDescription": "Denies the set_title command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_title_bar_style command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-title-bar-style",
                    "markdownDescription": "Denies the set_title_bar_style command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the set_visible_on_all_workspaces command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-set-visible-on-all-workspaces",
                    "markdownDescription": "Denies the set_visible_on_all_workspaces command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the show command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-show",
                    "markdownDescription": "Denies the show command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the start_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-start-dragging",
                    "markdownDescription": "Denies the start_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the start_resize_dragging command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-start-resize-dragging",
                    "markdownDescription": "Denies the start_resize_dragging command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the theme command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-theme",
                    "markdownDescription": "Denies the theme command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the title command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-title",
                    "markdownDescription": "Denies the title command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the toggle_maximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-toggle-maximize",
                    "markdownDescription": "Denies the toggle_maximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the unmaximize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-unmaximize",
                    "markdownDescription": "Denies the unmaximize command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the unminimize command without any pre-configured scope.",
                    "type": "string",
                    "const": "core:window:deny-unminimize",
                    "markdownDescription": "Denies the unminimize command without any pre-configured scope."
                  },
                  {
                    "description": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`",
                    "type": "string",
                    "const": "opener:default",
                    "markdownDescription": "This permission set allows opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application\nas well as reveal file in directories using default file explorer\n#### This default permission set includes:\n\n- `allow-open-url`\n- `allow-reveal-item-in-dir`\n- `allow-default-urls`"
                  },
                  {
                    "description": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application.",
                    "type": "string",
                    "const": "opener:allow-default-urls",
                    "markdownDescription": "This enables opening `mailto:`, `tel:`, `https://` and `http://` urls using their default application."
                  },
                  {
                    "description": "Enables the open_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:allow-open-path",
                    "markdownDescription": "Enables the open_path command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the open_url command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:allow-open-url",
                    "markdownDescription": "Enables the open_url command without any pre-configured scope."
                  },
                  {
                    "description": "Enables the reveal_item_in_dir command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:allow-reveal-item-in-dir",
                    "markdownDescription": "Enables the reveal_item_in_dir command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the open_path command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:deny-open-path",
                    "markdownDescription": "Denies the open_path command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the open_url command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:deny-open-url",
                    "markdownDescription": "Denies the open_url command without any pre-configured scope."
                  },
                  {
                    "description": "Denies the reveal_item_in_dir command without any pre-configured scope.",
                    "type": "string",
                    "const": "opener:deny-reveal-item-in-dir",
                    "markdownDescription": "Denies the reveal_item_in_dir command without any pre-configured scope."
                  }
                ]
              },
              "Value": {
                "description": "All supported ACL values.",
                "anyOf": [
                  {
                    "description": "Represents a null JSON value.",
                    "type": "null"
                  },
                  {
                    "description": "Represents a [`bool`].",
                    "type": "boolean"
                  },
                  {
                    "description": "Represents a valid ACL [`Number`].",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Number"
                      }
                    ]
                  },
                  {
                    "description": "Represents a [`String`].",
                    "type": "string"
                  },
                  {
                    "description": "Represents a list of other [`Value`]s.",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Value"
                    }
                  },
                  {
                    "description": "Represents a map of [`String`] keys to [`Value`]s.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/definitions/Value"
                    }
                  }
                ]
              },
              "Number": {
                "description": "A valid ACL number.",
                "anyOf": [
                  {
                    "description": "Represents an [`i64`].",
                    "type": "integer",
                    "format": "int64"
                  },
                  {
                    "description": "Represents a [`f64`].",
                    "type": "number",
                    "format": "double"
                  }
                ]
              },
              "Target": {
                "description": "Platform target.",
                "oneOf": [
                  {
                    "description": "MacOS.",
                    "type": "string",
                    "enum": [
                      "macOS"
                    ]
                  },
                  {
                    "description": "Windows.",
                    "type": "string",
                    "enum": [
                      "windows"
                    ]
                  },
                  {
                    "description": "Linux.",
                    "type": "string",
                    "enum": [
                      "linux"
                    ]
                  },
                  {
                    "description": "Android.",
                    "type": "string",
                    "enum": [
                      "android"
                    ]
                  },
                  {
                    "description": "iOS.",
                    "type": "string",
                    "enum": [
                      "iOS"
                    ]
                  }
                ]
              },
              "Application": {
                "description": "Opener scope application.",
                "anyOf": [
                  {
                    "description": "Open in default application.",
                    "type": "null"
                  },
                  {
                    "description": "If true, allow open with any application.",
                    "type": "boolean"
                  },
                  {
                    "description": "Allow specific application to open with.",
                    "type": "string"
                  }
                ]
              }
            }
          }
          ```

    - ğŸ“ **icons/**
      - ğŸ“„ **128x128.png**
      - ğŸ“„ **128x128@2x.png**
      - ğŸ“„ **32x32.png**
      - ğŸ“„ **Square107x107Logo.png**
      - ğŸ“„ **Square142x142Logo.png**
      - ğŸ“„ **Square150x150Logo.png**
      - ğŸ“„ **Square284x284Logo.png**
      - ğŸ“„ **Square30x30Logo.png**
      - ğŸ“„ **Square310x310Logo.png**
      - ğŸ“„ **Square44x44Logo.png**
      - ğŸ“„ **Square71x71Logo.png**
      - ğŸ“„ **Square89x89Logo.png**
      - ğŸ“„ **StoreLogo.png**
      - ğŸ“„ **icon.icns**
      - ğŸ“„ **icon.ico**
      - ğŸ“„ **icon.png**
    - ğŸ“ **src/**
      - ğŸ“ **commands/**
        - ğŸ“„ **calling.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\calling.rs`
          *Size*: 5992 bytes | *Modified*: 2026-01-17 04:23:13

          ```
          //! Tauri commands for voice calling
          
          use serde::{Deserialize, Serialize};
          use std::sync::Arc;
          use tauri::State;
          
          use crate::error::AppError;
          use crate::services::CallingService;
          
          /// Offer result for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct OfferResult {
              pub call_id: String,
              pub caller_peer_id: String,
              pub callee_peer_id: String,
              pub sdp: String,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// Answer result for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct AnswerResult {
              pub call_id: String,
              pub caller_peer_id: String,
              pub callee_peer_id: String,
              pub sdp: String,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// ICE candidate result for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct IceResult {
              pub call_id: String,
              pub sender_peer_id: String,
              pub candidate: String,
              pub sdp_mid: Option<String>,
              pub sdp_mline_index: Option<u32>,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// Hangup result for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct HangupResult {
              pub call_id: String,
              pub sender_peer_id: String,
              pub reason: String,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// Start a call (create an offer)
          #[tauri::command]
          pub async fn start_call(
              calling_service: State<'_, Arc<CallingService>>,
              callee_peer_id: String,
              sdp: String,
          ) -> Result<OfferResult, AppError> {
              let offer = calling_service.create_offer(&callee_peer_id, &sdp)?;
          
              Ok(OfferResult {
                  call_id: offer.call_id,
                  caller_peer_id: offer.caller_peer_id,
                  callee_peer_id: offer.callee_peer_id,
                  sdp: offer.sdp,
                  timestamp: offer.timestamp,
                  signature: offer.signature,
              })
          }
          
          /// Answer a call
          #[tauri::command]
          pub async fn answer_call(
              calling_service: State<'_, Arc<CallingService>>,
              call_id: String,
              caller_peer_id: String,
              sdp: String,
          ) -> Result<AnswerResult, AppError> {
              let answer = calling_service.create_answer(&call_id, &caller_peer_id, &sdp)?;
          
              Ok(AnswerResult {
                  call_id: answer.call_id,
                  caller_peer_id: answer.caller_peer_id,
                  callee_peer_id: answer.callee_peer_id,
                  sdp: answer.sdp,
                  timestamp: answer.timestamp,
                  signature: answer.signature,
              })
          }
          
          /// Send an ICE candidate
          #[tauri::command]
          pub async fn send_ice_candidate(
              calling_service: State<'_, Arc<CallingService>>,
              call_id: String,
              candidate: String,
              sdp_mid: Option<String>,
              sdp_mline_index: Option<u32>,
          ) -> Result<IceResult, AppError> {
              let ice = calling_service.create_ice_candidate(
                  &call_id,
                  &candidate,
                  sdp_mid.as_deref(),
                  sdp_mline_index,
              )?;
          
              Ok(IceResult {
                  call_id: ice.call_id,
                  sender_peer_id: ice.sender_peer_id,
                  candidate: ice.candidate,
                  sdp_mid: ice.sdp_mid,
                  sdp_mline_index: ice.sdp_mline_index,
                  timestamp: ice.timestamp,
                  signature: ice.signature,
              })
          }
          
          /// Hang up a call
          #[tauri::command]
          pub async fn hangup_call(
              calling_service: State<'_, Arc<CallingService>>,
              call_id: String,
              reason: Option<String>,
          ) -> Result<HangupResult, AppError> {
              let reason = reason.unwrap_or_else(|| "normal".to_string());
              let hangup = calling_service.create_hangup(&call_id, &reason)?;
          
              Ok(HangupResult {
                  call_id: hangup.call_id,
                  sender_peer_id: hangup.sender_peer_id,
                  reason: hangup.reason,
                  timestamp: hangup.timestamp,
                  signature: hangup.signature,
              })
          }
          
          /// Process an incoming offer (validate it)
          #[tauri::command]
          pub async fn process_offer(
              calling_service: State<'_, Arc<CallingService>>,
              call_id: String,
              caller_peer_id: String,
              callee_peer_id: String,
              sdp: String,
              timestamp: i64,
              signature: Vec<u8>,
          ) -> Result<(), AppError> {
              calling_service.process_incoming_offer(
                  &call_id,
                  &caller_peer_id,
                  &callee_peer_id,
                  &sdp,
                  timestamp,
                  &signature,
              )
          }
          
          /// Process an incoming answer (validate it)
          #[tauri::command]
          pub async fn process_answer(
              calling_service: State<'_, Arc<CallingService>>,
              call_id: String,
              caller_peer_id: String,
              callee_peer_id: String,
              sdp: String,
              timestamp: i64,
              signature: Vec<u8>,
          ) -> Result<(), AppError> {
              calling_service.process_incoming_answer(
                  &call_id,
                  &caller_peer_id,
                  &callee_peer_id,
                  &sdp,
                  timestamp,
                  &signature,
              )
          }
          
          /// Process an incoming ICE candidate (validate it)
          #[tauri::command]
          pub async fn process_ice_candidate(
              calling_service: State<'_, Arc<CallingService>>,
              call_id: String,
              sender_peer_id: String,
              candidate: String,
              sdp_mid: Option<String>,
              sdp_mline_index: Option<u32>,
              timestamp: i64,
              signature: Vec<u8>,
          ) -> Result<(), AppError> {
              calling_service.process_incoming_ice(
                  &call_id,
                  &sender_peer_id,
                  &candidate,
                  sdp_mid.as_deref(),
                  sdp_mline_index,
                  timestamp,
                  &signature,
              )
          }
          
          /// Process an incoming hangup (validate it)
          #[tauri::command]
          pub async fn process_hangup(
              calling_service: State<'_, Arc<CallingService>>,
              call_id: String,
              sender_peer_id: String,
              reason: String,
              timestamp: i64,
              signature: Vec<u8>,
          ) -> Result<(), AppError> {
              calling_service.process_incoming_hangup(
                  &call_id,
                  &sender_peer_id,
                  &reason,
                  timestamp,
                  &signature,
              )
          }
          ```

        - ğŸ“„ **contacts.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\contacts.rs`
          *Size*: 4569 bytes | *Modified*: 2026-01-18 00:18:33

          ```
          //! Tauri commands for contact management
          
          use libp2p::PeerId;
          use serde::{Deserialize, Serialize};
          use std::str::FromStr;
          use std::sync::Arc;
          use tauri::State;
          use tracing::info;
          
          use crate::commands::network::NetworkState;
          use crate::error::AppError;
          use crate::services::ContactsService;
          
          /// Contact info for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct ContactInfo {
              pub id: i64,
              pub peer_id: String,
              pub display_name: String,
              pub avatar_hash: Option<String>,
              pub bio: Option<String>,
              pub is_blocked: bool,
              pub trust_level: i32,
              pub last_seen_at: Option<i64>,
              pub added_at: i64,
          }
          
          /// Get all contacts
          #[tauri::command]
          pub async fn get_contacts(
              contacts_service: State<'_, Arc<ContactsService>>,
          ) -> Result<Vec<ContactInfo>, AppError> {
              let contacts = contacts_service.get_all_contacts()?;
              Ok(contacts.into_iter().map(|c| ContactInfo {
                  id: c.id,
                  peer_id: c.peer_id,
                  display_name: c.display_name,
                  avatar_hash: c.avatar_hash,
                  bio: c.bio,
                  is_blocked: c.is_blocked,
                  trust_level: c.trust_level,
                  last_seen_at: c.last_seen_at,
                  added_at: c.added_at,
              }).collect())
          }
          
          /// Get active (non-blocked) contacts
          #[tauri::command]
          pub async fn get_active_contacts(
              contacts_service: State<'_, Arc<ContactsService>>,
          ) -> Result<Vec<ContactInfo>, AppError> {
              let contacts = contacts_service.get_active_contacts()?;
              Ok(contacts.into_iter().map(|c| ContactInfo {
                  id: c.id,
                  peer_id: c.peer_id,
                  display_name: c.display_name,
                  avatar_hash: c.avatar_hash,
                  bio: c.bio,
                  is_blocked: c.is_blocked,
                  trust_level: c.trust_level,
                  last_seen_at: c.last_seen_at,
                  added_at: c.added_at,
              }).collect())
          }
          
          /// Get a single contact by peer ID
          #[tauri::command]
          pub async fn get_contact(
              contacts_service: State<'_, Arc<ContactsService>>,
              peer_id: String,
          ) -> Result<Option<ContactInfo>, AppError> {
              let contact = contacts_service.get_contact(&peer_id)?;
              Ok(contact.map(|c| ContactInfo {
                  id: c.id,
                  peer_id: c.peer_id,
                  display_name: c.display_name,
                  avatar_hash: c.avatar_hash,
                  bio: c.bio,
                  is_blocked: c.is_blocked,
                  trust_level: c.trust_level,
                  last_seen_at: c.last_seen_at,
                  added_at: c.added_at,
              }))
          }
          
          /// Add a new contact
          #[tauri::command]
          pub async fn add_contact(
              contacts_service: State<'_, Arc<ContactsService>>,
              peer_id: String,
              public_key: Vec<u8>,
              x25519_public: Vec<u8>,
              display_name: String,
              avatar_hash: Option<String>,
              bio: Option<String>,
          ) -> Result<i64, AppError> {
              contacts_service.add_contact(
                  &peer_id,
                  &public_key,
                  &x25519_public,
                  &display_name,
                  avatar_hash.as_deref(),
                  bio.as_deref(),
              )
          }
          
          /// Block a contact
          #[tauri::command]
          pub async fn block_contact(
              contacts_service: State<'_, Arc<ContactsService>>,
              peer_id: String,
          ) -> Result<bool, AppError> {
              contacts_service.block_contact(&peer_id)
          }
          
          /// Unblock a contact
          #[tauri::command]
          pub async fn unblock_contact(
              contacts_service: State<'_, Arc<ContactsService>>,
              peer_id: String,
          ) -> Result<bool, AppError> {
              contacts_service.unblock_contact(&peer_id)
          }
          
          /// Remove a contact
          #[tauri::command]
          pub async fn remove_contact(
              contacts_service: State<'_, Arc<ContactsService>>,
              peer_id: String,
          ) -> Result<bool, AppError> {
              contacts_service.remove_contact(&peer_id)
          }
          
          /// Check if a peer is a contact
          #[tauri::command]
          pub async fn is_contact(
              contacts_service: State<'_, Arc<ContactsService>>,
              peer_id: String,
          ) -> Result<bool, AppError> {
              contacts_service.is_contact(&peer_id)
          }
          
          /// Check if a contact is blocked
          #[tauri::command]
          pub async fn is_contact_blocked(
              contacts_service: State<'_, Arc<ContactsService>>,
              peer_id: String,
          ) -> Result<bool, AppError> {
              contacts_service.is_blocked(&peer_id)
          }
          
          /// Request identity exchange with a peer (adds them as a contact)
          #[tauri::command]
          pub async fn request_peer_identity(
              network: State<'_, NetworkState>,
              peer_id: String,
          ) -> Result<(), AppError> {
              let libp2p_peer_id = PeerId::from_str(&peer_id)
                  .map_err(|e| AppError::Validation(format!("Invalid peer ID: {}", e)))?;
          
              let handle = network.get_handle().await?;
              handle.request_identity(libp2p_peer_id).await?;
          
              info!("Requested identity from peer {}", peer_id);
              Ok(())
          }
          ```

        - ğŸ“„ **feed.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\feed.rs`
          *Size*: 2134 bytes | *Modified*: 2026-01-17 04:16:26

          ```
          //! Tauri commands for feed functionality
          
          use serde::{Deserialize, Serialize};
          use std::sync::Arc;
          use tauri::State;
          
          use crate::error::AppError;
          use crate::services::{FeedService, FeedItem};
          
          /// Feed item info for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct FeedItemInfo {
              pub post_id: String,
              pub author_peer_id: String,
              pub author_display_name: Option<String>,
              pub content_type: String,
              pub content_text: Option<String>,
              pub visibility: String,
              pub lamport_clock: i64,
              pub created_at: i64,
              pub updated_at: i64,
              pub is_local: bool,
          }
          
          impl From<FeedItem> for FeedItemInfo {
              fn from(item: FeedItem) -> Self {
                  Self {
                      post_id: item.post.post_id,
                      author_peer_id: item.post.author_peer_id,
                      author_display_name: item.author_display_name,
                      content_type: item.post.content_type,
                      content_text: item.post.content_text,
                      visibility: item.post.visibility.as_str().to_string(),
                      lamport_clock: item.post.lamport_clock,
                      created_at: item.post.created_at,
                      updated_at: item.post.updated_at,
                      is_local: item.post.is_local,
                  }
              }
          }
          
          /// Get the user's feed
          #[tauri::command]
          pub async fn get_feed(
              feed_service: State<'_, Arc<FeedService>>,
              limit: Option<i64>,
              before_timestamp: Option<i64>,
          ) -> Result<Vec<FeedItemInfo>, AppError> {
              let limit = limit.unwrap_or(50);
              let items = feed_service.get_feed(limit, before_timestamp)?;
              Ok(items.into_iter().map(FeedItemInfo::from).collect())
          }
          
          /// Get a specific user's wall
          #[tauri::command]
          pub async fn get_wall(
              feed_service: State<'_, Arc<FeedService>>,
              author_peer_id: String,
              limit: Option<i64>,
              before_timestamp: Option<i64>,
          ) -> Result<Vec<FeedItemInfo>, AppError> {
              let limit = limit.unwrap_or(50);
              let items = feed_service.get_wall(&author_peer_id, limit, before_timestamp)?;
              Ok(items.into_iter().map(FeedItemInfo::from).collect())
          }
          ```

        - ğŸ“„ **identity.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\identity.rs`
          *Size*: 2188 bytes | *Modified*: 2026-01-16 21:35:37

          ```
          use crate::error::AppError;
          use crate::models::{CreateIdentityRequest, IdentityInfo};
          use crate::services::IdentityService;
          use std::sync::Arc;
          use tauri::State;
          
          /// Check if an identity has been created
          #[tauri::command]
          pub async fn has_identity(
              identity_service: State<'_, Arc<IdentityService>>,
          ) -> Result<bool, AppError> {
              identity_service.has_identity()
          }
          
          /// Check if the identity is currently unlocked
          #[tauri::command]
          pub async fn is_identity_unlocked(
              identity_service: State<'_, Arc<IdentityService>>,
          ) -> Result<bool, AppError> {
              Ok(identity_service.is_unlocked())
          }
          
          /// Get identity info (public data only)
          #[tauri::command]
          pub async fn get_identity_info(
              identity_service: State<'_, Arc<IdentityService>>,
          ) -> Result<Option<IdentityInfo>, AppError> {
              identity_service.get_identity_info()
          }
          
          /// Create a new identity
          #[tauri::command]
          pub async fn create_identity(
              identity_service: State<'_, Arc<IdentityService>>,
              request: CreateIdentityRequest,
          ) -> Result<IdentityInfo, AppError> {
              identity_service.create_identity(request)
          }
          
          /// Unlock the identity with passphrase
          #[tauri::command]
          pub async fn unlock_identity(
              identity_service: State<'_, Arc<IdentityService>>,
              passphrase: String,
          ) -> Result<IdentityInfo, AppError> {
              identity_service.unlock(&passphrase)
          }
          
          /// Lock the identity
          #[tauri::command]
          pub async fn lock_identity(
              identity_service: State<'_, Arc<IdentityService>>,
          ) -> Result<(), AppError> {
              identity_service.lock();
              Ok(())
          }
          
          /// Update display name
          #[tauri::command]
          pub async fn update_display_name(
              identity_service: State<'_, Arc<IdentityService>>,
              display_name: String,
          ) -> Result<(), AppError> {
              identity_service.update_display_name(&display_name)
          }
          
          /// Update bio
          #[tauri::command]
          pub async fn update_bio(
              identity_service: State<'_, Arc<IdentityService>>,
              bio: Option<String>,
          ) -> Result<(), AppError> {
              identity_service.update_bio(bio.as_deref())
          }
          
          /// Get the local peer ID
          #[tauri::command]
          pub async fn get_peer_id(
              identity_service: State<'_, Arc<IdentityService>>,
          ) -> Result<String, AppError> {
              identity_service.get_peer_id()
          }
          ```

        - ğŸ“„ **messaging.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\messaging.rs`
          *Size*: 6293 bytes | *Modified*: 2026-01-17 11:04:44

          ```
          //! Tauri commands for direct messaging
          
          use libp2p::PeerId;
          use serde::{Deserialize, Serialize};
          use std::str::FromStr;
          use std::sync::Arc;
          use tauri::State;
          use tracing::info;
          
          use crate::commands::network::NetworkState;
          use crate::db::repositories::Conversation;
          use crate::error::AppError;
          use crate::p2p::protocols::messaging::{DirectMessage, MessagingCodec, MessagingMessage};
          use crate::services::{DecryptedMessage, MessagingService, OutgoingMessage};
          
          /// Message info for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct MessageInfo {
              pub message_id: String,
              pub conversation_id: String,
              pub sender_peer_id: String,
              pub recipient_peer_id: String,
              pub content: String,
              pub content_type: String,
              pub reply_to_message_id: Option<String>,
              pub sent_at: i64,
              pub delivered_at: Option<i64>,
              pub read_at: Option<i64>,
              pub status: String,
              pub is_outgoing: bool,
          }
          
          impl From<DecryptedMessage> for MessageInfo {
              fn from(msg: DecryptedMessage) -> Self {
                  Self {
                      message_id: msg.message_id,
                      conversation_id: msg.conversation_id,
                      sender_peer_id: msg.sender_peer_id,
                      recipient_peer_id: msg.recipient_peer_id,
                      content: msg.content,
                      content_type: msg.content_type,
                      reply_to_message_id: msg.reply_to_message_id,
                      sent_at: msg.sent_at,
                      delivered_at: msg.delivered_at,
                      read_at: msg.read_at,
                      status: msg.status,
                      is_outgoing: msg.is_outgoing,
                  }
              }
          }
          
          /// Conversation info for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct ConversationInfo {
              pub conversation_id: String,
              pub peer_id: String,
              pub last_message_at: i64,
              pub unread_count: i64,
          }
          
          impl From<Conversation> for ConversationInfo {
              fn from(conv: Conversation) -> Self {
                  Self {
                      conversation_id: conv.conversation_id,
                      peer_id: conv.peer_id,
                      last_message_at: conv.last_message_at,
                      unread_count: conv.unread_count,
                  }
              }
          }
          
          /// Send result for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct SendMessageResult {
              pub message_id: String,
              pub conversation_id: String,
              pub sent_at: i64,
          }
          
          /// Convert OutgoingMessage to DirectMessage for network transmission
          fn outgoing_to_direct_message(outgoing: &OutgoingMessage) -> DirectMessage {
              DirectMessage {
                  message_id: outgoing.message_id.clone(),
                  conversation_id: outgoing.conversation_id.clone(),
                  sender_peer_id: outgoing.sender_peer_id.clone(),
                  recipient_peer_id: outgoing.recipient_peer_id.clone(),
                  content_encrypted: outgoing.content_encrypted.clone(),
                  content_type: outgoing.content_type.clone(),
                  reply_to: outgoing.reply_to.clone(),
                  nonce_counter: outgoing.nonce_counter,
                  lamport_clock: outgoing.lamport_clock,
                  timestamp: outgoing.timestamp,
                  signature: outgoing.signature.clone(),
              }
          }
          
          /// Send a message to a peer
          #[tauri::command]
          pub async fn send_message(
              messaging_service: State<'_, Arc<MessagingService>>,
              network: State<'_, NetworkState>,
              peer_id: String,
              content: String,
              content_type: Option<String>,
              reply_to: Option<String>,
          ) -> Result<SendMessageResult, AppError> {
              let content_type = content_type.unwrap_or_else(|| "text".to_string());
          
              // Create the encrypted, signed message
              let outgoing = messaging_service.send_message(
                  &peer_id,
                  &content,
                  &content_type,
                  reply_to.as_deref(),
              )?;
          
              // Convert to DirectMessage and encode for network transmission
              let direct_msg = outgoing_to_direct_message(&outgoing);
              let msg_wrapper = MessagingMessage::Message(direct_msg);
              let payload = MessagingCodec::encode(&msg_wrapper)
                  .map_err(|e| AppError::Internal(format!("Failed to encode message: {}", e)))?;
          
              // Parse the peer ID
              let libp2p_peer_id = PeerId::from_str(&peer_id)
                  .map_err(|e| AppError::Validation(format!("Invalid peer ID: {}", e)))?;
          
              // Send over the network
              let handle = network.get_handle().await?;
              handle.send_message(libp2p_peer_id, "message".to_string(), payload).await?;
          
              info!("Message {} sent to peer {}", outgoing.message_id, peer_id);
          
              Ok(SendMessageResult {
                  message_id: outgoing.message_id,
                  conversation_id: outgoing.conversation_id,
                  sent_at: outgoing.timestamp,
              })
          }
          
          /// Get messages for a conversation
          #[tauri::command]
          pub async fn get_messages(
              messaging_service: State<'_, Arc<MessagingService>>,
              peer_id: String,
              limit: Option<i64>,
              before_timestamp: Option<i64>,
          ) -> Result<Vec<MessageInfo>, AppError> {
              let limit = limit.unwrap_or(50);
          
              let messages = messaging_service.get_conversation_messages(
                  &peer_id,
                  limit,
                  before_timestamp,
              )?;
          
              Ok(messages.into_iter().map(MessageInfo::from).collect())
          }
          
          /// Get all conversations
          #[tauri::command]
          pub async fn get_conversations(
              messaging_service: State<'_, Arc<MessagingService>>,
          ) -> Result<Vec<ConversationInfo>, AppError> {
              let conversations = messaging_service.get_conversations()?;
              Ok(conversations.into_iter().map(ConversationInfo::from).collect())
          }
          
          /// Mark a conversation as read
          #[tauri::command]
          pub async fn mark_conversation_read(
              messaging_service: State<'_, Arc<MessagingService>>,
              peer_id: String,
          ) -> Result<i64, AppError> {
              messaging_service.mark_conversation_read(&peer_id)
          }
          
          /// Get unread count for a conversation
          #[tauri::command]
          pub async fn get_unread_count(
              messaging_service: State<'_, Arc<MessagingService>>,
              peer_id: String,
          ) -> Result<i64, AppError> {
              messaging_service.get_unread_count(&peer_id)
          }
          
          /// Get total unread count across all conversations
          #[tauri::command]
          pub async fn get_total_unread_count(
              messaging_service: State<'_, Arc<MessagingService>>,
          ) -> Result<i64, AppError> {
              let conversations = messaging_service.get_conversations()?;
              let total: i64 = conversations.iter().map(|c| c.unread_count).sum();
              Ok(total)
          }
          ```

        - ğŸ“„ **mod.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\mod.rs`
          *Size*: 303 bytes | *Modified*: 2026-01-17 04:23:33

          ```
          pub mod calling;
          pub mod contacts;
          pub mod feed;
          pub mod identity;
          pub mod messaging;
          pub mod network;
          pub mod permissions;
          pub mod posts;
          
          pub use calling::*;
          pub use contacts::*;
          pub use feed::*;
          pub use identity::*;
          pub use messaging::*;
          pub use network::*;
          pub use permissions::*;
          pub use posts::*;
          ```

        - ğŸ“„ **network.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\network.rs`
          *Size*: 5905 bytes | *Modified*: 2026-01-18 10:11:15

          ```
          use crate::error::AppError;
          use crate::p2p::{NetworkConfig, NetworkHandle, NetworkService, NetworkStats, PeerInfo};
          use crate::services::{ContactsService, IdentityService, MessagingService, PermissionsService};
          use std::sync::Arc;
          use tauri::{AppHandle, Emitter, State};
          use tokio::sync::RwLock;
          use tracing::info;
          
          /// Wrapper for NetworkHandle to make it Tauri state compatible
          pub struct NetworkState {
              pub handle: RwLock<Option<NetworkHandle>>,
          }
          
          impl NetworkState {
              pub fn new() -> Self {
                  Self {
                      handle: RwLock::new(None),
                  }
              }
          
              pub async fn set_handle(&self, handle: NetworkHandle) {
                  let mut guard = self.handle.write().await;
                  *guard = Some(handle);
              }
          
              pub async fn get_handle(&self) -> Result<NetworkHandle, AppError> {
                  let guard: tokio::sync::RwLockReadGuard<'_, Option<NetworkHandle>> =
                      self.handle.read().await;
                  guard.clone().ok_or_else(|| {
                      AppError::Network("Network not initialized".to_string())
                  })
              }
          }
          
          impl Default for NetworkState {
              fn default() -> Self {
                  Self::new()
              }
          }
          
          /// Get list of connected peers
          #[tauri::command]
          pub async fn get_connected_peers(
              network: State<'_, NetworkState>,
          ) -> Result<Vec<PeerInfo>, AppError> {
              let handle: NetworkHandle = network.get_handle().await?;
              handle.get_connected_peers().await
          }
          
          /// Get network statistics
          #[tauri::command]
          pub async fn get_network_stats(
              network: State<'_, NetworkState>,
          ) -> Result<NetworkStats, AppError> {
              let handle: NetworkHandle = network.get_handle().await?;
              handle.get_stats().await
          }
          
          /// Check if the network is running
          #[tauri::command]
          pub async fn is_network_running(
              network: State<'_, NetworkState>,
          ) -> Result<bool, AppError> {
              let guard: tokio::sync::RwLockReadGuard<'_, Option<NetworkHandle>> =
                  network.handle.read().await;
              Ok(guard.is_some())
          }
          
          /// Bootstrap the DHT (connect to bootstrap nodes)
          #[tauri::command]
          pub async fn bootstrap_network(
              network: State<'_, NetworkState>,
          ) -> Result<(), AppError> {
              let handle: NetworkHandle = network.get_handle().await?;
              handle.bootstrap().await
          }
          
          /// Start the P2P network (called after identity is unlocked)
          #[tauri::command]
          pub async fn start_network(
              app: AppHandle,
              network: State<'_, NetworkState>,
              identity_service: State<'_, Arc<IdentityService>>,
              messaging_service: State<'_, Arc<MessagingService>>,
              contacts_service: State<'_, Arc<ContactsService>>,
              permissions_service: State<'_, Arc<PermissionsService>>,
          ) -> Result<(), AppError> {
              // Check if identity is unlocked
              if !identity_service.is_unlocked() {
                  return Err(AppError::PermissionDenied(
                      "Identity must be unlocked to start network".to_string(),
                  ));
              }
          
              // Check if network is already running
              {
                  let guard: tokio::sync::RwLockReadGuard<'_, Option<NetworkHandle>> =
                      network.handle.read().await;
                  if guard.is_some() {
                      return Ok(()); // Already running
                  }
              }
          
              // Get the unlocked keys to create a libp2p keypair
              let unlocked_keys = identity_service.get_unlocked_keys()?;
              let ed25519_bytes = unlocked_keys.ed25519_signing.to_bytes();
          
              // Convert to libp2p keypair
              let keypair = crate::p2p::swarm::ed25519_to_libp2p_keypair(&ed25519_bytes)?;
              let network_peer_id = libp2p::PeerId::from(keypair.public());
          
              // Compare with stored identity peer ID to verify they match
              if let Ok(Some(identity_info)) = identity_service.get_identity_info() {
                  info!(
                      "PEER ID CHECK - Stored: {} (len={}) vs Network: {} (len={})",
                      identity_info.peer_id,
                      identity_info.peer_id.len(),
                      network_peer_id,
                      network_peer_id.to_string().len()
                  );
                  if identity_info.peer_id != network_peer_id.to_string() {
                      tracing::error!(
                          "PEER ID MISMATCH! Stored peer ID does not match network peer ID. This will cause messaging to fail."
                      );
                  }
              }
          
              // Create network config
              let config = NetworkConfig::default();
          
              // Create network service - clone the Arc to pass to the service
              let identity_arc: Arc<IdentityService> = (*identity_service).clone();
              let (mut service, handle, mut event_rx) = NetworkService::new(
                  config,
                  identity_arc,
                  keypair,
              )?;
          
              // Inject services for message processing, contact storage, and permissions
              service.set_messaging_service((*messaging_service).clone());
              service.set_contacts_service((*contacts_service).clone());
              service.set_permissions_service((*permissions_service).clone());
          
              // Store the handle
              network.set_handle(handle).await;
          
              // Spawn the network service in a background task
              tokio::spawn(async move {
                  info!("Network service starting in background task");
                  service.run().await;
                  info!("Network service stopped");
              });
          
              // Spawn a task to process network events and forward to frontend
              let app_clone = app.clone();
              tokio::spawn(async move {
                  while let Some(event) = event_rx.recv().await {
                      info!("Network event: {:?}", event);
                      // Emit event to frontend
                      if let Err(e) = app_clone.emit("harbor:network", &event) {
                          tracing::warn!("Failed to emit network event: {}", e);
                      }
                  }
              });
          
              info!("Network started successfully");
              Ok(())
          }
          
          /// Stop the P2P network
          #[tauri::command]
          pub async fn stop_network(
              network: State<'_, NetworkState>,
          ) -> Result<(), AppError> {
              let maybe_handle: Option<NetworkHandle> = {
                  let mut guard = network.handle.write().await;
                  guard.take()
              };
          
              if let Some(handle) = maybe_handle {
                  handle.shutdown().await?;
                  info!("Network stopped");
              }
          
              Ok(())
          }
          ```

        - ğŸ“„ **permissions.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\permissions.rs`
          *Size*: 4986 bytes | *Modified*: 2026-01-16 21:40:15

          ```
          //! Tauri commands for permission management
          
          use serde::{Deserialize, Serialize};
          use tauri::State;
          use std::sync::Arc;
          
          use crate::db::Capability;
          use crate::error::AppError;
          use crate::services::PermissionsService;
          
          /// Permission info for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct PermissionInfo {
              pub grant_id: String,
              pub issuer_peer_id: String,
              pub subject_peer_id: String,
              pub capability: String,
              pub issued_at: i64,
              pub expires_at: Option<i64>,
              pub is_valid: bool,
          }
          
          /// Permission grant result
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct GrantResult {
              pub grant_id: String,
              pub capability: String,
              pub subject_peer_id: String,
              pub issued_at: i64,
              pub expires_at: Option<i64>,
          }
          
          fn capability_from_str(s: &str) -> Result<Capability, AppError> {
              Capability::from_str(s)
                  .ok_or_else(|| AppError::Validation(format!("Invalid capability: {}", s)))
          }
          
          /// Grant a permission to another peer
          #[tauri::command]
          pub async fn grant_permission(
              permissions_service: State<'_, Arc<PermissionsService>>,
              subject_peer_id: String,
              capability: String,
              expires_in_seconds: Option<i64>,
          ) -> Result<GrantResult, AppError> {
              let cap = capability_from_str(&capability)?;
              let grant = permissions_service.create_permission_grant(
                  &subject_peer_id,
                  cap,
                  expires_in_seconds,
              )?;
          
              Ok(GrantResult {
                  grant_id: grant.grant_id,
                  capability: grant.capability,
                  subject_peer_id: grant.subject_peer_id,
                  issued_at: grant.issued_at,
                  expires_at: grant.expires_at,
              })
          }
          
          /// Revoke a permission
          #[tauri::command]
          pub async fn revoke_permission(
              permissions_service: State<'_, Arc<PermissionsService>>,
              grant_id: String,
          ) -> Result<bool, AppError> {
              permissions_service.revoke_permission(&grant_id)?;
              Ok(true)
          }
          
          /// Check if a peer has a specific capability (we granted it to them)
          #[tauri::command]
          pub async fn peer_has_capability(
              permissions_service: State<'_, Arc<PermissionsService>>,
              peer_id: String,
              capability: String,
          ) -> Result<bool, AppError> {
              let cap = capability_from_str(&capability)?;
              permissions_service.peer_has_capability(&peer_id, cap)
          }
          
          /// Check if we have a specific capability from another peer
          #[tauri::command]
          pub async fn we_have_capability(
              permissions_service: State<'_, Arc<PermissionsService>>,
              issuer_peer_id: String,
              capability: String,
          ) -> Result<bool, AppError> {
              let cap = capability_from_str(&capability)?;
              permissions_service.we_have_capability(&issuer_peer_id, cap)
          }
          
          /// Get all permissions we've granted
          #[tauri::command]
          pub async fn get_granted_permissions(
              permissions_service: State<'_, Arc<PermissionsService>>,
          ) -> Result<Vec<PermissionInfo>, AppError> {
              let perms = permissions_service.get_granted_permissions()?;
              Ok(perms.into_iter().map(|p| {
                  let is_valid = p.is_valid();
                  PermissionInfo {
                      grant_id: p.grant_id,
                      issuer_peer_id: p.issuer_peer_id,
                      subject_peer_id: p.subject_peer_id,
                      capability: p.capability,
                      issued_at: p.issued_at,
                      expires_at: p.expires_at,
                      is_valid,
                  }
              }).collect())
          }
          
          /// Get all permissions granted to us
          #[tauri::command]
          pub async fn get_received_permissions(
              permissions_service: State<'_, Arc<PermissionsService>>,
          ) -> Result<Vec<PermissionInfo>, AppError> {
              let perms = permissions_service.get_received_permissions()?;
              Ok(perms.into_iter().map(|p| {
                  let is_valid = p.is_valid();
                  PermissionInfo {
                      grant_id: p.grant_id,
                      issuer_peer_id: p.issuer_peer_id,
                      subject_peer_id: p.subject_peer_id,
                      capability: p.capability,
                      issued_at: p.issued_at,
                      expires_at: p.expires_at,
                      is_valid,
                  }
              }).collect())
          }
          
          /// Get all peers we can chat with
          #[tauri::command]
          pub async fn get_chat_peers(
              permissions_service: State<'_, Arc<PermissionsService>>,
          ) -> Result<Vec<String>, AppError> {
              permissions_service.get_chat_peers()
          }
          
          /// Grant all standard permissions to a peer (chat, wall_read, call)
          #[tauri::command]
          pub async fn grant_all_permissions(
              permissions_service: State<'_, Arc<PermissionsService>>,
              subject_peer_id: String,
          ) -> Result<Vec<GrantResult>, AppError> {
              let mut results = Vec::new();
          
              for cap in [Capability::Chat, Capability::WallRead, Capability::Call] {
                  let grant = permissions_service.create_permission_grant(
                      &subject_peer_id,
                      cap,
                      None,
                  )?;
          
                  results.push(GrantResult {
                      grant_id: grant.grant_id,
                      capability: grant.capability,
                      subject_peer_id: grant.subject_peer_id.clone(),
                      issued_at: grant.issued_at,
                      expires_at: grant.expires_at,
                  });
              }
          
              Ok(results)
          }
          ```

        - ğŸ“„ **posts.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\commands\posts.rs`
          *Size*: 5632 bytes | *Modified*: 2026-01-16 23:46:48

          ```
          //! Tauri commands for wall/blog posts
          
          use serde::{Deserialize, Serialize};
          use std::sync::Arc;
          use tauri::State;
          
          use crate::db::repositories::{Post, PostMedia, PostVisibility};
          use crate::error::AppError;
          use crate::services::PostsService;
          
          /// Post info for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct PostInfo {
              pub post_id: String,
              pub author_peer_id: String,
              pub content_type: String,
              pub content_text: Option<String>,
              pub visibility: String,
              pub lamport_clock: i64,
              pub created_at: i64,
              pub updated_at: i64,
              pub deleted_at: Option<i64>,
              pub is_local: bool,
          }
          
          impl From<Post> for PostInfo {
              fn from(post: Post) -> Self {
                  Self {
                      post_id: post.post_id,
                      author_peer_id: post.author_peer_id,
                      content_type: post.content_type,
                      content_text: post.content_text,
                      visibility: post.visibility.as_str().to_string(),
                      lamport_clock: post.lamport_clock,
                      created_at: post.created_at,
                      updated_at: post.updated_at,
                      deleted_at: post.deleted_at,
                      is_local: post.is_local,
                  }
              }
          }
          
          /// Post media info for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct PostMediaInfo {
              pub id: i64,
              pub post_id: String,
              pub media_hash: String,
              pub media_type: String,
              pub mime_type: String,
              pub file_name: String,
              pub file_size: i64,
              pub width: Option<i32>,
              pub height: Option<i32>,
              pub duration_seconds: Option<i32>,
              pub sort_order: i32,
          }
          
          impl From<PostMedia> for PostMediaInfo {
              fn from(media: PostMedia) -> Self {
                  Self {
                      id: media.id,
                      post_id: media.post_id,
                      media_hash: media.media_hash,
                      media_type: media.media_type,
                      mime_type: media.mime_type,
                      file_name: media.file_name,
                      file_size: media.file_size,
                      width: media.width,
                      height: media.height,
                      duration_seconds: media.duration_seconds,
                      sort_order: media.sort_order,
                  }
              }
          }
          
          /// Create post result for the frontend
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct CreatePostResult {
              pub post_id: String,
              pub created_at: i64,
          }
          
          /// Create a new post
          #[tauri::command]
          pub async fn create_post(
              posts_service: State<'_, Arc<PostsService>>,
              content_type: String,
              content_text: Option<String>,
              visibility: Option<String>,
          ) -> Result<CreatePostResult, AppError> {
              let vis = match visibility.as_deref() {
                  Some("public") => PostVisibility::Public,
                  _ => PostVisibility::Contacts, // Default to contacts-only
              };
          
              let outgoing = posts_service.create_post(
                  &content_type,
                  content_text.as_deref(),
                  vis,
              )?;
          
              Ok(CreatePostResult {
                  post_id: outgoing.post_id,
                  created_at: outgoing.created_at,
              })
          }
          
          /// Update a post
          #[tauri::command]
          pub async fn update_post(
              posts_service: State<'_, Arc<PostsService>>,
              post_id: String,
              content_text: Option<String>,
          ) -> Result<(), AppError> {
              posts_service.update_post(&post_id, content_text.as_deref())?;
              Ok(())
          }
          
          /// Delete a post
          #[tauri::command]
          pub async fn delete_post(
              posts_service: State<'_, Arc<PostsService>>,
              post_id: String,
          ) -> Result<(), AppError> {
              posts_service.delete_post(&post_id)?;
              Ok(())
          }
          
          /// Get a single post by ID
          #[tauri::command]
          pub async fn get_post(
              posts_service: State<'_, Arc<PostsService>>,
              post_id: String,
          ) -> Result<Option<PostInfo>, AppError> {
              let post = posts_service.get_post(&post_id)?;
              Ok(post.map(PostInfo::from))
          }
          
          /// Get the local user's posts (their wall)
          #[tauri::command]
          pub async fn get_my_posts(
              posts_service: State<'_, Arc<PostsService>>,
              limit: Option<i64>,
              before_timestamp: Option<i64>,
          ) -> Result<Vec<PostInfo>, AppError> {
              let limit = limit.unwrap_or(50);
              let posts = posts_service.get_my_posts(limit, before_timestamp)?;
              Ok(posts.into_iter().map(PostInfo::from).collect())
          }
          
          /// Get posts by a specific author
          #[tauri::command]
          pub async fn get_posts_by_author(
              posts_service: State<'_, Arc<PostsService>>,
              author_peer_id: String,
              limit: Option<i64>,
              before_timestamp: Option<i64>,
          ) -> Result<Vec<PostInfo>, AppError> {
              let limit = limit.unwrap_or(50);
              let posts = posts_service.get_posts_by_author(&author_peer_id, limit, before_timestamp)?;
              Ok(posts.into_iter().map(PostInfo::from).collect())
          }
          
          /// Add media to a post
          #[tauri::command]
          pub async fn add_post_media(
              posts_service: State<'_, Arc<PostsService>>,
              post_id: String,
              media_hash: String,
              media_type: String,
              mime_type: String,
              file_name: String,
              file_size: i64,
              width: Option<i32>,
              height: Option<i32>,
              duration_seconds: Option<i32>,
              sort_order: Option<i32>,
          ) -> Result<(), AppError> {
              posts_service.add_media_to_post(
                  &post_id,
                  &media_hash,
                  &media_type,
                  &mime_type,
                  &file_name,
                  file_size,
                  width,
                  height,
                  duration_seconds,
                  sort_order.unwrap_or(0),
              )
          }
          
          /// Get media for a post
          #[tauri::command]
          pub async fn get_post_media(
              posts_service: State<'_, Arc<PostsService>>,
              post_id: String,
          ) -> Result<Vec<PostMediaInfo>, AppError> {
              let media = posts_service.get_post_media(&post_id)?;
              Ok(media.into_iter().map(PostMediaInfo::from).collect())
          }
          ```

      - ğŸ“ **db/**
        - ğŸ“„ **connection.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\db\connection.rs`
          *Size*: 18531 bytes | *Modified*: 2026-01-16 22:51:58

          ```
          use rusqlite::{Connection, Result as SqliteResult};
          use std::path::PathBuf;
          use std::sync::{Arc, Mutex};
          use tracing::info;
          
          const MIGRATION_001: &str = include_str!("migrations/001_initial.sql");
          const MIGRATION_002: &str = include_str!("migrations/002_schema_fixes.sql");
          const MIGRATION_003: &str = include_str!("migrations/003_lamport_sync_cursor.sql");
          const MIGRATION_004: &str = include_str!("migrations/004_messages_nonce.sql");
          
          /// Database wrapper for SQLite connection management
          pub struct Database {
              conn: Arc<Mutex<Connection>>,
              path: PathBuf,
          }
          
          impl Database {
              /// Create a new database connection at the given path
              pub fn new(path: PathBuf) -> SqliteResult<Self> {
                  // Ensure parent directory exists
                  if let Some(parent) = path.parent() {
                      std::fs::create_dir_all(parent).map_err(|_| {
                          rusqlite::Error::InvalidPath(path.clone().into())
                      })?;
                  }
          
                  let conn = Connection::open(&path)?;
          
                  // Enable foreign keys
                  conn.execute_batch("PRAGMA foreign_keys = ON;")?;
          
                  let db = Self {
                      conn: Arc::new(Mutex::new(conn)),
                      path,
                  };
          
                  // Run migrations
                  db.migrate()?;
          
                  info!("Database initialized at {:?}", db.path);
                  Ok(db)
              }
          
              /// Create an in-memory database (for testing)
              pub fn in_memory() -> SqliteResult<Self> {
                  let conn = Connection::open_in_memory()?;
                  conn.execute_batch("PRAGMA foreign_keys = ON;")?;
          
                  let db = Self {
                      conn: Arc::new(Mutex::new(conn)),
                      path: PathBuf::from(":memory:"),
                  };
          
                  db.migrate()?;
                  Ok(db)
              }
          
              /// Run database migrations
              fn migrate(&self) -> SqliteResult<()> {
                  let conn = self.conn.lock().unwrap();
          
                  // Check current schema version
                  let version: i32 = conn
                      .query_row(
                          "SELECT version FROM schema_version WHERE id = 1",
                          [],
                          |row| row.get(0),
                      )
                      .unwrap_or(0);
          
                  if version < 1 {
                      info!("Running migration 001...");
                      conn.execute_batch(MIGRATION_001)?;
                      info!("Migration 001 complete");
                  }
          
                  if version < 2 {
                      info!("Running migration 002...");
                      conn.execute_batch(MIGRATION_002)?;
                      info!("Migration 002 complete");
                  }
          
                  if version < 3 {
                      info!("Running migration 003...");
                      conn.execute_batch(MIGRATION_003)?;
                      info!("Migration 003 complete");
                  }
          
                  if version < 4 {
                      info!("Running migration 004...");
                      conn.execute_batch(MIGRATION_004)?;
                      info!("Migration 004 complete");
                  }
          
                  Ok(())
              }
          
              /// Execute a function with the database connection
              pub fn with_connection<F, T>(&self, f: F) -> SqliteResult<T>
              where
                  F: FnOnce(&Connection) -> SqliteResult<T>,
              {
                  let conn = self.conn.lock().unwrap();
                  f(&conn)
              }
          
              /// Execute a function with a mutable database connection (for transactions)
              pub fn with_connection_mut<F, T>(&self, f: F) -> SqliteResult<T>
              where
                  F: FnOnce(&mut Connection) -> SqliteResult<T>,
              {
                  let mut conn = self.conn.lock().unwrap();
                  f(&mut conn)
              }
          
              /// Get the database path
              pub fn path(&self) -> &PathBuf {
                  &self.path
              }
          
              /// Get the next lamport clock value for the given author and increment it
              pub fn next_lamport_clock(&self, author_peer_id: &str) -> SqliteResult<i64> {
                  self.with_connection_mut(|conn| {
                      let tx = conn.transaction()?;
          
                      // Get current value (or 0 if not exists)
                      let current: i64 = tx.query_row(
                          "SELECT current_value FROM lamport_clocks WHERE author_peer_id = ?",
                          [author_peer_id],
                          |row| row.get(0),
                      ).unwrap_or(0);
          
                      let next = current + 1;
          
                      // Upsert the new value
                      tx.execute(
                          "INSERT INTO lamport_clocks (author_peer_id, current_value) VALUES (?, ?)
                           ON CONFLICT(author_peer_id) DO UPDATE SET current_value = excluded.current_value",
                          rusqlite::params![author_peer_id, next],
                      )?;
          
                      tx.commit()?;
                      Ok(next)
                  })
              }
          
              /// Update lamport clock for author if received value is higher
              pub fn update_lamport_clock(&self, author_peer_id: &str, received: i64) -> SqliteResult<()> {
                  self.with_connection(|conn| {
                      conn.execute(
                          "INSERT INTO lamport_clocks (author_peer_id, current_value) VALUES (?, ?)
                           ON CONFLICT(author_peer_id) DO UPDATE SET current_value = MAX(current_value, excluded.current_value)",
                          rusqlite::params![author_peer_id, received],
                      )?;
                      Ok(())
                  })
              }
          
              /// Get the current lamport clock value for an author (without incrementing)
              pub fn get_lamport_clock(&self, author_peer_id: &str) -> SqliteResult<i64> {
                  self.with_connection(|conn| {
                      conn.query_row(
                          "SELECT current_value FROM lamport_clocks WHERE author_peer_id = ?",
                          [author_peer_id],
                          |row| row.get(0),
                      ).or(Ok(0))
                  })
              }
          
              /// Get and increment the send counter for a conversation (for nonce generation)
              pub fn next_send_counter(&self, conversation_id: &str) -> SqliteResult<u64> {
                  self.with_connection_mut(|conn| {
                      let tx = conn.transaction()?;
          
                      // Get current value (or 0 if not exists)
                      let current: u64 = tx.query_row(
                          "SELECT send_counter FROM conversation_counters WHERE conversation_id = ?",
                          [conversation_id],
                          |row| row.get(0),
                      ).unwrap_or(0);
          
                      let next = current + 1;
          
                      // Upsert the new value
                      tx.execute(
                          "INSERT INTO conversation_counters (conversation_id, send_counter, highest_received_counter) VALUES (?, ?, 0)
                           ON CONFLICT(conversation_id) DO UPDATE SET send_counter = excluded.send_counter",
                          rusqlite::params![conversation_id, next],
                      )?;
          
                      tx.commit()?;
                      Ok(next)
                  })
              }
          
              /// Check if a nonce has been seen and record it if not
              /// Returns true if the nonce is new (not replayed), false if it's a replay
              pub fn check_and_record_nonce(
                  &self,
                  conversation_id: &str,
                  sender_peer_id: &str,
                  nonce_counter: u64,
              ) -> SqliteResult<bool> {
                  self.with_connection_mut(|conn| {
                      let tx = conn.transaction()?;
          
                      // Try to insert the nonce
                      let result = tx.execute(
                          "INSERT INTO received_nonces (conversation_id, sender_peer_id, nonce_counter, received_at)
                           VALUES (?, ?, ?, ?)",
                          rusqlite::params![
                              conversation_id,
                              sender_peer_id,
                              nonce_counter as i64,
                              chrono::Utc::now().timestamp()
                          ],
                      );
          
                      match result {
                          Ok(_) => {
                              // Update highest received counter
                              tx.execute(
                                  "UPDATE conversation_counters
                                   SET highest_received_counter = MAX(highest_received_counter, ?)
                                   WHERE conversation_id = ?",
                                  rusqlite::params![nonce_counter as i64, conversation_id],
                              )?;
                              tx.commit()?;
                              Ok(true) // New nonce, not a replay
                          }
                          Err(rusqlite::Error::SqliteFailure(err, _))
                              if err.code == rusqlite::ErrorCode::ConstraintViolation =>
                          {
                              // Unique constraint violated - this nonce was already seen
                              Ok(false) // Replay detected
                          }
                          Err(e) => Err(e),
                      }
                  })
              }
          
              // ============================================================
              // Sync Cursor Functions (lamport-based)
              // ============================================================
          
              /// Get the sync cursor for a specific peer and sync type
              /// Returns a map of author_peer_id -> highest_lamport_clock
              pub fn get_sync_cursor(
                  &self,
                  source_peer_id: &str,
                  sync_type: &str,
              ) -> SqliteResult<std::collections::HashMap<String, u64>> {
                  self.with_connection(|conn| {
                      let mut stmt = conn.prepare(
                          "SELECT author_peer_id, highest_lamport_clock FROM sync_cursors
                           WHERE source_peer_id = ? AND sync_type = ?"
                      )?;
          
                      let rows = stmt.query_map(
                          rusqlite::params![source_peer_id, sync_type],
                          |row| {
                              let author: String = row.get(0)?;
                              let clock: i64 = row.get(1)?;
                              Ok((author, clock as u64))
                          },
                      )?;
          
                      let mut cursor = std::collections::HashMap::new();
                      for row in rows {
                          let (author, clock) = row?;
                          cursor.insert(author, clock);
                      }
                      Ok(cursor)
                  })
              }
          
              /// Update the sync cursor for a specific author
              /// Call this after successfully syncing content from an author
              pub fn update_sync_cursor(
                  &self,
                  source_peer_id: &str,
                  sync_type: &str,
                  author_peer_id: &str,
                  lamport_clock: u64,
              ) -> SqliteResult<()> {
                  self.with_connection(|conn| {
                      conn.execute(
                          "INSERT INTO sync_cursors (source_peer_id, sync_type, author_peer_id, highest_lamport_clock, last_sync_at)
                           VALUES (?, ?, ?, ?, ?)
                           ON CONFLICT(source_peer_id, sync_type, author_peer_id)
                           DO UPDATE SET
                               highest_lamport_clock = MAX(highest_lamport_clock, excluded.highest_lamport_clock),
                               last_sync_at = excluded.last_sync_at",
                          rusqlite::params![
                              source_peer_id,
                              sync_type,
                              author_peer_id,
                              lamport_clock as i64,
                              chrono::Utc::now().timestamp()
                          ],
                      )?;
                      Ok(())
                  })
              }
          
              /// Batch update sync cursors from a response
              pub fn update_sync_cursors_batch(
                  &self,
                  source_peer_id: &str,
                  sync_type: &str,
                  cursor_updates: &std::collections::HashMap<String, u64>,
              ) -> SqliteResult<()> {
                  self.with_connection_mut(|conn| {
                      let tx = conn.transaction()?;
                      let now = chrono::Utc::now().timestamp();
          
                      for (author_peer_id, lamport_clock) in cursor_updates {
                          tx.execute(
                              "INSERT INTO sync_cursors (source_peer_id, sync_type, author_peer_id, highest_lamport_clock, last_sync_at)
                               VALUES (?, ?, ?, ?, ?)
                               ON CONFLICT(source_peer_id, sync_type, author_peer_id)
                               DO UPDATE SET
                                   highest_lamport_clock = MAX(highest_lamport_clock, excluded.highest_lamport_clock),
                                   last_sync_at = excluded.last_sync_at",
                              rusqlite::params![
                                  source_peer_id,
                                  sync_type,
                                  author_peer_id,
                                  *lamport_clock as i64,
                                  now
                              ],
                          )?;
                      }
          
                      tx.commit()?;
                      Ok(())
                  })
              }
          
              /// Get last sync time for a peer
              pub fn get_last_sync_time(
                  &self,
                  source_peer_id: &str,
                  sync_type: &str,
              ) -> SqliteResult<Option<i64>> {
                  self.with_connection(|conn| {
                      conn.query_row(
                          "SELECT MAX(last_sync_at) FROM sync_cursors
                           WHERE source_peer_id = ? AND sync_type = ?",
                          rusqlite::params![source_peer_id, sync_type],
                          |row| row.get(0),
                      ).or(Ok(None))
                  })
              }
          }
          
          impl Clone for Database {
              fn clone(&self) -> Self {
                  Self {
                      conn: Arc::clone(&self.conn),
                      path: self.path.clone(),
                  }
              }
          }
          
          #[cfg(test)]
          mod tests {
              use super::*;
          
              #[test]
              fn test_database_creation() {
                  let db = Database::in_memory().unwrap();
          
                  // Verify tables exist
                  db.with_connection(|conn| {
                      let count: i32 = conn.query_row(
                          "SELECT COUNT(*) FROM sqlite_master WHERE type='table'",
                          [],
                          |row| row.get(0),
                      )?;
                      assert!(count > 0, "Tables should be created");
                      Ok(())
                  }).unwrap();
              }
          
              #[test]
              fn test_lamport_clock_per_author() {
                  let db = Database::in_memory().unwrap();
                  let author1 = "12D3KooWAuthor1";
                  let author2 = "12D3KooWAuthor2";
          
                  // Each author starts at 0 and increments independently
                  let clock1_a = db.next_lamport_clock(author1).unwrap();
                  let clock1_b = db.next_lamport_clock(author1).unwrap();
                  let clock2_a = db.next_lamport_clock(author2).unwrap();
                  let clock1_c = db.next_lamport_clock(author1).unwrap();
          
                  assert_eq!(clock1_a, 1);
                  assert_eq!(clock1_b, 2);
                  assert_eq!(clock2_a, 1); // Author 2 starts at 1
                  assert_eq!(clock1_c, 3);
              }
          
              #[test]
              fn test_lamport_clock_update() {
                  let db = Database::in_memory().unwrap();
                  let author = "12D3KooWAuthor1";
          
                  // Get initial value
                  let _ = db.next_lamport_clock(author).unwrap(); // 1
          
                  // Update with higher value from network
                  db.update_lamport_clock(author, 100).unwrap();
          
                  // Next should be 101
                  let next = db.next_lamport_clock(author).unwrap();
                  assert_eq!(next, 101);
              }
          
              #[test]
              fn test_send_counter() {
                  let db = Database::in_memory().unwrap();
                  let conv_id = "conversation123";
          
                  let counter1 = db.next_send_counter(conv_id).unwrap();
                  let counter2 = db.next_send_counter(conv_id).unwrap();
                  let counter3 = db.next_send_counter(conv_id).unwrap();
          
                  assert_eq!(counter1, 1);
                  assert_eq!(counter2, 2);
                  assert_eq!(counter3, 3);
              }
          
              #[test]
              fn test_nonce_replay_detection() {
                  let db = Database::in_memory().unwrap();
                  let conv_id = "conversation123";
                  let sender = "12D3KooWSender";
          
                  // First time seeing nonce 1 - should be accepted
                  assert!(db.check_and_record_nonce(conv_id, sender, 1).unwrap());
          
                  // Second time seeing nonce 1 - should be rejected (replay)
                  assert!(!db.check_and_record_nonce(conv_id, sender, 1).unwrap());
          
                  // Different nonce - should be accepted
                  assert!(db.check_and_record_nonce(conv_id, sender, 2).unwrap());
          
                  // Same nonce from different sender - should be accepted
                  assert!(db.check_and_record_nonce(conv_id, "12D3KooWOther", 1).unwrap());
              }
          
              #[test]
              fn test_sync_cursor_empty() {
                  let db = Database::in_memory().unwrap();
          
                  // Initially no cursor exists
                  let cursor = db.get_sync_cursor("12D3KooWPeer1", "posts").unwrap();
                  assert!(cursor.is_empty());
              }
          
              #[test]
              fn test_sync_cursor_update_and_get() {
                  let db = Database::in_memory().unwrap();
                  let source = "12D3KooWPeer1";
                  let author1 = "12D3KooWAuthor1";
                  let author2 = "12D3KooWAuthor2";
          
                  // Update cursor for author1
                  db.update_sync_cursor(source, "posts", author1, 10).unwrap();
          
                  // Update cursor for author2
                  db.update_sync_cursor(source, "posts", author2, 5).unwrap();
          
                  // Get cursor should return both
                  let cursor = db.get_sync_cursor(source, "posts").unwrap();
                  assert_eq!(cursor.len(), 2);
                  assert_eq!(cursor.get(author1), Some(&10));
                  assert_eq!(cursor.get(author2), Some(&5));
              }
          
              #[test]
              fn test_sync_cursor_only_increases() {
                  let db = Database::in_memory().unwrap();
                  let source = "12D3KooWPeer1";
                  let author = "12D3KooWAuthor1";
          
                  // Update to 10
                  db.update_sync_cursor(source, "posts", author, 10).unwrap();
          
                  // Try to "update" to 5 (lower) - should be ignored
                  db.update_sync_cursor(source, "posts", author, 5).unwrap();
          
                  // Cursor should still be 10
                  let cursor = db.get_sync_cursor(source, "posts").unwrap();
                  assert_eq!(cursor.get(author), Some(&10));
          
                  // Update to 15 (higher) - should work
                  db.update_sync_cursor(source, "posts", author, 15).unwrap();
                  let cursor = db.get_sync_cursor(source, "posts").unwrap();
                  assert_eq!(cursor.get(author), Some(&15));
              }
          
              #[test]
              fn test_sync_cursor_different_sync_types() {
                  let db = Database::in_memory().unwrap();
                  let source = "12D3KooWPeer1";
                  let author = "12D3KooWAuthor1";
          
                  // Update posts cursor
                  db.update_sync_cursor(source, "posts", author, 10).unwrap();
          
                  // Update permissions cursor (different type)
                  db.update_sync_cursor(source, "permissions", author, 5).unwrap();
          
                  // They should be separate
                  let posts_cursor = db.get_sync_cursor(source, "posts").unwrap();
                  let perms_cursor = db.get_sync_cursor(source, "permissions").unwrap();
          
                  assert_eq!(posts_cursor.get(author), Some(&10));
                  assert_eq!(perms_cursor.get(author), Some(&5));
              }
          
              #[test]
              fn test_sync_cursor_batch_update() {
                  use std::collections::HashMap;
          
                  let db = Database::in_memory().unwrap();
                  let source = "12D3KooWPeer1";
          
                  let mut updates = HashMap::new();
                  updates.insert("12D3KooWAuthor1".to_string(), 10u64);
                  updates.insert("12D3KooWAuthor2".to_string(), 20u64);
                  updates.insert("12D3KooWAuthor3".to_string(), 30u64);
          
                  db.update_sync_cursors_batch(source, "posts", &updates).unwrap();
          
                  let cursor = db.get_sync_cursor(source, "posts").unwrap();
                  assert_eq!(cursor.len(), 3);
                  assert_eq!(cursor.get("12D3KooWAuthor1"), Some(&10));
                  assert_eq!(cursor.get("12D3KooWAuthor2"), Some(&20));
                  assert_eq!(cursor.get("12D3KooWAuthor3"), Some(&30));
              }
          }
          ```

        - ğŸ“ **migrations/**
          - ğŸ“„ **001_initial.sql**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\migrations\001_initial.sql`
            *Size*: 7944 bytes | *Modified*: 2026-01-16 17:09:13

            ```
            -- ============================================================
            -- IDENTITY
            -- ============================================================
            CREATE TABLE IF NOT EXISTS local_identity (
                id INTEGER PRIMARY KEY CHECK (id = 1),
                peer_id TEXT NOT NULL UNIQUE,
                public_key BLOB NOT NULL,
                x25519_public BLOB NOT NULL,
                private_key_encrypted BLOB NOT NULL,
                display_name TEXT NOT NULL,
                avatar_hash TEXT,
                bio TEXT,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );
            
            -- ============================================================
            -- CONTACTS
            -- ============================================================
            CREATE TABLE IF NOT EXISTS contacts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                peer_id TEXT NOT NULL UNIQUE,
                public_key BLOB NOT NULL,
                x25519_public BLOB NOT NULL,
                display_name TEXT NOT NULL,
                avatar_hash TEXT,
                bio TEXT,
                is_blocked INTEGER DEFAULT 0,
                trust_level INTEGER DEFAULT 0,
                last_seen_at INTEGER,
                added_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_contacts_peer_id ON contacts(peer_id);
            
            -- ============================================================
            -- PERMISSIONS (event-sourced)
            -- ============================================================
            CREATE TABLE IF NOT EXISTS permission_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id TEXT NOT NULL UNIQUE,
                event_type TEXT NOT NULL,
                grant_id TEXT NOT NULL,
                issuer_peer_id TEXT NOT NULL,
                subject_peer_id TEXT NOT NULL,
                capability TEXT NOT NULL,
                scope_json TEXT,
                issued_at INTEGER,
                expires_at INTEGER,
                payload_cbor BLOB NOT NULL,
                signature BLOB NOT NULL,
                received_at INTEGER NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_perm_events_grant ON permission_events(grant_id);
            CREATE INDEX IF NOT EXISTS idx_perm_events_subject ON permission_events(subject_peer_id);
            
            -- Materialized view of current permissions
            CREATE TABLE IF NOT EXISTS permissions_current (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                grant_id TEXT NOT NULL UNIQUE,
                issuer_peer_id TEXT NOT NULL,
                subject_peer_id TEXT NOT NULL,
                capability TEXT NOT NULL,
                issued_at INTEGER NOT NULL,
                expires_at INTEGER,
                revoked_at INTEGER,
                payload_cbor BLOB NOT NULL,
                signature BLOB NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_perm_current_subject ON permissions_current(subject_peer_id, capability);
            CREATE INDEX IF NOT EXISTS idx_perm_current_issuer ON permissions_current(issuer_peer_id, capability);
            
            -- ============================================================
            -- MESSAGES (event-sourced)
            -- ============================================================
            CREATE TABLE IF NOT EXISTS message_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id TEXT NOT NULL UNIQUE,
                event_type TEXT NOT NULL,
                message_id TEXT NOT NULL,
                conversation_id TEXT NOT NULL,
                sender_peer_id TEXT NOT NULL,
                recipient_peer_id TEXT NOT NULL,
                lamport_clock INTEGER NOT NULL,
                timestamp INTEGER NOT NULL,
                payload_cbor BLOB,
                signature BLOB NOT NULL,
                received_at INTEGER NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_msg_events_message ON message_events(message_id);
            CREATE INDEX IF NOT EXISTS idx_msg_events_conv ON message_events(conversation_id, timestamp);
            
            -- Materialized messages for UI
            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                message_id TEXT NOT NULL UNIQUE,
                conversation_id TEXT NOT NULL,
                sender_peer_id TEXT NOT NULL,
                recipient_peer_id TEXT NOT NULL,
                content_encrypted BLOB NOT NULL,
                content_type TEXT DEFAULT 'text',
                reply_to_message_id TEXT,
                lamport_clock INTEGER NOT NULL,
                sent_at INTEGER NOT NULL,
                received_at INTEGER,
                delivered_at INTEGER,
                read_at INTEGER,
                status TEXT DEFAULT 'pending'
            );
            
            CREATE INDEX IF NOT EXISTS idx_messages_conv ON messages(conversation_id, sent_at);
            
            -- ============================================================
            -- POSTS (event-sourced)
            -- ============================================================
            CREATE TABLE IF NOT EXISTS post_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id TEXT NOT NULL UNIQUE,
                event_type TEXT NOT NULL,
                post_id TEXT NOT NULL,
                author_peer_id TEXT NOT NULL,
                lamport_clock INTEGER NOT NULL,
                timestamp INTEGER NOT NULL,
                payload_cbor BLOB,
                signature BLOB NOT NULL,
                received_at INTEGER NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_post_events_post ON post_events(post_id);
            
            -- Materialized posts for UI
            CREATE TABLE IF NOT EXISTS posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                post_id TEXT NOT NULL UNIQUE,
                author_peer_id TEXT NOT NULL,
                content_type TEXT NOT NULL,
                content_text TEXT,
                visibility TEXT DEFAULT 'contacts',
                lamport_clock INTEGER NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL,
                deleted_at INTEGER,
                is_local INTEGER DEFAULT 1,
                signature BLOB NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_posts_author ON posts(author_peer_id);
            CREATE INDEX IF NOT EXISTS idx_posts_created ON posts(created_at DESC);
            
            -- Post media (metadata only, files on disk)
            CREATE TABLE IF NOT EXISTS post_media (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                post_id TEXT NOT NULL,
                media_hash TEXT NOT NULL,
                media_type TEXT NOT NULL,
                mime_type TEXT NOT NULL,
                file_name TEXT NOT NULL,
                file_size INTEGER NOT NULL,
                width INTEGER,
                height INTEGER,
                duration_seconds INTEGER,
                sort_order INTEGER DEFAULT 0,
                FOREIGN KEY (post_id) REFERENCES posts(post_id) ON DELETE CASCADE
            );
            
            CREATE INDEX IF NOT EXISTS idx_post_media_post ON post_media(post_id);
            CREATE INDEX IF NOT EXISTS idx_post_media_hash ON post_media(media_hash);
            
            -- ============================================================
            -- SYNC STATE
            -- ============================================================
            CREATE TABLE IF NOT EXISTS sync_state (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                peer_id TEXT NOT NULL,
                sync_type TEXT NOT NULL,
                last_sync_at INTEGER,
                last_lamport_clock INTEGER DEFAULT 0,
                UNIQUE(peer_id, sync_type)
            );
            
            -- Offline message queue
            CREATE TABLE IF NOT EXISTS sync_queue (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target_peer_id TEXT NOT NULL,
                item_type TEXT NOT NULL,
                item_id TEXT NOT NULL,
                payload_cbor BLOB NOT NULL,
                priority INTEGER DEFAULT 5,
                attempts INTEGER DEFAULT 0,
                created_at INTEGER NOT NULL,
                next_attempt_at INTEGER NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_sync_queue_next ON sync_queue(next_attempt_at);
            
            -- ============================================================
            -- CALLS
            -- ============================================================
            CREATE TABLE IF NOT EXISTS call_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                call_id TEXT NOT NULL UNIQUE,
                peer_id TEXT NOT NULL,
                direction TEXT NOT NULL,
                status TEXT NOT NULL,
                started_at INTEGER,
                ended_at INTEGER,
                duration_seconds INTEGER
            );
            
            -- ============================================================
            -- SETTINGS
            -- ============================================================
            CREATE TABLE IF NOT EXISTS settings (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at INTEGER NOT NULL
            );
            
            -- ============================================================
            -- LAMPORT CLOCK
            -- ============================================================
            CREATE TABLE IF NOT EXISTS lamport_clock (
                id INTEGER PRIMARY KEY CHECK (id = 1),
                current_value INTEGER NOT NULL DEFAULT 0
            );
            
            INSERT OR IGNORE INTO lamport_clock (id, current_value) VALUES (1, 0);
            
            -- ============================================================
            -- SCHEMA VERSION
            -- ============================================================
            CREATE TABLE IF NOT EXISTS schema_version (
                id INTEGER PRIMARY KEY CHECK (id = 1),
                version INTEGER NOT NULL DEFAULT 1
            );
            
            INSERT OR IGNORE INTO schema_version (id, version) VALUES (1, 1);
            ```

          - ğŸ“„ **002_schema_fixes.sql**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\migrations\002_schema_fixes.sql`
            *Size*: 5431 bytes | *Modified*: 2026-01-16 17:59:43

            ```
            -- ============================================================
            -- Migration 002: Schema fixes based on review feedback
            -- ============================================================
            
            -- ============================================================
            -- FIX 1: Per-author lamport clocks instead of global
            -- ============================================================
            DROP TABLE IF EXISTS lamport_clock;
            
            CREATE TABLE IF NOT EXISTS lamport_clocks (
                author_peer_id TEXT PRIMARY KEY,
                current_value INTEGER NOT NULL DEFAULT 0
            );
            
            -- ============================================================
            -- FIX 2: Peer keys table for discovered (non-contact) peers
            -- ============================================================
            CREATE TABLE IF NOT EXISTS peer_keys (
                peer_id TEXT PRIMARY KEY,
                ed25519_public BLOB NOT NULL,
                x25519_public BLOB NOT NULL,
                display_name TEXT,
                avatar_hash TEXT,
                bio TEXT,
                identity_version TEXT,  -- hash of cbor identity doc for caching
                first_seen_at INTEGER NOT NULL,
                last_seen_at INTEGER NOT NULL
            );
            
            CREATE INDEX IF NOT EXISTS idx_peer_keys_last_seen ON peer_keys(last_seen_at);
            
            -- ============================================================
            -- FIX 3: Add author_peer_id consistently to event tables
            -- ============================================================
            
            -- message_events already has sender_peer_id, add explicit author_peer_id
            ALTER TABLE message_events ADD COLUMN author_peer_id TEXT;
            -- For existing rows, set author_peer_id = sender_peer_id for 'sent' events
            -- This will be handled in code for new entries
            
            -- permission_events: add author_peer_id (the one who authored this event)
            ALTER TABLE permission_events ADD COLUMN author_peer_id TEXT;
            -- For request events: author = requester (subject_peer_id)
            -- For grant/revoke events: author = issuer (issuer_peer_id)
            
            -- ============================================================
            -- FIX 4: Fix permission_events grant_id to allow NULL for requests
            -- ============================================================
            -- SQLite doesn't support modifying columns, so we create a new table
            CREATE TABLE IF NOT EXISTS permission_events_new (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id TEXT NOT NULL UNIQUE,
                event_type TEXT NOT NULL,  -- 'request', 'grant', 'revoke'
                entity_id TEXT NOT NULL,   -- request_id for requests, grant_id for grant/revoke
                author_peer_id TEXT NOT NULL,
                issuer_peer_id TEXT,       -- NULL for request events
                subject_peer_id TEXT NOT NULL,
                capability TEXT NOT NULL,
                scope_json TEXT,
                lamport_clock INTEGER NOT NULL,
                issued_at INTEGER,
                expires_at INTEGER,
                payload_cbor BLOB NOT NULL,
                signature BLOB NOT NULL,
                received_at INTEGER NOT NULL
            );
            
            -- Migrate data (if any exists)
            INSERT INTO permission_events_new (
                id, event_id, event_type, entity_id, author_peer_id,
                issuer_peer_id, subject_peer_id, capability, scope_json,
                lamport_clock, issued_at, expires_at, payload_cbor, signature, received_at
            )
            SELECT
                id, event_id, event_type, grant_id,
                CASE WHEN event_type = 'request' THEN subject_peer_id ELSE issuer_peer_id END,
                issuer_peer_id, subject_peer_id, capability, scope_json,
                0, -- default lamport_clock for migrated rows
                issued_at, expires_at, payload_cbor, signature, received_at
            FROM permission_events;
            
            DROP TABLE IF EXISTS permission_events;
            ALTER TABLE permission_events_new RENAME TO permission_events;
            
            CREATE INDEX IF NOT EXISTS idx_perm_events_entity ON permission_events(entity_id);
            CREATE INDEX IF NOT EXISTS idx_perm_events_subject ON permission_events(subject_peer_id);
            CREATE INDEX IF NOT EXISTS idx_perm_events_author ON permission_events(author_peer_id, lamport_clock);
            
            -- ============================================================
            -- FIX 5: Add deduplication constraint
            -- ============================================================
            CREATE UNIQUE INDEX IF NOT EXISTS idx_post_events_dedup
                ON post_events(author_peer_id, post_id, lamport_clock);
            
            CREATE UNIQUE INDEX IF NOT EXISTS idx_msg_events_dedup
                ON message_events(author_peer_id, message_id, lamport_clock);
            
            -- ============================================================
            -- FIX 6: Per-conversation encryption counters (nonce management)
            -- ============================================================
            CREATE TABLE IF NOT EXISTS conversation_counters (
                conversation_id TEXT PRIMARY KEY,
                send_counter INTEGER NOT NULL DEFAULT 0,
                highest_received_counter INTEGER NOT NULL DEFAULT 0
            );
            
            -- Track received nonces to prevent replay
            CREATE TABLE IF NOT EXISTS received_nonces (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                conversation_id TEXT NOT NULL,
                sender_peer_id TEXT NOT NULL,
                nonce_counter INTEGER NOT NULL,
                received_at INTEGER NOT NULL,
                UNIQUE(conversation_id, sender_peer_id, nonce_counter)
            );
            
            CREATE INDEX IF NOT EXISTS idx_received_nonces_conv
                ON received_nonces(conversation_id, sender_peer_id);
            
            -- ============================================================
            -- FIX 7: Message events split - add ack_sender_peer_id for status events
            -- ============================================================
            ALTER TABLE message_events ADD COLUMN ack_sender_peer_id TEXT;
            
            -- ============================================================
            -- Update schema version
            -- ============================================================
            UPDATE schema_version SET version = 2 WHERE id = 1;
            ```

          - ğŸ“„ **003_lamport_sync_cursor.sql**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\migrations\003_lamport_sync_cursor.sql`
            *Size*: 1598 bytes | *Modified*: 2026-01-16 18:24:57

            ```
            -- ============================================================
            -- Migration 003: Lamport-based sync cursor
            -- ============================================================
            -- Replace timestamp-based sync with lamport-based cursor.
            -- This ensures no events are missed due to clock skew between peers.
            
            -- ============================================================
            -- FIX 1: Replace sync_state with lamport cursor table
            -- ============================================================
            DROP TABLE IF EXISTS sync_state;
            
            -- Sync cursor tracks lamport clock per author per peer
            -- This allows efficient resumable sync without missing events
            CREATE TABLE IF NOT EXISTS sync_cursors (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                -- Peer we're syncing content FROM
                source_peer_id TEXT NOT NULL,
                -- Type of content being synced
                sync_type TEXT NOT NULL,  -- 'posts', 'permissions'
                -- Author whose content we're tracking
                author_peer_id TEXT NOT NULL,
                -- Highest lamport clock seen from this author
                highest_lamport_clock INTEGER NOT NULL DEFAULT 0,
                -- When we last synced with this peer
                last_sync_at INTEGER NOT NULL,
                UNIQUE(source_peer_id, sync_type, author_peer_id)
            );
            
            CREATE INDEX IF NOT EXISTS idx_sync_cursors_source
                ON sync_cursors(source_peer_id, sync_type);
            
            CREATE INDEX IF NOT EXISTS idx_sync_cursors_author
                ON sync_cursors(author_peer_id);
            
            -- ============================================================
            -- Update schema version
            -- ============================================================
            UPDATE schema_version SET version = 3 WHERE id = 1;
            ```

          - ğŸ“„ **004_messages_nonce.sql**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\migrations\004_messages_nonce.sql`
            *Size*: 211 bytes | *Modified*: 2026-01-16 22:51:34

            ```
            -- Add nonce_counter column to messages table for replay protection
            ALTER TABLE messages ADD COLUMN nonce_counter INTEGER DEFAULT 0;
            
            -- Update schema version
            UPDATE schema_version SET version = 4 WHERE id = 1;
            ```

        - ğŸ“„ **mod.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\db\mod.rs`
          *Size*: 379 bytes | *Modified*: 2026-01-16 23:45:07

          ```
          pub mod connection;
          pub mod repositories;
          
          pub use connection::Database;
          pub use repositories::{
              Contact, ContactData, ContactsRepository,
              Capability, GrantData, Permission, PermissionEvent, PermissionsRepository,
              Conversation, Message, MessageData, MessageStatus, MessagesRepository,
              Post, PostData, PostMedia, PostMediaData, PostVisibility, PostsRepository,
          };
          ```

        - ğŸ“ **repositories/**
          - ğŸ“„ **contacts_repo.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\repositories\contacts_repo.rs`
            *Size*: 12532 bytes | *Modified*: 2026-01-16 21:29:40

            ```
            //! Contact repository for managing peer contacts
            
            use rusqlite::{params, OptionalExtension, Result as SqliteResult};
            use crate::db::Database;
            
            /// Represents a contact in the database
            #[derive(Debug, Clone)]
            pub struct Contact {
                pub id: i64,
                pub peer_id: String,
                pub public_key: Vec<u8>,
                pub x25519_public: Vec<u8>,
                pub display_name: String,
                pub avatar_hash: Option<String>,
                pub bio: Option<String>,
                pub is_blocked: bool,
                pub trust_level: i32,
                pub last_seen_at: Option<i64>,
                pub added_at: i64,
                pub updated_at: i64,
            }
            
            /// Contact data for creating or updating contacts
            #[derive(Debug, Clone)]
            pub struct ContactData {
                pub peer_id: String,
                pub public_key: Vec<u8>,
                pub x25519_public: Vec<u8>,
                pub display_name: String,
                pub avatar_hash: Option<String>,
                pub bio: Option<String>,
            }
            
            /// Repository for contact operations
            pub struct ContactsRepository;
            
            impl ContactsRepository {
                /// Add a new contact
                pub fn add_contact(db: &Database, contact: &ContactData) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        conn.execute(
                            "INSERT INTO contacts (peer_id, public_key, x25519_public, display_name, avatar_hash, bio, added_at, updated_at)
                             VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                contact.peer_id,
                                contact.public_key,
                                contact.x25519_public,
                                contact.display_name,
                                contact.avatar_hash,
                                contact.bio,
                                now,
                                now
                            ],
                        )?;
                        Ok(conn.last_insert_rowid())
                    })
                }
            
                /// Get a contact by peer ID
                pub fn get_by_peer_id(db: &Database, peer_id: &str) -> SqliteResult<Option<Contact>> {
                    db.with_connection(|conn| {
                        conn.query_row(
                            "SELECT id, peer_id, public_key, x25519_public, display_name, avatar_hash, bio,
                                    is_blocked, trust_level, last_seen_at, added_at, updated_at
                             FROM contacts WHERE peer_id = ?",
                            [peer_id],
                            |row| {
                                Ok(Contact {
                                    id: row.get(0)?,
                                    peer_id: row.get(1)?,
                                    public_key: row.get(2)?,
                                    x25519_public: row.get(3)?,
                                    display_name: row.get(4)?,
                                    avatar_hash: row.get(5)?,
                                    bio: row.get(6)?,
                                    is_blocked: row.get::<_, i32>(7)? != 0,
                                    trust_level: row.get(8)?,
                                    last_seen_at: row.get(9)?,
                                    added_at: row.get(10)?,
                                    updated_at: row.get(11)?,
                                })
                            },
                        )
                        .optional()
                    })
                }
            
                /// Get all contacts
                pub fn get_all(db: &Database) -> SqliteResult<Vec<Contact>> {
                    db.with_connection(|conn| {
                        let mut stmt = conn.prepare(
                            "SELECT id, peer_id, public_key, x25519_public, display_name, avatar_hash, bio,
                                    is_blocked, trust_level, last_seen_at, added_at, updated_at
                             FROM contacts
                             ORDER BY display_name ASC"
                        )?;
            
                        let contacts = stmt.query_map([], |row| {
                            Ok(Contact {
                                id: row.get(0)?,
                                peer_id: row.get(1)?,
                                public_key: row.get(2)?,
                                x25519_public: row.get(3)?,
                                display_name: row.get(4)?,
                                avatar_hash: row.get(5)?,
                                bio: row.get(6)?,
                                is_blocked: row.get::<_, i32>(7)? != 0,
                                trust_level: row.get(8)?,
                                last_seen_at: row.get(9)?,
                                added_at: row.get(10)?,
                                updated_at: row.get(11)?,
                            })
                        })?;
            
                        contacts.collect()
                    })
                }
            
                /// Get all non-blocked contacts
                pub fn get_active(db: &Database) -> SqliteResult<Vec<Contact>> {
                    db.with_connection(|conn| {
                        let mut stmt = conn.prepare(
                            "SELECT id, peer_id, public_key, x25519_public, display_name, avatar_hash, bio,
                                    is_blocked, trust_level, last_seen_at, added_at, updated_at
                             FROM contacts
                             WHERE is_blocked = 0
                             ORDER BY display_name ASC"
                        )?;
            
                        let contacts = stmt.query_map([], |row| {
                            Ok(Contact {
                                id: row.get(0)?,
                                peer_id: row.get(1)?,
                                public_key: row.get(2)?,
                                x25519_public: row.get(3)?,
                                display_name: row.get(4)?,
                                avatar_hash: row.get(5)?,
                                bio: row.get(6)?,
                                is_blocked: row.get::<_, i32>(7)? != 0,
                                trust_level: row.get(8)?,
                                last_seen_at: row.get(9)?,
                                added_at: row.get(10)?,
                                updated_at: row.get(11)?,
                            })
                        })?;
            
                        contacts.collect()
                    })
                }
            
                /// Update contact info (from identity exchange)
                pub fn update_contact_info(
                    db: &Database,
                    peer_id: &str,
                    display_name: &str,
                    avatar_hash: Option<&str>,
                    bio: Option<&str>,
                ) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let rows = conn.execute(
                            "UPDATE contacts SET display_name = ?, avatar_hash = ?, bio = ?, updated_at = ?
                             WHERE peer_id = ?",
                            params![display_name, avatar_hash, bio, now, peer_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Update last seen timestamp
                pub fn update_last_seen(db: &Database, peer_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let rows = conn.execute(
                            "UPDATE contacts SET last_seen_at = ?, updated_at = ? WHERE peer_id = ?",
                            params![now, now, peer_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Block a contact
                pub fn block_contact(db: &Database, peer_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let rows = conn.execute(
                            "UPDATE contacts SET is_blocked = 1, updated_at = ? WHERE peer_id = ?",
                            params![now, peer_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Unblock a contact
                pub fn unblock_contact(db: &Database, peer_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let rows = conn.execute(
                            "UPDATE contacts SET is_blocked = 0, updated_at = ? WHERE peer_id = ?",
                            params![now, peer_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Update trust level
                pub fn set_trust_level(db: &Database, peer_id: &str, trust_level: i32) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let rows = conn.execute(
                            "UPDATE contacts SET trust_level = ?, updated_at = ? WHERE peer_id = ?",
                            params![trust_level, now, peer_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Remove a contact
                pub fn remove_contact(db: &Database, peer_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "DELETE FROM contacts WHERE peer_id = ?",
                            [peer_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Check if peer is a contact
                pub fn is_contact(db: &Database, peer_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let count: i32 = conn.query_row(
                            "SELECT COUNT(*) FROM contacts WHERE peer_id = ?",
                            [peer_id],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            
                /// Check if peer is blocked
                pub fn is_blocked(db: &Database, peer_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let blocked: Option<i32> = conn
                            .query_row(
                                "SELECT is_blocked FROM contacts WHERE peer_id = ?",
                                [peer_id],
                                |row| row.get(0),
                            )
                            .optional()?;
                        Ok(blocked.unwrap_or(0) != 0)
                    })
                }
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
            
                #[test]
                fn test_add_and_get_contact() {
                    let db = Database::in_memory().unwrap();
            
                    let contact_data = ContactData {
                        peer_id: "12D3KooWTest".to_string(),
                        public_key: vec![1, 2, 3, 4],
                        x25519_public: vec![5, 6, 7, 8],
                        display_name: "Test User".to_string(),
                        avatar_hash: None,
                        bio: Some("Hello!".to_string()),
                    };
            
                    let id = ContactsRepository::add_contact(&db, &contact_data).unwrap();
                    assert!(id > 0);
            
                    let contact = ContactsRepository::get_by_peer_id(&db, "12D3KooWTest")
                        .unwrap()
                        .expect("Contact should exist");
            
                    assert_eq!(contact.peer_id, "12D3KooWTest");
                    assert_eq!(contact.display_name, "Test User");
                    assert_eq!(contact.bio, Some("Hello!".to_string()));
                    assert!(!contact.is_blocked);
                }
            
                #[test]
                fn test_block_unblock_contact() {
                    let db = Database::in_memory().unwrap();
            
                    let contact_data = ContactData {
                        peer_id: "12D3KooWTest".to_string(),
                        public_key: vec![1, 2, 3, 4],
                        x25519_public: vec![5, 6, 7, 8],
                        display_name: "Test User".to_string(),
                        avatar_hash: None,
                        bio: None,
                    };
            
                    ContactsRepository::add_contact(&db, &contact_data).unwrap();
            
                    // Initially not blocked
                    assert!(!ContactsRepository::is_blocked(&db, "12D3KooWTest").unwrap());
            
                    // Block
                    ContactsRepository::block_contact(&db, "12D3KooWTest").unwrap();
                    assert!(ContactsRepository::is_blocked(&db, "12D3KooWTest").unwrap());
            
                    // Unblock
                    ContactsRepository::unblock_contact(&db, "12D3KooWTest").unwrap();
                    assert!(!ContactsRepository::is_blocked(&db, "12D3KooWTest").unwrap());
                }
            
                #[test]
                fn test_get_active_contacts() {
                    let db = Database::in_memory().unwrap();
            
                    // Add two contacts
                    ContactsRepository::add_contact(&db, &ContactData {
                        peer_id: "12D3KooWActive".to_string(),
                        public_key: vec![1],
                        x25519_public: vec![2],
                        display_name: "Active".to_string(),
                        avatar_hash: None,
                        bio: None,
                    }).unwrap();
            
                    ContactsRepository::add_contact(&db, &ContactData {
                        peer_id: "12D3KooWBlocked".to_string(),
                        public_key: vec![3],
                        x25519_public: vec![4],
                        display_name: "Blocked".to_string(),
                        avatar_hash: None,
                        bio: None,
                    }).unwrap();
            
                    // Block one
                    ContactsRepository::block_contact(&db, "12D3KooWBlocked").unwrap();
            
                    // Get active should only return non-blocked
                    let active = ContactsRepository::get_active(&db).unwrap();
                    assert_eq!(active.len(), 1);
                    assert_eq!(active[0].peer_id, "12D3KooWActive");
            
                    // Get all should return both
                    let all = ContactsRepository::get_all(&db).unwrap();
                    assert_eq!(all.len(), 2);
                }
            
                #[test]
                fn test_remove_contact() {
                    let db = Database::in_memory().unwrap();
            
                    ContactsRepository::add_contact(&db, &ContactData {
                        peer_id: "12D3KooWTest".to_string(),
                        public_key: vec![1],
                        x25519_public: vec![2],
                        display_name: "Test".to_string(),
                        avatar_hash: None,
                        bio: None,
                    }).unwrap();
            
                    assert!(ContactsRepository::is_contact(&db, "12D3KooWTest").unwrap());
            
                    ContactsRepository::remove_contact(&db, "12D3KooWTest").unwrap();
            
                    assert!(!ContactsRepository::is_contact(&db, "12D3KooWTest").unwrap());
                }
            }
            ```

          - ğŸ“„ **identity_repo.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\repositories\identity_repo.rs`
            *Size*: 5600 bytes | *Modified*: 2026-01-16 17:10:13

            ```
            use crate::db::Database;
            use crate::models::identity::LocalIdentity;
            use rusqlite::{params, Result as SqliteResult};
            use tracing::info;
            
            /// Repository for local identity operations
            pub struct IdentityRepository<'a> {
                db: &'a Database,
            }
            
            impl<'a> IdentityRepository<'a> {
                pub fn new(db: &'a Database) -> Self {
                    Self { db }
                }
            
                /// Check if a local identity exists
                pub fn exists(&self) -> SqliteResult<bool> {
                    self.db.with_connection(|conn| {
                        let count: i32 = conn.query_row(
                            "SELECT COUNT(*) FROM local_identity WHERE id = 1",
                            [],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            
                /// Get the local identity
                pub fn get(&self) -> SqliteResult<Option<LocalIdentity>> {
                    self.db.with_connection(|conn| {
                        let mut stmt = conn.prepare(
                            "SELECT peer_id, public_key, x25519_public, private_key_encrypted,
                                    display_name, avatar_hash, bio, created_at, updated_at
                             FROM local_identity WHERE id = 1"
                        )?;
            
                        let result = stmt.query_row([], |row| {
                            Ok(LocalIdentity {
                                peer_id: row.get(0)?,
                                public_key: row.get(1)?,
                                x25519_public: row.get(2)?,
                                private_key_encrypted: row.get(3)?,
                                display_name: row.get(4)?,
                                avatar_hash: row.get(5)?,
                                bio: row.get(6)?,
                                created_at: row.get(7)?,
                                updated_at: row.get(8)?,
                            })
                        });
            
                        match result {
                            Ok(identity) => Ok(Some(identity)),
                            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
                            Err(e) => Err(e),
                        }
                    })
                }
            
                /// Create a new local identity
                pub fn create(&self, identity: &LocalIdentity) -> SqliteResult<()> {
                    self.db.with_connection(|conn| {
                        conn.execute(
                            "INSERT INTO local_identity
                             (id, peer_id, public_key, x25519_public, private_key_encrypted,
                              display_name, avatar_hash, bio, created_at, updated_at)
                             VALUES (1, ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)",
                            params![
                                identity.peer_id,
                                identity.public_key,
                                identity.x25519_public,
                                identity.private_key_encrypted,
                                identity.display_name,
                                identity.avatar_hash,
                                identity.bio,
                                identity.created_at,
                                identity.updated_at,
                            ],
                        )?;
                        info!("Created local identity: {}", identity.peer_id);
                        Ok(())
                    })
                }
            
                /// Update display name
                pub fn update_display_name(&self, display_name: &str) -> SqliteResult<()> {
                    let now = chrono::Utc::now().timestamp();
                    self.db.with_connection(|conn| {
                        conn.execute(
                            "UPDATE local_identity SET display_name = ?1, updated_at = ?2 WHERE id = 1",
                            params![display_name, now],
                        )?;
                        Ok(())
                    })
                }
            
                /// Update bio
                pub fn update_bio(&self, bio: Option<&str>) -> SqliteResult<()> {
                    let now = chrono::Utc::now().timestamp();
                    self.db.with_connection(|conn| {
                        conn.execute(
                            "UPDATE local_identity SET bio = ?1, updated_at = ?2 WHERE id = 1",
                            params![bio, now],
                        )?;
                        Ok(())
                    })
                }
            
                /// Update avatar hash
                pub fn update_avatar(&self, avatar_hash: Option<&str>) -> SqliteResult<()> {
                    let now = chrono::Utc::now().timestamp();
                    self.db.with_connection(|conn| {
                        conn.execute(
                            "UPDATE local_identity SET avatar_hash = ?1, updated_at = ?2 WHERE id = 1",
                            params![avatar_hash, now],
                        )?;
                        Ok(())
                    })
                }
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
            
                fn create_test_identity() -> LocalIdentity {
                    LocalIdentity {
                        peer_id: "12D3KooWTestPeerId".to_string(),
                        public_key: vec![1, 2, 3, 4],
                        x25519_public: vec![5, 6, 7, 8],
                        private_key_encrypted: vec![9, 10, 11, 12],
                        display_name: "Test User".to_string(),
                        avatar_hash: None,
                        bio: Some("Test bio".to_string()),
                        created_at: 1000,
                        updated_at: 1000,
                    }
                }
            
                #[test]
                fn test_identity_crud() {
                    let db = Database::in_memory().unwrap();
                    let repo = IdentityRepository::new(&db);
            
                    // Initially no identity
                    assert!(!repo.exists().unwrap());
                    assert!(repo.get().unwrap().is_none());
            
                    // Create identity
                    let identity = create_test_identity();
                    repo.create(&identity).unwrap();
            
                    // Now exists
                    assert!(repo.exists().unwrap());
            
                    // Can retrieve
                    let retrieved = repo.get().unwrap().unwrap();
                    assert_eq!(retrieved.peer_id, identity.peer_id);
                    assert_eq!(retrieved.display_name, identity.display_name);
                }
            
                #[test]
                fn test_update_display_name() {
                    let db = Database::in_memory().unwrap();
                    let repo = IdentityRepository::new(&db);
            
                    repo.create(&create_test_identity()).unwrap();
                    repo.update_display_name("New Name").unwrap();
            
                    let identity = repo.get().unwrap().unwrap();
                    assert_eq!(identity.display_name, "New Name");
                }
            }
            ```

          - ğŸ“„ **messages_repo.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\repositories\messages_repo.rs`
            *Size*: 19130 bytes | *Modified*: 2026-01-18 08:43:12

            ```
            //! Messages repository for storing and retrieving direct messages
            
            use rusqlite::{params, Connection, Result as SqliteResult};
            use crate::db::Database;
            
            /// Message status
            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            pub enum MessageStatus {
                Pending,
                Sent,
                Delivered,
                Read,
                Failed,
            }
            
            impl MessageStatus {
                pub fn as_str(&self) -> &'static str {
                    match self {
                        MessageStatus::Pending => "pending",
                        MessageStatus::Sent => "sent",
                        MessageStatus::Delivered => "delivered",
                        MessageStatus::Read => "read",
                        MessageStatus::Failed => "failed",
                    }
                }
            
                pub fn from_str(s: &str) -> Option<Self> {
                    match s {
                        "pending" => Some(MessageStatus::Pending),
                        "sent" => Some(MessageStatus::Sent),
                        "delivered" => Some(MessageStatus::Delivered),
                        "read" => Some(MessageStatus::Read),
                        "failed" => Some(MessageStatus::Failed),
                        _ => None,
                    }
                }
            }
            
            /// A stored message
            #[derive(Debug, Clone)]
            pub struct Message {
                pub id: i64,
                pub message_id: String,
                pub conversation_id: String,
                pub sender_peer_id: String,
                pub recipient_peer_id: String,
                pub content_encrypted: Vec<u8>,
                pub content_type: String,
                pub reply_to_message_id: Option<String>,
                pub nonce_counter: u64,
                pub lamport_clock: i64,
                pub sent_at: i64,
                pub received_at: Option<i64>,
                pub delivered_at: Option<i64>,
                pub read_at: Option<i64>,
                pub status: String,
            }
            
            /// Data for inserting a new message
            #[derive(Debug, Clone)]
            pub struct MessageData {
                pub message_id: String,
                pub conversation_id: String,
                pub sender_peer_id: String,
                pub recipient_peer_id: String,
                pub content_encrypted: Vec<u8>,
                pub content_type: String,
                pub reply_to_message_id: Option<String>,
                pub nonce_counter: u64,
                pub lamport_clock: i64,
                pub sent_at: i64,
                pub received_at: Option<i64>,
                pub status: MessageStatus,
            }
            
            /// A conversation summary
            #[derive(Debug, Clone)]
            pub struct Conversation {
                pub conversation_id: String,
                pub peer_id: String,
                pub last_message_at: i64,
                pub last_message_preview: Option<String>,
                pub unread_count: i64,
            }
            
            /// Repository for message operations
            pub struct MessagesRepository;
            
            impl MessagesRepository {
                /// Insert a new message
                pub fn insert_message(db: &Database, msg: &MessageData) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        conn.execute(
                            "INSERT INTO messages (
                                message_id, conversation_id, sender_peer_id, recipient_peer_id,
                                content_encrypted, content_type, reply_to_message_id, nonce_counter,
                                lamport_clock, sent_at, received_at, status
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                msg.message_id,
                                msg.conversation_id,
                                msg.sender_peer_id,
                                msg.recipient_peer_id,
                                msg.content_encrypted,
                                msg.content_type,
                                msg.reply_to_message_id,
                                msg.nonce_counter as i64,
                                msg.lamport_clock,
                                msg.sent_at,
                                msg.received_at,
                                msg.status.as_str(),
                            ],
                        )?;
                        Ok(conn.last_insert_rowid())
                    })
                }
            
                /// Get a message by ID
                pub fn get_by_message_id(db: &Database, message_id: &str) -> SqliteResult<Option<Message>> {
                    db.with_connection(|conn| {
                        Self::get_by_message_id_inner(conn, message_id)
                    })
                }
            
                fn get_by_message_id_inner(conn: &Connection, message_id: &str) -> SqliteResult<Option<Message>> {
                    let mut stmt = conn.prepare(
                        "SELECT id, message_id, conversation_id, sender_peer_id, recipient_peer_id,
                                content_encrypted, content_type, reply_to_message_id, nonce_counter,
                                lamport_clock, sent_at, received_at, delivered_at, read_at, status
                         FROM messages WHERE message_id = ?"
                    )?;
            
                    let mut rows = stmt.query([message_id])?;
            
                    if let Some(row) = rows.next()? {
                        Ok(Some(Message {
                            id: row.get(0)?,
                            message_id: row.get(1)?,
                            conversation_id: row.get(2)?,
                            sender_peer_id: row.get(3)?,
                            recipient_peer_id: row.get(4)?,
                            content_encrypted: row.get(5)?,
                            content_type: row.get(6)?,
                            reply_to_message_id: row.get(7)?,
                            nonce_counter: row.get::<_, i64>(8)? as u64,
                            lamport_clock: row.get(9)?,
                            sent_at: row.get(10)?,
                            received_at: row.get(11)?,
                            delivered_at: row.get(12)?,
                            read_at: row.get(13)?,
                            status: row.get(14)?,
                        }))
                    } else {
                        Ok(None)
                    }
                }
            
                /// Get messages for a conversation
                pub fn get_conversation_messages(
                    db: &Database,
                    conversation_id: &str,
                    limit: i64,
                    before_timestamp: Option<i64>,
                ) -> SqliteResult<Vec<Message>> {
                    db.with_connection(|conn| {
                        // For pagination, we need to get the N most recent messages, then sort them ASC for display
                        // When paginating (before_timestamp provided), get messages before that time
                        let query = if before_timestamp.is_some() {
                            "SELECT id, message_id, conversation_id, sender_peer_id, recipient_peer_id,
                                    content_encrypted, content_type, reply_to_message_id, nonce_counter,
                                    lamport_clock, sent_at, received_at, delivered_at, read_at, status
                             FROM (
                               SELECT * FROM messages
                               WHERE conversation_id = ? AND sent_at < ?
                               ORDER BY sent_at DESC
                               LIMIT ?
                             ) ORDER BY sent_at ASC"
                        } else {
                            "SELECT id, message_id, conversation_id, sender_peer_id, recipient_peer_id,
                                    content_encrypted, content_type, reply_to_message_id, nonce_counter,
                                    lamport_clock, sent_at, received_at, delivered_at, read_at, status
                             FROM (
                               SELECT * FROM messages
                               WHERE conversation_id = ?
                               ORDER BY sent_at DESC
                               LIMIT ?
                             ) ORDER BY sent_at ASC"
                        };
            
                        let mut stmt = conn.prepare(query)?;
            
                        let rows = if let Some(before) = before_timestamp {
                            stmt.query_map(params![conversation_id, before, limit], Self::row_to_message)?
                        } else {
                            stmt.query_map(params![conversation_id, limit], Self::row_to_message)?
                        };
            
                        rows.collect()
                    })
                }
            
                fn row_to_message(row: &rusqlite::Row) -> SqliteResult<Message> {
                    Ok(Message {
                        id: row.get(0)?,
                        message_id: row.get(1)?,
                        conversation_id: row.get(2)?,
                        sender_peer_id: row.get(3)?,
                        recipient_peer_id: row.get(4)?,
                        content_encrypted: row.get(5)?,
                        content_type: row.get(6)?,
                        reply_to_message_id: row.get(7)?,
                        nonce_counter: row.get::<_, i64>(8)? as u64,
                        lamport_clock: row.get(9)?,
                        sent_at: row.get(10)?,
                        received_at: row.get(11)?,
                        delivered_at: row.get(12)?,
                        read_at: row.get(13)?,
                        status: row.get(14)?,
                    })
                }
            
                /// Update message status
                pub fn update_status(
                    db: &Database,
                    message_id: &str,
                    status: MessageStatus,
                ) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "UPDATE messages SET status = ? WHERE message_id = ?",
                            params![status.as_str(), message_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Mark message as delivered
                pub fn mark_delivered(db: &Database, message_id: &str, timestamp: i64) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "UPDATE messages SET status = 'delivered', delivered_at = ?
                             WHERE message_id = ? AND status IN ('pending', 'sent')",
                            params![timestamp, message_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Mark message as read
                pub fn mark_read(db: &Database, message_id: &str, timestamp: i64) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "UPDATE messages SET status = 'read', read_at = ?
                             WHERE message_id = ? AND status IN ('pending', 'sent', 'delivered')",
                            params![timestamp, message_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Mark all messages in a conversation as read
                pub fn mark_conversation_read(
                    db: &Database,
                    conversation_id: &str,
                    our_peer_id: &str,
                    timestamp: i64,
                ) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "UPDATE messages SET status = 'read', read_at = ?
                             WHERE conversation_id = ? AND recipient_peer_id = ?
                               AND status IN ('delivered', 'sent')",
                            params![timestamp, conversation_id, our_peer_id],
                        )?;
                        Ok(rows as i64)
                    })
                }
            
                /// Get all conversations for a peer
                pub fn get_conversations(db: &Database, our_peer_id: &str) -> SqliteResult<Vec<Conversation>> {
                    db.with_connection(|conn| {
                        let mut stmt = conn.prepare(
                            "SELECT
                                m.conversation_id,
                                CASE
                                    WHEN m.sender_peer_id = ? THEN m.recipient_peer_id
                                    ELSE m.sender_peer_id
                                END as peer_id,
                                MAX(m.sent_at) as last_message_at,
                                (SELECT COUNT(*) FROM messages m2
                                 WHERE m2.conversation_id = m.conversation_id
                                   AND m2.recipient_peer_id = ?
                                   AND m2.status IN ('sent', 'delivered')) as unread_count
                             FROM messages m
                             WHERE m.sender_peer_id = ? OR m.recipient_peer_id = ?
                             GROUP BY m.conversation_id
                             ORDER BY last_message_at DESC"
                        )?;
            
                        let rows = stmt.query_map(
                            params![our_peer_id, our_peer_id, our_peer_id, our_peer_id],
                            |row| {
                                Ok(Conversation {
                                    conversation_id: row.get(0)?,
                                    peer_id: row.get(1)?,
                                    last_message_at: row.get(2)?,
                                    last_message_preview: None, // We don't store decrypted content
                                    unread_count: row.get(3)?,
                                })
                            },
                        )?;
            
                        rows.collect()
                    })
                }
            
                /// Get unread count for a conversation
                pub fn get_unread_count(
                    db: &Database,
                    conversation_id: &str,
                    our_peer_id: &str,
                ) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        conn.query_row(
                            "SELECT COUNT(*) FROM messages
                             WHERE conversation_id = ? AND recipient_peer_id = ?
                               AND status IN ('sent', 'delivered')",
                            params![conversation_id, our_peer_id],
                            |row| row.get(0),
                        )
                    })
                }
            
                /// Get pending messages for a peer (for retry/sync)
                pub fn get_pending_messages(
                    db: &Database,
                    recipient_peer_id: &str,
                ) -> SqliteResult<Vec<Message>> {
                    db.with_connection(|conn| {
                        let mut stmt = conn.prepare(
                            "SELECT id, message_id, conversation_id, sender_peer_id, recipient_peer_id,
                                    content_encrypted, content_type, reply_to_message_id, nonce_counter,
                                    lamport_clock, sent_at, received_at, delivered_at, read_at, status
                             FROM messages
                             WHERE recipient_peer_id = ? AND status = 'pending'
                             ORDER BY sent_at ASC"
                        )?;
            
                        let rows = stmt.query_map([recipient_peer_id], Self::row_to_message)?;
                        rows.collect()
                    })
                }
            
                /// Check if a message exists
                pub fn message_exists(db: &Database, message_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let count: i64 = conn.query_row(
                            "SELECT COUNT(*) FROM messages WHERE message_id = ?",
                            [message_id],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            
                /// Record a message event (for event sourcing)
                pub fn record_message_event(
                    db: &Database,
                    event_id: &str,
                    event_type: &str,
                    message_id: &str,
                    conversation_id: &str,
                    sender_peer_id: &str,
                    recipient_peer_id: &str,
                    lamport_clock: i64,
                    timestamp: i64,
                    payload_cbor: &[u8],
                    signature: &[u8],
                ) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        let received_at = chrono::Utc::now().timestamp();
                        conn.execute(
                            "INSERT INTO message_events (
                                event_id, event_type, message_id, conversation_id,
                                sender_peer_id, recipient_peer_id, lamport_clock,
                                timestamp, payload_cbor, signature, received_at
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                event_id,
                                event_type,
                                message_id,
                                conversation_id,
                                sender_peer_id,
                                recipient_peer_id,
                                lamport_clock,
                                timestamp,
                                payload_cbor,
                                signature,
                                received_at,
                            ],
                        )?;
                        Ok(conn.last_insert_rowid())
                    })
                }
            
                /// Check if a message event exists (for deduplication)
                pub fn event_exists(db: &Database, event_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let count: i64 = conn.query_row(
                            "SELECT COUNT(*) FROM message_events WHERE event_id = ?",
                            [event_id],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
            
                fn create_test_db() -> Database {
                    Database::in_memory().unwrap()
                }
            
                #[test]
                fn test_insert_and_get_message() {
                    let db = create_test_db();
            
                    let msg = MessageData {
                        message_id: "msg-123".to_string(),
                        conversation_id: "conv-456".to_string(),
                        sender_peer_id: "peer-a".to_string(),
                        recipient_peer_id: "peer-b".to_string(),
                        content_encrypted: vec![1, 2, 3, 4],
                        content_type: "text".to_string(),
                        reply_to_message_id: None,
                        nonce_counter: 1,
                        lamport_clock: 1,
                        sent_at: 1234567890,
                        received_at: None,
                        status: MessageStatus::Pending,
                    };
            
                    let id = MessagesRepository::insert_message(&db, &msg).unwrap();
                    assert!(id > 0);
            
                    let stored = MessagesRepository::get_by_message_id(&db, "msg-123")
                        .unwrap()
                        .unwrap();
                    assert_eq!(stored.message_id, "msg-123");
                    assert_eq!(stored.content_encrypted, vec![1, 2, 3, 4]);
                    assert_eq!(stored.status, "pending");
                }
            
                #[test]
                fn test_mark_delivered_and_read() {
                    let db = create_test_db();
            
                    let msg = MessageData {
                        message_id: "msg-456".to_string(),
                        conversation_id: "conv-789".to_string(),
                        sender_peer_id: "peer-a".to_string(),
                        recipient_peer_id: "peer-b".to_string(),
                        content_encrypted: vec![5, 6, 7, 8],
                        content_type: "text".to_string(),
                        reply_to_message_id: None,
                        nonce_counter: 1,
                        lamport_clock: 1,
                        sent_at: 1234567890,
                        received_at: None,
                        status: MessageStatus::Sent,
                    };
            
                    MessagesRepository::insert_message(&db, &msg).unwrap();
            
                    // Mark delivered
                    let delivered = MessagesRepository::mark_delivered(&db, "msg-456", 1234567900).unwrap();
                    assert!(delivered);
            
                    let stored = MessagesRepository::get_by_message_id(&db, "msg-456")
                        .unwrap()
                        .unwrap();
                    assert_eq!(stored.status, "delivered");
                    assert_eq!(stored.delivered_at, Some(1234567900));
            
                    // Mark read
                    let read = MessagesRepository::mark_read(&db, "msg-456", 1234567910).unwrap();
                    assert!(read);
            
                    let stored = MessagesRepository::get_by_message_id(&db, "msg-456")
                        .unwrap()
                        .unwrap();
                    assert_eq!(stored.status, "read");
                    assert_eq!(stored.read_at, Some(1234567910));
                }
            
                #[test]
                fn test_get_conversations() {
                    let db = create_test_db();
            
                    // Insert messages in two conversations
                    let msg1 = MessageData {
                        message_id: "msg-1".to_string(),
                        conversation_id: "conv-1".to_string(),
                        sender_peer_id: "peer-a".to_string(),
                        recipient_peer_id: "peer-b".to_string(),
                        content_encrypted: vec![1],
                        content_type: "text".to_string(),
                        reply_to_message_id: None,
                        nonce_counter: 1,
                        lamport_clock: 1,
                        sent_at: 1000,
                        received_at: None,
                        status: MessageStatus::Sent,
                    };
            
                    let msg2 = MessageData {
                        message_id: "msg-2".to_string(),
                        conversation_id: "conv-2".to_string(),
                        sender_peer_id: "peer-c".to_string(),
                        recipient_peer_id: "peer-a".to_string(),
                        content_encrypted: vec![2],
                        content_type: "text".to_string(),
                        reply_to_message_id: None,
                        nonce_counter: 1,
                        lamport_clock: 1,
                        sent_at: 2000,
                        received_at: Some(2000),
                        status: MessageStatus::Delivered,
                    };
            
                    MessagesRepository::insert_message(&db, &msg1).unwrap();
                    MessagesRepository::insert_message(&db, &msg2).unwrap();
            
                    let conversations = MessagesRepository::get_conversations(&db, "peer-a").unwrap();
                    assert_eq!(conversations.len(), 2);
            
                    // Should be ordered by last_message_at DESC
                    assert_eq!(conversations[0].conversation_id, "conv-2");
                    assert_eq!(conversations[0].peer_id, "peer-c");
                    assert_eq!(conversations[0].unread_count, 1); // Unread from peer-c
            
                    assert_eq!(conversations[1].conversation_id, "conv-1");
                    assert_eq!(conversations[1].peer_id, "peer-b");
                }
            }
            ```

          - ğŸ“„ **mod.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\repositories\mod.rs`
            *Size*: 543 bytes | *Modified*: 2026-01-16 23:41:18

            ```
            pub mod contacts_repo;
            pub mod identity_repo;
            pub mod messages_repo;
            pub mod permissions_repo;
            pub mod posts_repo;
            
            pub use contacts_repo::{Contact, ContactData, ContactsRepository};
            pub use identity_repo::IdentityRepository;
            pub use messages_repo::{
                Conversation, Message, MessageData, MessageStatus, MessagesRepository,
            };
            pub use permissions_repo::{
                Capability, GrantData, Permission, PermissionEvent, PermissionsRepository,
            };
            pub use posts_repo::{
                Post, PostData, PostMedia, PostMediaData, PostVisibility, PostsRepository,
            };
            ```

          - ğŸ“„ **permissions_repo.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\repositories\permissions_repo.rs`
            *Size*: 18563 bytes | *Modified*: 2026-01-16 21:30:35

            ```
            //! Permissions repository for managing capability grants and revocations
            
            use rusqlite::{params, OptionalExtension, Result as SqliteResult};
            use crate::db::Database;
            
            /// Capability types that can be granted
            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            pub enum Capability {
                /// Can send/receive direct messages
                Chat,
                /// Can view wall posts
                WallRead,
                /// Can initiate voice calls
                Call,
            }
            
            impl Capability {
                pub fn as_str(&self) -> &'static str {
                    match self {
                        Capability::Chat => "chat",
                        Capability::WallRead => "wall_read",
                        Capability::Call => "call",
                    }
                }
            
                pub fn from_str(s: &str) -> Option<Self> {
                    match s {
                        "chat" => Some(Capability::Chat),
                        "wall_read" => Some(Capability::WallRead),
                        "call" => Some(Capability::Call),
                        _ => None,
                    }
                }
            }
            
            /// A permission event (request, grant, or revoke)
            #[derive(Debug, Clone)]
            pub struct PermissionEvent {
                pub id: i64,
                pub event_id: String,
                pub event_type: String,  // "request", "grant", "revoke"
                pub entity_id: String,   // request_id or grant_id
                pub author_peer_id: String,
                pub issuer_peer_id: Option<String>,
                pub subject_peer_id: String,
                pub capability: String,
                pub scope_json: Option<String>,
                pub lamport_clock: i64,
                pub issued_at: Option<i64>,
                pub expires_at: Option<i64>,
                pub payload_cbor: Vec<u8>,
                pub signature: Vec<u8>,
                pub received_at: i64,
            }
            
            /// Current permission state (materialized from events)
            #[derive(Debug, Clone)]
            pub struct Permission {
                pub id: i64,
                pub grant_id: String,
                pub issuer_peer_id: String,
                pub subject_peer_id: String,
                pub capability: String,
                pub issued_at: i64,
                pub expires_at: Option<i64>,
                pub revoked_at: Option<i64>,
                pub payload_cbor: Vec<u8>,
                pub signature: Vec<u8>,
            }
            
            impl Permission {
                /// Check if this permission is currently valid
                pub fn is_valid(&self) -> bool {
                    // Not revoked
                    if self.revoked_at.is_some() {
                        return false;
                    }
            
                    // Not expired
                    if let Some(expires_at) = self.expires_at {
                        let now = chrono::Utc::now().timestamp();
                        if now > expires_at {
                            return false;
                        }
                    }
            
                    true
                }
            }
            
            /// Data for creating a new permission grant
            #[derive(Debug, Clone)]
            pub struct GrantData {
                pub grant_id: String,
                pub issuer_peer_id: String,
                pub subject_peer_id: String,
                pub capability: String,
                pub scope_json: Option<String>,
                pub lamport_clock: i64,
                pub issued_at: i64,
                pub expires_at: Option<i64>,
                pub payload_cbor: Vec<u8>,
                pub signature: Vec<u8>,
            }
            
            /// Repository for permission operations
            pub struct PermissionsRepository;
            
            impl PermissionsRepository {
                // ============================================================
                // Event Storage (append-only log)
                // ============================================================
            
                /// Record a permission event (request, grant, or revoke)
                pub fn record_event(
                    db: &Database,
                    event_id: &str,
                    event_type: &str,
                    entity_id: &str,
                    author_peer_id: &str,
                    issuer_peer_id: Option<&str>,
                    subject_peer_id: &str,
                    capability: &str,
                    scope_json: Option<&str>,
                    lamport_clock: i64,
                    issued_at: Option<i64>,
                    expires_at: Option<i64>,
                    payload_cbor: &[u8],
                    signature: &[u8],
                ) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        conn.execute(
                            "INSERT INTO permission_events
                             (event_id, event_type, entity_id, author_peer_id, issuer_peer_id, subject_peer_id,
                              capability, scope_json, lamport_clock, issued_at, expires_at, payload_cbor, signature, received_at)
                             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                event_id, event_type, entity_id, author_peer_id, issuer_peer_id, subject_peer_id,
                                capability, scope_json, lamport_clock, issued_at, expires_at, payload_cbor, signature, now
                            ],
                        )?;
                        Ok(conn.last_insert_rowid())
                    })
                }
            
                /// Check if event already exists (for deduplication)
                pub fn event_exists(db: &Database, event_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let count: i32 = conn.query_row(
                            "SELECT COUNT(*) FROM permission_events WHERE event_id = ?",
                            [event_id],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            
                // ============================================================
                // Materialized Permission State
                // ============================================================
            
                /// Create or update a permission grant in the materialized view
                pub fn upsert_grant(db: &Database, grant: &GrantData) -> SqliteResult<()> {
                    db.with_connection(|conn| {
                        conn.execute(
                            "INSERT INTO permissions_current
                             (grant_id, issuer_peer_id, subject_peer_id, capability, issued_at, expires_at, payload_cbor, signature)
                             VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                             ON CONFLICT(grant_id) DO UPDATE SET
                                 expires_at = excluded.expires_at,
                                 payload_cbor = excluded.payload_cbor,
                                 signature = excluded.signature",
                            params![
                                grant.grant_id,
                                grant.issuer_peer_id,
                                grant.subject_peer_id,
                                grant.capability,
                                grant.issued_at,
                                grant.expires_at,
                                grant.payload_cbor,
                                grant.signature
                            ],
                        )?;
                        Ok(())
                    })
                }
            
                /// Mark a grant as revoked
                pub fn revoke_grant(db: &Database, grant_id: &str, revoked_at: i64) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "UPDATE permissions_current SET revoked_at = ? WHERE grant_id = ?",
                            params![revoked_at, grant_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Get a permission by grant ID
                pub fn get_by_grant_id(db: &Database, grant_id: &str) -> SqliteResult<Option<Permission>> {
                    db.with_connection(|conn| {
                        conn.query_row(
                            "SELECT id, grant_id, issuer_peer_id, subject_peer_id, capability,
                                    issued_at, expires_at, revoked_at, payload_cbor, signature
                             FROM permissions_current WHERE grant_id = ?",
                            [grant_id],
                            |row| {
                                Ok(Permission {
                                    id: row.get(0)?,
                                    grant_id: row.get(1)?,
                                    issuer_peer_id: row.get(2)?,
                                    subject_peer_id: row.get(3)?,
                                    capability: row.get(4)?,
                                    issued_at: row.get(5)?,
                                    expires_at: row.get(6)?,
                                    revoked_at: row.get(7)?,
                                    payload_cbor: row.get(8)?,
                                    signature: row.get(9)?,
                                })
                            },
                        )
                        .optional()
                    })
                }
            
                /// Get all valid permissions granted TO a peer (they are the subject)
                pub fn get_permissions_for_subject(
                    db: &Database,
                    subject_peer_id: &str,
                ) -> SqliteResult<Vec<Permission>> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let mut stmt = conn.prepare(
                            "SELECT id, grant_id, issuer_peer_id, subject_peer_id, capability,
                                    issued_at, expires_at, revoked_at, payload_cbor, signature
                             FROM permissions_current
                             WHERE subject_peer_id = ?
                               AND revoked_at IS NULL
                               AND (expires_at IS NULL OR expires_at > ?)"
                        )?;
            
                        let perms = stmt.query_map(params![subject_peer_id, now], |row| {
                            Ok(Permission {
                                id: row.get(0)?,
                                grant_id: row.get(1)?,
                                issuer_peer_id: row.get(2)?,
                                subject_peer_id: row.get(3)?,
                                capability: row.get(4)?,
                                issued_at: row.get(5)?,
                                expires_at: row.get(6)?,
                                revoked_at: row.get(7)?,
                                payload_cbor: row.get(8)?,
                                signature: row.get(9)?,
                            })
                        })?;
            
                        perms.collect()
                    })
                }
            
                /// Get all valid permissions granted BY a peer (they are the issuer)
                pub fn get_permissions_by_issuer(
                    db: &Database,
                    issuer_peer_id: &str,
                ) -> SqliteResult<Vec<Permission>> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let mut stmt = conn.prepare(
                            "SELECT id, grant_id, issuer_peer_id, subject_peer_id, capability,
                                    issued_at, expires_at, revoked_at, payload_cbor, signature
                             FROM permissions_current
                             WHERE issuer_peer_id = ?
                               AND revoked_at IS NULL
                               AND (expires_at IS NULL OR expires_at > ?)"
                        )?;
            
                        let perms = stmt.query_map(params![issuer_peer_id, now], |row| {
                            Ok(Permission {
                                id: row.get(0)?,
                                grant_id: row.get(1)?,
                                issuer_peer_id: row.get(2)?,
                                subject_peer_id: row.get(3)?,
                                capability: row.get(4)?,
                                issued_at: row.get(5)?,
                                expires_at: row.get(6)?,
                                revoked_at: row.get(7)?,
                                payload_cbor: row.get(8)?,
                                signature: row.get(9)?,
                            })
                        })?;
            
                        perms.collect()
                    })
                }
            
                /// Check if a peer has a specific capability granted by another peer
                pub fn has_capability(
                    db: &Database,
                    issuer_peer_id: &str,
                    subject_peer_id: &str,
                    capability: &str,
                ) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let count: i32 = conn.query_row(
                            "SELECT COUNT(*) FROM permissions_current
                             WHERE issuer_peer_id = ?
                               AND subject_peer_id = ?
                               AND capability = ?
                               AND revoked_at IS NULL
                               AND (expires_at IS NULL OR expires_at > ?)",
                            params![issuer_peer_id, subject_peer_id, capability, now],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            
                /// Get the grant for a specific capability (if it exists and is valid)
                pub fn get_capability_grant(
                    db: &Database,
                    issuer_peer_id: &str,
                    subject_peer_id: &str,
                    capability: &str,
                ) -> SqliteResult<Option<Permission>> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        conn.query_row(
                            "SELECT id, grant_id, issuer_peer_id, subject_peer_id, capability,
                                    issued_at, expires_at, revoked_at, payload_cbor, signature
                             FROM permissions_current
                             WHERE issuer_peer_id = ?
                               AND subject_peer_id = ?
                               AND capability = ?
                               AND revoked_at IS NULL
                               AND (expires_at IS NULL OR expires_at > ?)
                             ORDER BY issued_at DESC
                             LIMIT 1",
                            params![issuer_peer_id, subject_peer_id, capability, now],
                            |row| {
                                Ok(Permission {
                                    id: row.get(0)?,
                                    grant_id: row.get(1)?,
                                    issuer_peer_id: row.get(2)?,
                                    subject_peer_id: row.get(3)?,
                                    capability: row.get(4)?,
                                    issued_at: row.get(5)?,
                                    expires_at: row.get(6)?,
                                    revoked_at: row.get(7)?,
                                    payload_cbor: row.get(8)?,
                                    signature: row.get(9)?,
                                })
                            },
                        )
                        .optional()
                    })
                }
            
                /// Get all peers who can chat with us (we granted them chat capability)
                pub fn get_chat_contacts(db: &Database, our_peer_id: &str) -> SqliteResult<Vec<String>> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let mut stmt = conn.prepare(
                            "SELECT DISTINCT subject_peer_id FROM permissions_current
                             WHERE issuer_peer_id = ?
                               AND capability = 'chat'
                               AND revoked_at IS NULL
                               AND (expires_at IS NULL OR expires_at > ?)"
                        )?;
            
                        let peers = stmt.query_map(params![our_peer_id, now], |row| row.get(0))?;
                        peers.collect()
                    })
                }
            
                /// Get all peers who have granted us a capability
                pub fn get_peers_who_granted_capability(
                    db: &Database,
                    our_peer_id: &str,
                    capability: &str,
                ) -> SqliteResult<Vec<String>> {
                    db.with_connection(|conn| {
                        let now = chrono::Utc::now().timestamp();
                        let mut stmt = conn.prepare(
                            "SELECT DISTINCT issuer_peer_id FROM permissions_current
                             WHERE subject_peer_id = ?
                               AND capability = ?
                               AND revoked_at IS NULL
                               AND (expires_at IS NULL OR expires_at > ?)"
                        )?;
            
                        let peers = stmt.query_map(params![our_peer_id, capability, now], |row| row.get(0))?;
                        peers.collect()
                    })
                }
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
            
                #[test]
                fn test_capability_conversion() {
                    assert_eq!(Capability::Chat.as_str(), "chat");
                    assert_eq!(Capability::from_str("chat"), Some(Capability::Chat));
                    assert_eq!(Capability::from_str("invalid"), None);
                }
            
                #[test]
                fn test_grant_and_check_capability() {
                    let db = Database::in_memory().unwrap();
            
                    let grant = GrantData {
                        grant_id: "grant-123".to_string(),
                        issuer_peer_id: "12D3KooWIssuer".to_string(),
                        subject_peer_id: "12D3KooWSubject".to_string(),
                        capability: "chat".to_string(),
                        scope_json: None,
                        lamport_clock: 1,
                        issued_at: chrono::Utc::now().timestamp(),
                        expires_at: None,
                        payload_cbor: vec![1, 2, 3],
                        signature: vec![4, 5, 6],
                    };
            
                    PermissionsRepository::upsert_grant(&db, &grant).unwrap();
            
                    // Check capability exists
                    assert!(PermissionsRepository::has_capability(
                        &db,
                        "12D3KooWIssuer",
                        "12D3KooWSubject",
                        "chat"
                    ).unwrap());
            
                    // Check different capability doesn't exist
                    assert!(!PermissionsRepository::has_capability(
                        &db,
                        "12D3KooWIssuer",
                        "12D3KooWSubject",
                        "call"
                    ).unwrap());
                }
            
                #[test]
                fn test_revoke_grant() {
                    let db = Database::in_memory().unwrap();
            
                    let grant = GrantData {
                        grant_id: "grant-123".to_string(),
                        issuer_peer_id: "12D3KooWIssuer".to_string(),
                        subject_peer_id: "12D3KooWSubject".to_string(),
                        capability: "chat".to_string(),
                        scope_json: None,
                        lamport_clock: 1,
                        issued_at: chrono::Utc::now().timestamp(),
                        expires_at: None,
                        payload_cbor: vec![1, 2, 3],
                        signature: vec![4, 5, 6],
                    };
            
                    PermissionsRepository::upsert_grant(&db, &grant).unwrap();
            
                    // Capability exists before revocation
                    assert!(PermissionsRepository::has_capability(
                        &db, "12D3KooWIssuer", "12D3KooWSubject", "chat"
                    ).unwrap());
            
                    // Revoke
                    let now = chrono::Utc::now().timestamp();
                    PermissionsRepository::revoke_grant(&db, "grant-123", now).unwrap();
            
                    // Capability no longer valid
                    assert!(!PermissionsRepository::has_capability(
                        &db, "12D3KooWIssuer", "12D3KooWSubject", "chat"
                    ).unwrap());
                }
            
                #[test]
                fn test_expired_permission() {
                    let db = Database::in_memory().unwrap();
            
                    // Create a grant that expired in the past
                    let grant = GrantData {
                        grant_id: "grant-expired".to_string(),
                        issuer_peer_id: "12D3KooWIssuer".to_string(),
                        subject_peer_id: "12D3KooWSubject".to_string(),
                        capability: "chat".to_string(),
                        scope_json: None,
                        lamport_clock: 1,
                        issued_at: chrono::Utc::now().timestamp() - 3600, // 1 hour ago
                        expires_at: Some(chrono::Utc::now().timestamp() - 1800), // 30 min ago
                        payload_cbor: vec![1, 2, 3],
                        signature: vec![4, 5, 6],
                    };
            
                    PermissionsRepository::upsert_grant(&db, &grant).unwrap();
            
                    // Expired permission should not be valid
                    assert!(!PermissionsRepository::has_capability(
                        &db, "12D3KooWIssuer", "12D3KooWSubject", "chat"
                    ).unwrap());
                }
            
                #[test]
                fn test_get_permissions_by_issuer() {
                    let db = Database::in_memory().unwrap();
            
                    // Grant multiple permissions
                    for (i, cap) in ["chat", "wall_read", "call"].iter().enumerate() {
                        let grant = GrantData {
                            grant_id: format!("grant-{}", i),
                            issuer_peer_id: "12D3KooWIssuer".to_string(),
                            subject_peer_id: format!("12D3KooWSubject{}", i),
                            capability: cap.to_string(),
                            scope_json: None,
                            lamport_clock: i as i64,
                            issued_at: chrono::Utc::now().timestamp(),
                            expires_at: None,
                            payload_cbor: vec![1, 2, 3],
                            signature: vec![4, 5, 6],
                        };
                        PermissionsRepository::upsert_grant(&db, &grant).unwrap();
                    }
            
                    let perms = PermissionsRepository::get_permissions_by_issuer(&db, "12D3KooWIssuer").unwrap();
                    assert_eq!(perms.len(), 3);
                }
            }
            ```

          - ğŸ“„ **posts_repo.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\db\repositories\posts_repo.rs`
            *Size*: 19591 bytes | *Modified*: 2026-01-16 23:46:28

            ```
            //! Posts repository for storing and retrieving wall/blog posts
            
            use rusqlite::{params, Connection, Result as SqliteResult};
            use crate::db::Database;
            
            /// Post visibility
            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            pub enum PostVisibility {
                /// Visible only to contacts with wall_read permission
                Contacts,
                /// Visible to everyone (public)
                Public,
            }
            
            impl PostVisibility {
                pub fn as_str(&self) -> &'static str {
                    match self {
                        PostVisibility::Contacts => "contacts",
                        PostVisibility::Public => "public",
                    }
                }
            
                pub fn from_str(s: &str) -> Option<Self> {
                    match s {
                        "contacts" => Some(PostVisibility::Contacts),
                        "public" => Some(PostVisibility::Public),
                        _ => None,
                    }
                }
            }
            
            impl std::fmt::Display for PostVisibility {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }
            
            /// A stored post
            #[derive(Debug, Clone)]
            pub struct Post {
                pub id: i64,
                pub post_id: String,
                pub author_peer_id: String,
                pub content_type: String,
                pub content_text: Option<String>,
                pub visibility: PostVisibility,
                pub lamport_clock: i64,
                pub created_at: i64,
                pub updated_at: i64,
                pub deleted_at: Option<i64>,
                pub is_local: bool,
                pub signature: Vec<u8>,
            }
            
            /// Data for inserting a new post
            #[derive(Debug, Clone)]
            pub struct PostData {
                pub post_id: String,
                pub author_peer_id: String,
                pub content_type: String,
                pub content_text: Option<String>,
                pub visibility: PostVisibility,
                pub lamport_clock: i64,
                pub created_at: i64,
                pub signature: Vec<u8>,
            }
            
            /// Post media metadata
            #[derive(Debug, Clone)]
            pub struct PostMedia {
                pub id: i64,
                pub post_id: String,
                pub media_hash: String,
                pub media_type: String,
                pub mime_type: String,
                pub file_name: String,
                pub file_size: i64,
                pub width: Option<i32>,
                pub height: Option<i32>,
                pub duration_seconds: Option<i32>,
                pub sort_order: i32,
            }
            
            /// Data for inserting post media
            #[derive(Debug, Clone)]
            pub struct PostMediaData {
                pub post_id: String,
                pub media_hash: String,
                pub media_type: String,
                pub mime_type: String,
                pub file_name: String,
                pub file_size: i64,
                pub width: Option<i32>,
                pub height: Option<i32>,
                pub duration_seconds: Option<i32>,
                pub sort_order: i32,
            }
            
            /// Repository for post operations
            pub struct PostsRepository;
            
            impl PostsRepository {
                /// Insert a new post
                pub fn insert_post(db: &Database, post: &PostData) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        conn.execute(
                            "INSERT INTO posts (
                                post_id, author_peer_id, content_type, content_text,
                                visibility, lamport_clock, created_at, updated_at,
                                is_local, signature
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                post.post_id,
                                post.author_peer_id,
                                post.content_type,
                                post.content_text,
                                post.visibility.as_str(),
                                post.lamport_clock,
                                post.created_at,
                                post.created_at, // updated_at = created_at initially
                                1i32, // is_local = true for posts we create
                                post.signature,
                            ],
                        )?;
                        Ok(conn.last_insert_rowid())
                    })
                }
            
                /// Insert a remote post (received from network)
                pub fn insert_remote_post(db: &Database, post: &PostData) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        conn.execute(
                            "INSERT INTO posts (
                                post_id, author_peer_id, content_type, content_text,
                                visibility, lamport_clock, created_at, updated_at,
                                is_local, signature
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                post.post_id,
                                post.author_peer_id,
                                post.content_type,
                                post.content_text,
                                post.visibility.as_str(),
                                post.lamport_clock,
                                post.created_at,
                                post.created_at,
                                0i32, // is_local = false for remote posts
                                post.signature,
                            ],
                        )?;
                        Ok(conn.last_insert_rowid())
                    })
                }
            
                /// Get a post by ID
                pub fn get_by_post_id(db: &Database, post_id: &str) -> SqliteResult<Option<Post>> {
                    db.with_connection(|conn| {
                        Self::get_by_post_id_inner(conn, post_id)
                    })
                }
            
                fn get_by_post_id_inner(conn: &Connection, post_id: &str) -> SqliteResult<Option<Post>> {
                    let mut stmt = conn.prepare(
                        "SELECT id, post_id, author_peer_id, content_type, content_text,
                                visibility, lamport_clock, created_at, updated_at,
                                deleted_at, is_local, signature
                         FROM posts WHERE post_id = ?"
                    )?;
            
                    let mut rows = stmt.query([post_id])?;
            
                    if let Some(row) = rows.next()? {
                        Ok(Some(Self::row_to_post(row)?))
                    } else {
                        Ok(None)
                    }
                }
            
                fn row_to_post(row: &rusqlite::Row) -> SqliteResult<Post> {
                    let visibility_str: String = row.get(5)?;
                    let visibility = PostVisibility::from_str(&visibility_str)
                        .unwrap_or(PostVisibility::Contacts);
            
                    Ok(Post {
                        id: row.get(0)?,
                        post_id: row.get(1)?,
                        author_peer_id: row.get(2)?,
                        content_type: row.get(3)?,
                        content_text: row.get(4)?,
                        visibility,
                        lamport_clock: row.get(6)?,
                        created_at: row.get(7)?,
                        updated_at: row.get(8)?,
                        deleted_at: row.get(9)?,
                        is_local: row.get::<_, i32>(10)? != 0,
                        signature: row.get(11)?,
                    })
                }
            
                /// Get posts by author
                pub fn get_by_author(
                    db: &Database,
                    author_peer_id: &str,
                    limit: i64,
                    before_timestamp: Option<i64>,
                ) -> SqliteResult<Vec<Post>> {
                    db.with_connection(|conn| {
                        let mut posts = Vec::new();
            
                        if let Some(before) = before_timestamp {
                            let mut stmt = conn.prepare(
                                "SELECT id, post_id, author_peer_id, content_type, content_text,
                                        visibility, lamport_clock, created_at, updated_at,
                                        deleted_at, is_local, signature
                                 FROM posts
                                 WHERE author_peer_id = ? AND deleted_at IS NULL AND created_at < ?
                                 ORDER BY created_at DESC
                                 LIMIT ?"
                            )?;
                            let mut rows = stmt.query(params![author_peer_id, before, limit])?;
                            while let Some(row) = rows.next()? {
                                posts.push(Self::row_to_post(row)?);
                            }
                        } else {
                            let mut stmt = conn.prepare(
                                "SELECT id, post_id, author_peer_id, content_type, content_text,
                                        visibility, lamport_clock, created_at, updated_at,
                                        deleted_at, is_local, signature
                                 FROM posts
                                 WHERE author_peer_id = ? AND deleted_at IS NULL
                                 ORDER BY created_at DESC
                                 LIMIT ?"
                            )?;
                            let mut rows = stmt.query(params![author_peer_id, limit])?;
                            while let Some(row) = rows.next()? {
                                posts.push(Self::row_to_post(row)?);
                            }
                        }
            
                        Ok(posts)
                    })
                }
            
                /// Get local posts (for own wall)
                pub fn get_local_posts(
                    db: &Database,
                    limit: i64,
                    before_timestamp: Option<i64>,
                ) -> SqliteResult<Vec<Post>> {
                    db.with_connection(|conn| {
                        let mut posts = Vec::new();
            
                        if let Some(before) = before_timestamp {
                            let mut stmt = conn.prepare(
                                "SELECT id, post_id, author_peer_id, content_type, content_text,
                                        visibility, lamport_clock, created_at, updated_at,
                                        deleted_at, is_local, signature
                                 FROM posts
                                 WHERE is_local = 1 AND deleted_at IS NULL AND created_at < ?
                                 ORDER BY created_at DESC
                                 LIMIT ?"
                            )?;
                            let mut rows = stmt.query(params![before, limit])?;
                            while let Some(row) = rows.next()? {
                                posts.push(Self::row_to_post(row)?);
                            }
                        } else {
                            let mut stmt = conn.prepare(
                                "SELECT id, post_id, author_peer_id, content_type, content_text,
                                        visibility, lamport_clock, created_at, updated_at,
                                        deleted_at, is_local, signature
                                 FROM posts
                                 WHERE is_local = 1 AND deleted_at IS NULL
                                 ORDER BY created_at DESC
                                 LIMIT ?"
                            )?;
                            let mut rows = stmt.query(params![limit])?;
                            while let Some(row) = rows.next()? {
                                posts.push(Self::row_to_post(row)?);
                            }
                        }
            
                        Ok(posts)
                    })
                }
            
                /// Update post content
                pub fn update_post(
                    db: &Database,
                    post_id: &str,
                    content_text: Option<&str>,
                    updated_at: i64,
                    lamport_clock: i64,
                ) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "UPDATE posts SET content_text = ?, updated_at = ?, lamport_clock = ?
                             WHERE post_id = ?",
                            params![content_text, updated_at, lamport_clock, post_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Soft delete a post
                pub fn delete_post(
                    db: &Database,
                    post_id: &str,
                    deleted_at: i64,
                ) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let rows = conn.execute(
                            "UPDATE posts SET deleted_at = ?
                             WHERE post_id = ? AND deleted_at IS NULL",
                            params![deleted_at, post_id],
                        )?;
                        Ok(rows > 0)
                    })
                }
            
                /// Check if a post exists
                pub fn post_exists(db: &Database, post_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let count: i64 = conn.query_row(
                            "SELECT COUNT(*) FROM posts WHERE post_id = ?",
                            [post_id],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            
                /// Add media to a post
                pub fn add_media(db: &Database, media: &PostMediaData) -> SqliteResult<()> {
                    db.with_connection(|conn| {
                        conn.execute(
                            "INSERT INTO post_media (
                                post_id, media_hash, media_type, mime_type,
                                file_name, file_size, width, height,
                                duration_seconds, sort_order
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                media.post_id,
                                media.media_hash,
                                media.media_type,
                                media.mime_type,
                                media.file_name,
                                media.file_size,
                                media.width,
                                media.height,
                                media.duration_seconds,
                                media.sort_order,
                            ],
                        )?;
                        Ok(())
                    })
                }
            
                /// Get media for a post
                pub fn get_post_media(db: &Database, post_id: &str) -> SqliteResult<Vec<PostMedia>> {
                    db.with_connection(|conn| {
                        let mut stmt = conn.prepare(
                            "SELECT id, post_id, media_hash, media_type, mime_type,
                                    file_name, file_size, width, height,
                                    duration_seconds, sort_order
                             FROM post_media
                             WHERE post_id = ?
                             ORDER BY sort_order ASC"
                        )?;
            
                        let mut media = Vec::new();
                        let mut rows = stmt.query([post_id])?;
                        while let Some(row) = rows.next()? {
                            media.push(PostMedia {
                                id: row.get(0)?,
                                post_id: row.get(1)?,
                                media_hash: row.get(2)?,
                                media_type: row.get(3)?,
                                mime_type: row.get(4)?,
                                file_name: row.get(5)?,
                                file_size: row.get(6)?,
                                width: row.get(7)?,
                                height: row.get(8)?,
                                duration_seconds: row.get(9)?,
                                sort_order: row.get(10)?,
                            });
                        }
            
                        Ok(media)
                    })
                }
            
                /// Record a post event (for event sourcing)
                pub fn record_post_event(
                    db: &Database,
                    event_id: &str,
                    event_type: &str,
                    post_id: &str,
                    author_peer_id: &str,
                    lamport_clock: i64,
                    timestamp: i64,
                    payload_cbor: &[u8],
                    signature: &[u8],
                ) -> SqliteResult<i64> {
                    db.with_connection(|conn| {
                        let received_at = chrono::Utc::now().timestamp();
                        conn.execute(
                            "INSERT INTO post_events (
                                event_id, event_type, post_id, author_peer_id,
                                lamport_clock, timestamp, payload_cbor, signature, received_at
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            params![
                                event_id,
                                event_type,
                                post_id,
                                author_peer_id,
                                lamport_clock,
                                timestamp,
                                payload_cbor,
                                signature,
                                received_at,
                            ],
                        )?;
                        Ok(conn.last_insert_rowid())
                    })
                }
            
                /// Check if a post event exists (for deduplication)
                pub fn event_exists(db: &Database, event_id: &str) -> SqliteResult<bool> {
                    db.with_connection(|conn| {
                        let count: i64 = conn.query_row(
                            "SELECT COUNT(*) FROM post_events WHERE event_id = ?",
                            [event_id],
                            |row| row.get(0),
                        )?;
                        Ok(count > 0)
                    })
                }
            
                /// Get media hashes for a post
                pub fn get_media_hashes(db: &Database, post_id: &str) -> SqliteResult<Vec<String>> {
                    db.with_connection(|conn| {
                        let mut stmt = conn.prepare(
                            "SELECT media_hash FROM post_media WHERE post_id = ? ORDER BY sort_order"
                        )?;
                        let mut hashes = Vec::new();
                        let mut rows = stmt.query([post_id])?;
                        while let Some(row) = rows.next()? {
                            hashes.push(row.get(0)?);
                        }
                        Ok(hashes)
                    })
                }
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
            
                fn create_test_db() -> Database {
                    Database::in_memory().unwrap()
                }
            
                #[test]
                fn test_insert_and_get_post() {
                    let db = create_test_db();
            
                    let post = PostData {
                        post_id: "post-123".to_string(),
                        author_peer_id: "peer-a".to_string(),
                        content_type: "text".to_string(),
                        content_text: Some("Hello, world!".to_string()),
                        visibility: PostVisibility::Contacts,
                        lamport_clock: 1,
                        created_at: 1234567890,
                        signature: vec![1, 2, 3, 4],
                    };
            
                    let id = PostsRepository::insert_post(&db, &post).unwrap();
                    assert!(id > 0);
            
                    let stored = PostsRepository::get_by_post_id(&db, "post-123")
                        .unwrap()
                        .unwrap();
                    assert_eq!(stored.post_id, "post-123");
                    assert_eq!(stored.content_text, Some("Hello, world!".to_string()));
                    assert_eq!(stored.visibility, PostVisibility::Contacts);
                    assert!(stored.is_local);
                }
            
                #[test]
                fn test_update_post() {
                    let db = create_test_db();
            
                    let post = PostData {
                        post_id: "post-456".to_string(),
                        author_peer_id: "peer-a".to_string(),
                        content_type: "text".to_string(),
                        content_text: Some("Original".to_string()),
                        visibility: PostVisibility::Contacts,
                        lamport_clock: 1,
                        created_at: 1234567890,
                        signature: vec![1, 2, 3, 4],
                    };
            
                    PostsRepository::insert_post(&db, &post).unwrap();
            
                    let updated = PostsRepository::update_post(
                        &db,
                        "post-456",
                        Some("Updated content"),
                        1234567891,
                        2,
                    ).unwrap();
                    assert!(updated);
            
                    let stored = PostsRepository::get_by_post_id(&db, "post-456")
                        .unwrap()
                        .unwrap();
                    assert_eq!(stored.content_text, Some("Updated content".to_string()));
                    assert_eq!(stored.lamport_clock, 2);
                }
            
                #[test]
                fn test_delete_post() {
                    let db = create_test_db();
            
                    let post = PostData {
                        post_id: "post-789".to_string(),
                        author_peer_id: "peer-a".to_string(),
                        content_type: "text".to_string(),
                        content_text: Some("To be deleted".to_string()),
                        visibility: PostVisibility::Contacts,
                        lamport_clock: 1,
                        created_at: 1234567890,
                        signature: vec![1, 2, 3, 4],
                    };
            
                    PostsRepository::insert_post(&db, &post).unwrap();
            
                    let deleted = PostsRepository::delete_post(&db, "post-789", 1234567892).unwrap();
                    assert!(deleted);
            
                    let stored = PostsRepository::get_by_post_id(&db, "post-789")
                        .unwrap()
                        .unwrap();
                    assert!(stored.deleted_at.is_some());
            
                    // Should not appear in get_by_author (filtered out)
                    let posts = PostsRepository::get_by_author(&db, "peer-a", 10, None).unwrap();
                    assert!(posts.is_empty());
                }
            
                #[test]
                fn test_post_media() {
                    let db = create_test_db();
            
                    let post = PostData {
                        post_id: "post-media".to_string(),
                        author_peer_id: "peer-a".to_string(),
                        content_type: "text".to_string(),
                        content_text: Some("Post with media".to_string()),
                        visibility: PostVisibility::Contacts,
                        lamport_clock: 1,
                        created_at: 1234567890,
                        signature: vec![1, 2, 3, 4],
                    };
            
                    PostsRepository::insert_post(&db, &post).unwrap();
            
                    let media = PostMediaData {
                        post_id: "post-media".to_string(),
                        media_hash: "abc123".to_string(),
                        media_type: "image".to_string(),
                        mime_type: "image/jpeg".to_string(),
                        file_name: "photo.jpg".to_string(),
                        file_size: 12345,
                        width: Some(800),
                        height: Some(600),
                        duration_seconds: None,
                        sort_order: 0,
                    };
            
                    PostsRepository::add_media(&db, &media).unwrap();
            
                    let stored_media = PostsRepository::get_post_media(&db, "post-media").unwrap();
                    assert_eq!(stored_media.len(), 1);
                    assert_eq!(stored_media[0].media_hash, "abc123");
                    assert_eq!(stored_media[0].width, Some(800));
            
                    let hashes = PostsRepository::get_media_hashes(&db, "post-media").unwrap();
                    assert_eq!(hashes, vec!["abc123"]);
                }
            }
            ```

      - ğŸ“„ **error.rs**

        ğŸ“„ *File Path*: `.\src-tauri\src\error.rs`
        *Size*: 1723 bytes | *Modified*: 2026-01-16 21:39:21

        ```
        use thiserror::Error;
        
        #[derive(Error, Debug)]
        pub enum AppError {
            #[error("Database error: {0}")]
            Database(#[from] rusqlite::Error),
        
            #[error("Database error: {0}")]
            DatabaseString(String),
        
            #[error("Cryptography error: {0}")]
            Crypto(String),
        
            #[error("Identity error: {0}")]
            Identity(String),
        
            #[error("Serialization error: {0}")]
            Serialization(String),
        
            #[error("IO error: {0}")]
            Io(#[from] std::io::Error),
        
            #[error("Invalid data: {0}")]
            InvalidData(String),
        
            #[error("Not found: {0}")]
            NotFound(String),
        
            #[error("Already exists: {0}")]
            AlreadyExists(String),
        
            #[error("Permission denied: {0}")]
            PermissionDenied(String),
        
            #[error("Unauthorized: {0}")]
            Unauthorized(String),
        
            #[error("Validation error: {0}")]
            Validation(String),
        
            #[error("Network error: {0}")]
            Network(String),
        
            #[error("Internal error: {0}")]
            Internal(String),
        }
        
        // Implement conversion to a serializable error for Tauri commands
        impl serde::Serialize for AppError {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.serialize_str(&self.to_string())
            }
        }
        
        pub type Result<T> = std::result::Result<T, AppError>;
        
        // Implement From for libp2p transport error
        impl From<libp2p::TransportError<std::io::Error>> for AppError {
            fn from(err: libp2p::TransportError<std::io::Error>) -> Self {
                AppError::Network(err.to_string())
            }
        }
        
        // Implement From for libp2p dial error
        impl From<libp2p::swarm::DialError> for AppError {
            fn from(err: libp2p::swarm::DialError) -> Self {
                AppError::Network(err.to_string())
            }
        }
        ```

      - ğŸ“„ **lib.rs**

        ğŸ“„ *File Path*: `.\src-tauri\src\lib.rs`
        *Size*: 7530 bytes | *Modified*: 2026-01-17 12:39:27

        ```
        pub mod commands;
        pub mod db;
        pub mod error;
        pub mod models;
        pub mod p2p;
        pub mod services;
        
        use commands::NetworkState;
        use db::Database;
        use services::{CallingService, ContactsService, FeedService, IdentityService, MessagingService, PermissionsService, PostsService};
        use std::path::PathBuf;
        use std::sync::Arc;
        use tauri::Manager;
        use tracing::info;
        use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
        
        /// Initialize logging
        fn init_logging() {
            tracing_subscriber::registry()
                .with(
                    tracing_subscriber::EnvFilter::try_from_default_env()
                        .unwrap_or_else(|_| "harbor_lib=debug,tauri=info".into()),
                )
                .with(tracing_subscriber::fmt::layer())
                .init();
        }
        
        /// Get the profile name from environment variable (for multi-instance support)
        fn get_profile_name() -> Option<String> {
            std::env::var("HARBOR_PROFILE").ok().filter(|s| !s.is_empty())
        }
        
        /// Get custom data directory from environment variable
        fn get_custom_data_dir() -> Option<PathBuf> {
            std::env::var("HARBOR_DATA_DIR")
                .ok()
                .filter(|s| !s.is_empty())
                .map(PathBuf::from)
        }
        
        /// Get the database path for the application
        fn get_db_path(app: &tauri::AppHandle) -> PathBuf {
            // Check for custom data directory first
            let base_dir = if let Some(custom_dir) = get_custom_data_dir() {
                custom_dir
            } else {
                let app_data = app
                    .path()
                    .app_data_dir()
                    .expect("Failed to get app data directory");
        
                // If a profile is specified, use a subdirectory for that profile
                if let Some(profile) = get_profile_name() {
                    app_data.join(format!("profile-{}", profile))
                } else {
                    app_data
                }
            };
        
            // Ensure the directory exists
            std::fs::create_dir_all(&base_dir).expect("Failed to create data directory");
        
            base_dir.join("harbor.db")
        }
        
        #[cfg_attr(mobile, tauri::mobile_entry_point)]
        pub fn run() {
            init_logging();
        
            let profile = get_profile_name();
            if let Some(ref p) = profile {
                info!("Starting Harbor with profile: {}", p);
            } else {
                info!("Starting Harbor...");
            }
        
            tauri::Builder::default()
                .plugin(tauri_plugin_opener::init())
                .setup(move |app| {
                    // Update window title if running with a profile
                    if let Some(ref profile_name) = profile {
                        if let Some(window) = app.get_webview_window("main") {
                            let _ = window.set_title(&format!("Harbor - {}", profile_name));
                        }
                    }
                    // Initialize database
                    let db_path = get_db_path(&app.handle());
                    info!("Database path: {:?}", db_path);
        
                    let db = Arc::new(Database::new(db_path)
                        .expect("Failed to initialize database"));
        
                    // Initialize services
                    let identity_service = Arc::new(IdentityService::new(db.clone()));
                    let contacts_service = Arc::new(ContactsService::new(db.clone(), identity_service.clone()));
                    let permissions_service = Arc::new(PermissionsService::new(db.clone(), identity_service.clone()));
                    let messaging_service = Arc::new(MessagingService::new(
                        db.clone(),
                        identity_service.clone(),
                        contacts_service.clone(),
                        permissions_service.clone(),
                    ));
                    let posts_service = Arc::new(PostsService::new(
                        db.clone(),
                        identity_service.clone(),
                        contacts_service.clone(),
                        permissions_service.clone(),
                    ));
                    let feed_service = Arc::new(FeedService::new(
                        db.clone(),
                        identity_service.clone(),
                        permissions_service.clone(),
                    ));
                    let calling_service = Arc::new(CallingService::new(
                        db.clone(),
                        identity_service.clone(),
                        contacts_service.clone(),
                        permissions_service.clone(),
                    ));
        
                    // Initialize network state (will be populated when identity is unlocked)
                    let network_state = NetworkState::new();
        
                    // Register state
                    app.manage(db);
                    app.manage(identity_service);
                    app.manage(contacts_service);
                    app.manage(permissions_service);
                    app.manage(messaging_service);
                    app.manage(posts_service);
                    app.manage(feed_service);
                    app.manage(calling_service);
                    app.manage(network_state);
        
                    info!("Application setup complete");
                    Ok(())
                })
                .invoke_handler(tauri::generate_handler![
                    // Identity commands
                    commands::has_identity,
                    commands::is_identity_unlocked,
                    commands::get_identity_info,
                    commands::create_identity,
                    commands::unlock_identity,
                    commands::lock_identity,
                    commands::update_display_name,
                    commands::update_bio,
                    commands::get_peer_id,
                    // Network commands
                    commands::get_connected_peers,
                    commands::get_network_stats,
                    commands::is_network_running,
                    commands::bootstrap_network,
                    commands::start_network,
                    commands::stop_network,
                    // Contact commands
                    commands::get_contacts,
                    commands::get_active_contacts,
                    commands::get_contact,
                    commands::add_contact,
                    commands::block_contact,
                    commands::unblock_contact,
                    commands::remove_contact,
                    commands::is_contact,
                    commands::is_contact_blocked,
                    commands::request_peer_identity,
                    // Permission commands
                    commands::grant_permission,
                    commands::revoke_permission,
                    commands::peer_has_capability,
                    commands::we_have_capability,
                    commands::get_granted_permissions,
                    commands::get_received_permissions,
                    commands::get_chat_peers,
                    commands::grant_all_permissions,
                    // Messaging commands
                    commands::send_message,
                    commands::get_messages,
                    commands::get_conversations,
                    commands::mark_conversation_read,
                    commands::get_unread_count,
                    commands::get_total_unread_count,
                    // Post commands
                    commands::create_post,
                    commands::update_post,
                    commands::delete_post,
                    commands::get_post,
                    commands::get_my_posts,
                    commands::get_posts_by_author,
                    commands::add_post_media,
                    commands::get_post_media,
                    // Feed commands
                    commands::get_feed,
                    commands::get_wall,
                    // Calling commands
                    commands::start_call,
                    commands::answer_call,
                    commands::send_ice_candidate,
                    commands::hangup_call,
                    commands::process_offer,
                    commands::process_answer,
                    commands::process_ice_candidate,
                    commands::process_hangup,
                ])
                .run(tauri::generate_context!())
                .expect("error while running tauri application");
        }
        ```

      - ğŸ“„ **main.rs**

        ğŸ“„ *File Path*: `.\src-tauri\src\main.rs`
        *Size*: 187 bytes | *Modified*: 2026-01-16 22:05:08

        ```
        // Prevents additional console window on Windows in release, DO NOT REMOVE!!
        #![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
        
        fn main() {
            harbor_lib::run()
        }
        ```

      - ğŸ“ **models/**
        - ğŸ“„ **identity.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\models\identity.rs`
          *Size*: 2129 bytes | *Modified*: 2026-01-16 17:10:44

          ```
          use serde::{Deserialize, Serialize};
          
          /// Local identity stored in the database
          #[derive(Debug, Clone)]
          pub struct LocalIdentity {
              pub peer_id: String,
              pub public_key: Vec<u8>,
              pub x25519_public: Vec<u8>,
              pub private_key_encrypted: Vec<u8>,
              pub display_name: String,
              pub avatar_hash: Option<String>,
              pub bio: Option<String>,
              pub created_at: i64,
              pub updated_at: i64,
          }
          
          /// Identity info sent to frontend (no private keys)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct IdentityInfo {
              pub peer_id: String,
              pub public_key: String,  // base64 encoded
              pub x25519_public: String,  // base64 encoded
              pub display_name: String,
              pub avatar_hash: Option<String>,
              pub bio: Option<String>,
              pub created_at: i64,
              pub updated_at: i64,
          }
          
          impl From<LocalIdentity> for IdentityInfo {
              fn from(identity: LocalIdentity) -> Self {
                  use base64::Engine;
                  let engine = base64::engine::general_purpose::STANDARD;
          
                  Self {
                      peer_id: identity.peer_id,
                      public_key: engine.encode(&identity.public_key),
                      x25519_public: engine.encode(&identity.x25519_public),
                      display_name: identity.display_name,
                      avatar_hash: identity.avatar_hash,
                      bio: identity.bio,
                      created_at: identity.created_at,
                      updated_at: identity.updated_at,
                  }
              }
          }
          
          /// Request to create a new identity
          #[derive(Debug, Clone, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct CreateIdentityRequest {
              pub display_name: String,
              pub passphrase: String,
              pub bio: Option<String>,
          }
          
          /// Request to unlock identity
          #[derive(Debug, Clone, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct UnlockIdentityRequest {
              pub passphrase: String,
          }
          
          /// Encrypted keys stored in database
          /// Contains both Ed25519 (signing) and X25519 (key agreement) private keys
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct EncryptedKeys {
              pub ed25519_private: Vec<u8>,  // 32 bytes
              pub x25519_private: Vec<u8>,   // 32 bytes
          }
          ```

        - ğŸ“„ **mod.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\models\mod.rs`
          *Size*: 40 bytes | *Modified*: 2026-01-16 17:10:31

          ```
          pub mod identity;
          
          pub use identity::*;
          ```

      - ğŸ“ **p2p/**
        - ğŸ“„ **behaviour.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\p2p\behaviour.rs`
          *Size*: 4206 bytes | *Modified*: 2026-01-16 22:06:18

          ```
          use libp2p::{
              autonat, dcutr, identify, kad, mdns, ping, relay,
              request_response::{self, ProtocolSupport},
              swarm::NetworkBehaviour,
              StreamProtocol,
          };
          use std::time::Duration;
          
          use super::protocols::{IDENTITY_PROTOCOL, MESSAGING_PROTOCOL};
          
          // Duration is used in ping configuration
          
          /// Combined network behaviour for the chat application
          #[derive(NetworkBehaviour)]
          pub struct ChatBehaviour {
              /// Ping protocol for connection liveness
              pub ping: ping::Behaviour,
              /// Identify protocol for peer identification
              pub identify: identify::Behaviour,
              /// Kademlia DHT for peer discovery and routing
              pub kademlia: kad::Behaviour<kad::store::MemoryStore>,
              /// mDNS for local network peer discovery
              pub mdns: mdns::tokio::Behaviour,
              /// Relay client for NAT traversal
              pub relay_client: relay::client::Behaviour,
              /// DCUtR for direct connection upgrade through relay
              pub dcutr: dcutr::Behaviour,
              /// AutoNAT for external address discovery
              pub autonat: autonat::Behaviour,
              /// Request-response for identity exchange
              pub identity_exchange: request_response::cbor::Behaviour<IdentityExchangeRequest, IdentityExchangeResponse>,
              /// Request-response for messaging
              pub messaging: request_response::cbor::Behaviour<MessagingRequest, MessagingResponse>,
          }
          
          /// Identity exchange request (simplified for request-response)
          #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
          pub struct IdentityExchangeRequest {
              pub requester_peer_id: String,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// Identity exchange response
          #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
          pub struct IdentityExchangeResponse {
              pub peer_id: String,
              pub public_key: Vec<u8>,
              pub x25519_public: Vec<u8>,
              pub display_name: String,
              pub avatar_hash: Option<String>,
              pub bio: Option<String>,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// Messaging request
          #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
          pub struct MessagingRequest {
              pub message_type: String,
              pub payload: Vec<u8>,
          }
          
          /// Messaging response
          #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
          pub struct MessagingResponse {
              pub success: bool,
              pub message_id: Option<String>,
              pub error: Option<String>,
          }
          
          impl ChatBehaviour {
              /// Create a new chat behaviour with the given local peer ID and keypair
              pub fn new(
                  local_peer_id: libp2p::PeerId,
                  local_public_key: libp2p::identity::PublicKey,
                  relay_client: relay::client::Behaviour,
              ) -> Self {
                  // Ping
                  let ping = ping::Behaviour::new(ping::Config::new().with_interval(Duration::from_secs(15)));
          
                  // Identify
                  let identify = identify::Behaviour::new(identify::Config::new(
                      "/harbor/1.0.0".to_string(),
                      local_public_key.clone(),
                  ));
          
                  // Kademlia DHT
                  let kademlia = kad::Behaviour::new(
                      local_peer_id,
                      kad::store::MemoryStore::new(local_peer_id),
                  );
          
                  // mDNS
                  let mdns = mdns::tokio::Behaviour::new(
                      mdns::Config::default(),
                      local_peer_id,
                  ).expect("Failed to create mDNS behaviour");
          
                  // DCUtR for hole punching
                  let dcutr = dcutr::Behaviour::new(local_peer_id);
          
                  // AutoNAT
                  let autonat = autonat::Behaviour::new(
                      local_peer_id,
                      autonat::Config::default(),
                  );
          
                  // Identity exchange protocol
                  let identity_exchange = request_response::cbor::Behaviour::new(
                      [(StreamProtocol::new(IDENTITY_PROTOCOL), ProtocolSupport::Full)],
                      request_response::Config::default(),
                  );
          
                  // Messaging protocol
                  let messaging = request_response::cbor::Behaviour::new(
                      [(StreamProtocol::new(MESSAGING_PROTOCOL), ProtocolSupport::Full)],
                      request_response::Config::default(),
                  );
          
                  Self {
                      ping,
                      identify,
                      kademlia,
                      mdns,
                      relay_client,
                      dcutr,
                      autonat,
                      identity_exchange,
                      messaging,
                  }
              }
          }
          ```

        - ğŸ“„ **config.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\p2p\config.rs`
          *Size*: 1906 bytes | *Modified*: 2026-01-18 09:17:19

          ```
          use libp2p::Multiaddr;
          use std::time::Duration;
          
          /// Configuration for the P2P network
          #[derive(Debug, Clone)]
          pub struct NetworkConfig {
              /// Port to listen on for TCP connections (0 = random)
              pub tcp_port: u16,
              /// Port to listen on for QUIC connections (0 = random)
              pub quic_port: u16,
              /// Enable mDNS for local peer discovery
              pub enable_mdns: bool,
              /// Enable the Kademlia DHT
              pub enable_dht: bool,
              /// Bootstrap nodes for the DHT
              pub bootstrap_nodes: Vec<Multiaddr>,
              /// Idle connection timeout
              pub idle_connection_timeout: Duration,
              /// Enable relay client for NAT traversal
              pub enable_relay_client: bool,
              /// Enable DCUtR (Direct Connection Upgrade through Relay) for hole punching
              pub enable_dcutr: bool,
              /// Enable AutoNAT for external address discovery
              pub enable_autonat: bool,
          }
          
          impl Default for NetworkConfig {
              fn default() -> Self {
                  Self {
                      tcp_port: 0,  // Random port
                      quic_port: 0, // Random port
                      enable_mdns: true,
                      enable_dht: true,
                      bootstrap_nodes: Vec::new(),
                      idle_connection_timeout: Duration::from_secs(86400), // 24 hours - chat apps stay connected
                      enable_relay_client: true,
                      enable_dcutr: true,
                      enable_autonat: true,
                  }
              }
          }
          
          impl NetworkConfig {
              /// Create a config optimized for LAN discovery
              pub fn lan_only() -> Self {
                  Self {
                      enable_mdns: true,
                      enable_dht: false,
                      enable_relay_client: false,
                      enable_dcutr: false,
                      enable_autonat: false,
                      ..Default::default()
                  }
              }
          
              /// Create a config with custom ports
              pub fn with_ports(tcp_port: u16, quic_port: u16) -> Self {
                  Self {
                      tcp_port,
                      quic_port,
                      ..Default::default()
                  }
              }
          }
          ```

        - ğŸ“„ **mod.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\p2p\mod.rs`
          *Size*: 201 bytes | *Modified*: 2026-01-16 17:46:14

          ```
          pub mod behaviour;
          pub mod config;
          pub mod network;
          pub mod protocols;
          pub mod swarm;
          pub mod types;
          
          pub use config::NetworkConfig;
          pub use network::{NetworkHandle, NetworkService};
          pub use types::*;
          ```

        - ğŸ“„ **network.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\p2p\network.rs`
          *Size*: 26855 bytes | *Modified*: 2026-01-18 10:12:05

          ```
          use futures::StreamExt;
          use libp2p::{
              identify, kad, mdns, ping,
              request_response::{self, ResponseChannel},
              swarm::SwarmEvent,
              Multiaddr, PeerId, Swarm,
          };
          use std::collections::HashMap;
          use base64::Engine;
          use std::time::Instant;
          use tokio::sync::{mpsc, oneshot};
          use tracing::{debug, error, info, warn};
          
          use super::behaviour::{ChatBehaviour, ChatBehaviourEvent, IdentityExchangeRequest, IdentityExchangeResponse, MessagingRequest, MessagingResponse};
          use super::config::NetworkConfig;
          use super::protocols::messaging::{MessagingCodec, MessagingMessage};
          use super::swarm::build_swarm;
          use super::types::*;
          use crate::error::{AppError, Result};
          use crate::services::{ContactsService, IdentityService, MessagingService, PermissionsService};
          use crate::db::Capability;
          use std::sync::Arc;
          
          /// Handle to interact with the network service
          #[derive(Clone)]
          pub struct NetworkHandle {
              command_tx: mpsc::Sender<(NetworkCommand, Option<oneshot::Sender<NetworkResponse>>)>,
          }
          
          impl NetworkHandle {
              /// Dial a peer at the given addresses
              pub async fn dial(&self, peer_id: PeerId, addresses: Vec<Multiaddr>) -> Result<()> {
                  let (tx, rx) = oneshot::channel();
                  self.command_tx
                      .send((NetworkCommand::Dial { peer_id, addresses }, Some(tx)))
                      .await
                      .map_err(|_| AppError::Internal("Network service unavailable".into()))?;
          
                  match rx.await {
                      Ok(NetworkResponse::Ok) => Ok(()),
                      Ok(NetworkResponse::Error(e)) => Err(AppError::Network(e)),
                      _ => Err(AppError::Internal("Unexpected response".into())),
                  }
              }
          
              /// Get list of connected peers
              pub async fn get_connected_peers(&self) -> Result<Vec<PeerInfo>> {
                  let (tx, rx) = oneshot::channel();
                  self.command_tx
                      .send((NetworkCommand::GetConnectedPeers, Some(tx)))
                      .await
                      .map_err(|_| AppError::Internal("Network service unavailable".into()))?;
          
                  match rx.await {
                      Ok(NetworkResponse::Peers(peers)) => Ok(peers),
                      Ok(NetworkResponse::Error(e)) => Err(AppError::Network(e)),
                      _ => Err(AppError::Internal("Unexpected response".into())),
                  }
              }
          
              /// Get network statistics
              pub async fn get_stats(&self) -> Result<NetworkStats> {
                  let (tx, rx) = oneshot::channel();
                  self.command_tx
                      .send((NetworkCommand::GetStats, Some(tx)))
                      .await
                      .map_err(|_| AppError::Internal("Network service unavailable".into()))?;
          
                  match rx.await {
                      Ok(NetworkResponse::Stats(stats)) => Ok(stats),
                      Ok(NetworkResponse::Error(e)) => Err(AppError::Network(e)),
                      _ => Err(AppError::Internal("Unexpected response".into())),
                  }
              }
          
              /// Bootstrap the DHT
              pub async fn bootstrap(&self) -> Result<()> {
                  let (tx, rx) = oneshot::channel();
                  self.command_tx
                      .send((NetworkCommand::Bootstrap, Some(tx)))
                      .await
                      .map_err(|_| AppError::Internal("Network service unavailable".into()))?;
          
                  match rx.await {
                      Ok(NetworkResponse::Ok) => Ok(()),
                      Ok(NetworkResponse::Error(e)) => Err(AppError::Network(e)),
                      _ => Err(AppError::Internal("Unexpected response".into())),
                  }
              }
          
              /// Shutdown the network service
              pub async fn shutdown(&self) -> Result<()> {
                  self.command_tx
                      .send((NetworkCommand::Shutdown, None))
                      .await
                      .map_err(|_| AppError::Internal("Network service unavailable".into()))?;
                  Ok(())
              }
          
              /// Send a message to a peer
              pub async fn send_message(&self, peer_id: PeerId, protocol: String, payload: Vec<u8>) -> Result<()> {
                  let (tx, rx) = oneshot::channel();
                  self.command_tx
                      .send((NetworkCommand::SendMessage { peer_id, protocol, payload }, Some(tx)))
                      .await
                      .map_err(|_| AppError::Internal("Network service unavailable".into()))?;
          
                  match rx.await {
                      Ok(NetworkResponse::Ok) => Ok(()),
                      Ok(NetworkResponse::Error(e)) => Err(AppError::Network(e)),
                      _ => Err(AppError::Internal("Unexpected response".into())),
                  }
              }
          
              /// Request identity from a peer
              pub async fn request_identity(&self, peer_id: PeerId) -> Result<()> {
                  let (tx, rx) = oneshot::channel();
                  self.command_tx
                      .send((NetworkCommand::RequestIdentity { peer_id }, Some(tx)))
                      .await
                      .map_err(|_| AppError::Internal("Network service unavailable".into()))?;
          
                  match rx.await {
                      Ok(NetworkResponse::Ok) => Ok(()),
                      Ok(NetworkResponse::Error(e)) => Err(AppError::Network(e)),
                      _ => Err(AppError::Internal("Unexpected response".into())),
                  }
              }
          }
          
          /// The network service manages the libp2p swarm
          pub struct NetworkService {
              swarm: Swarm<ChatBehaviour>,
              config: NetworkConfig,
              identity_service: Arc<IdentityService>,
              messaging_service: Option<Arc<MessagingService>>,
              contacts_service: Option<Arc<ContactsService>>,
              permissions_service: Option<Arc<PermissionsService>>,
              command_rx: mpsc::Receiver<(NetworkCommand, Option<oneshot::Sender<NetworkResponse>>)>,
              event_tx: mpsc::Sender<NetworkEvent>,
              connected_peers: HashMap<PeerId, PeerInfo>,
              discovered_peers: HashMap<PeerId, Vec<Multiaddr>>,
              stats: NetworkStats,
              start_time: Instant,
          }
          
          impl NetworkService {
              /// Create a new network service
              pub fn new(
                  config: NetworkConfig,
                  identity_service: Arc<IdentityService>,
                  keypair: libp2p::identity::Keypair,
              ) -> Result<(Self, NetworkHandle, mpsc::Receiver<NetworkEvent>)> {
                  let swarm = build_swarm(keypair, &config)?;
          
                  let (command_tx, command_rx) = mpsc::channel(256);
                  let (event_tx, event_rx) = mpsc::channel(256);
          
                  let handle = NetworkHandle { command_tx };
          
                  let service = Self {
                      swarm,
                      config,
                      identity_service,
                      messaging_service: None,
                      contacts_service: None,
                      permissions_service: None,
                      command_rx,
                      event_tx,
                      connected_peers: HashMap::new(),
                      discovered_peers: HashMap::new(),
                      stats: NetworkStats::default(),
                      start_time: Instant::now(),
                  };
          
                  Ok((service, handle, event_rx))
              }
          
              /// Set the messaging service for processing incoming messages
              pub fn set_messaging_service(&mut self, service: Arc<MessagingService>) {
                  self.messaging_service = Some(service);
              }
          
              /// Set the contacts service for storing contacts from identity exchange
              pub fn set_contacts_service(&mut self, service: Arc<ContactsService>) {
                  self.contacts_service = Some(service);
              }
          
              /// Set the permissions service for granting permissions to contacts
              pub fn set_permissions_service(&mut self, service: Arc<PermissionsService>) {
                  self.permissions_service = Some(service);
              }
          
              /// Get the local peer ID
              pub fn local_peer_id(&self) -> &PeerId {
                  self.swarm.local_peer_id()
              }
          
              /// Create an identity exchange request
              fn create_identity_request(&self) -> Result<IdentityExchangeRequest> {
                  let info = self.identity_service.get_identity_info()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let timestamp = chrono::Utc::now().timestamp();
                  let signature = self.identity_service.sign_raw(
                      format!("{}:{}", info.peer_id, timestamp).as_bytes()
                  )?;
          
                  Ok(IdentityExchangeRequest {
                      requester_peer_id: info.peer_id,
                      timestamp,
                      signature,
                  })
              }
          
              /// Start listening on configured addresses
              pub fn start_listening(&mut self) -> Result<()> {
                  // Listen on TCP
                  let tcp_addr: Multiaddr = format!("/ip4/0.0.0.0/tcp/{}", self.config.tcp_port)
                      .parse()
                      .map_err(|e| AppError::Network(format!("Invalid TCP address: {}", e)))?;
                  self.swarm.listen_on(tcp_addr.clone())?;
                  info!("Listening on TCP: {}", tcp_addr);
          
                  // Listen on QUIC
                  let quic_addr: Multiaddr = format!("/ip4/0.0.0.0/udp/{}/quic-v1", self.config.quic_port)
                      .parse()
                      .map_err(|e| AppError::Network(format!("Invalid QUIC address: {}", e)))?;
                  self.swarm.listen_on(quic_addr.clone())?;
                  info!("Listening on QUIC: {}", quic_addr);
          
                  Ok(())
              }
          
              /// Run the network event loop
              pub async fn run(mut self) {
                  info!("Network service starting...");
          
                  if let Err(e) = self.start_listening() {
                      error!("Failed to start listening: {}", e);
                      return;
                  }
          
                  loop {
                      tokio::select! {
                          // Handle swarm events
                          event = self.swarm.select_next_some() => {
                              self.handle_swarm_event(event).await;
                          }
          
                          // Handle commands from the application
                          Some((command, response_tx)) = self.command_rx.recv() => {
                              let should_shutdown = matches!(command, NetworkCommand::Shutdown);
                              let response = self.handle_command(command).await;
                              if let Some(tx) = response_tx {
                                  let _ = tx.send(response);
                              }
                              if should_shutdown {
                                  info!("Network service shutting down...");
                                  break;
                              }
                          }
                      }
                  }
              }
          
              async fn handle_swarm_event(&mut self, event: SwarmEvent<ChatBehaviourEvent>) {
                  match event {
                      SwarmEvent::NewListenAddr { address, .. } => {
                          info!("Listening on: {}", address);
                          let _ = self.event_tx.send(NetworkEvent::ListeningOn {
                              address: address.to_string(),
                          }).await;
                      }
          
                      SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
                          info!("Connected to peer: {} at {:?}", peer_id, endpoint);
                          let peer_info = PeerInfo {
                              peer_id: peer_id.to_string(),
                              addresses: vec![endpoint.get_remote_address().to_string()],
                              protocol_version: None,
                              agent_version: None,
                              is_connected: true,
                              last_seen: Some(chrono::Utc::now().timestamp()),
                          };
                          self.connected_peers.insert(peer_id, peer_info);
                          self.stats.connected_peers = self.connected_peers.len();
          
                          let _ = self.event_tx.send(NetworkEvent::PeerConnected {
                              peer_id: peer_id.to_string(),
                          }).await;
                      }
          
                      SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                          info!("Disconnected from peer: {} (cause: {:?})", peer_id, cause);
                          self.connected_peers.remove(&peer_id);
                          self.stats.connected_peers = self.connected_peers.len();
          
                          let _ = self.event_tx.send(NetworkEvent::PeerDisconnected {
                              peer_id: peer_id.to_string(),
                          }).await;
                      }
          
                      SwarmEvent::ExternalAddrConfirmed { address } => {
                          info!("External address confirmed: {}", address);
                          let _ = self.event_tx.send(NetworkEvent::ExternalAddressDiscovered {
                              address: address.to_string(),
                          }).await;
                      }
          
                      SwarmEvent::Behaviour(behaviour_event) => {
                          self.handle_behaviour_event(behaviour_event).await;
                      }
          
                      _ => {}
                  }
              }
          
              async fn handle_behaviour_event(&mut self, event: ChatBehaviourEvent) {
                  match event {
                      ChatBehaviourEvent::Mdns(mdns::Event::Discovered(peers)) => {
                          for (peer_id, addr) in peers {
                              info!("mDNS discovered peer: {} at {}", peer_id, addr);
                              self.discovered_peers
                                  .entry(peer_id)
                                  .or_default()
                                  .push(addr.clone());
          
                              // Add to Kademlia routing table
                              self.swarm.behaviour_mut().kademlia.add_address(&peer_id, addr);
          
                              let _ = self.event_tx.send(NetworkEvent::PeerDiscovered {
                                  peer_id: peer_id.to_string(),
                              }).await;
                          }
                      }
          
                      ChatBehaviourEvent::Mdns(mdns::Event::Expired(peers)) => {
                          for (peer_id, addr) in peers {
                              debug!("mDNS peer expired: {} at {}", peer_id, addr);
                              if let Some(addrs) = self.discovered_peers.get_mut(&peer_id) {
                                  addrs.retain(|a| a != &addr);
                                  if addrs.is_empty() {
                                      self.discovered_peers.remove(&peer_id);
                                      let _ = self.event_tx.send(NetworkEvent::PeerExpired {
                                          peer_id: peer_id.to_string(),
                                      }).await;
                                  }
                              }
                          }
                      }
          
                      ChatBehaviourEvent::Identify(identify::Event::Received { peer_id, info, .. }) => {
                          debug!("Identified peer: {} - {}", peer_id, info.agent_version);
                          if let Some(peer_info) = self.connected_peers.get_mut(&peer_id) {
                              peer_info.protocol_version = Some(info.protocol_version);
                              peer_info.agent_version = Some(info.agent_version);
                          }
          
                          // Add addresses to Kademlia
                          for addr in info.listen_addrs {
                              self.swarm.behaviour_mut().kademlia.add_address(&peer_id, addr);
                          }
                      }
          
                      ChatBehaviourEvent::Kademlia(kad::Event::RoutingUpdated { peer, .. }) => {
                          debug!("Kademlia routing updated for peer: {}", peer);
                      }
          
                      ChatBehaviourEvent::Ping(ping::Event { peer, result, .. }) => {
                          if let Ok(rtt) = result {
                              debug!("Ping to {} succeeded: {:?}", peer, rtt);
                          }
                      }
          
                      ChatBehaviourEvent::IdentityExchange(request_response::Event::Message { peer, message }) => {
                          match message {
                              request_response::Message::Request { request_id, request, channel } => {
                                  info!("Received identity request from {}", peer);
                                  self.handle_identity_request(peer, request_id, request, channel).await;
                              }
                              request_response::Message::Response { request_id, response } => {
                                  info!("Received identity response from {}", peer);
                                  self.handle_identity_response(peer, request_id, response).await;
                              }
                          }
                      }
          
                      ChatBehaviourEvent::Messaging(request_response::Event::Message { peer, message }) => {
                          match message {
                              request_response::Message::Request { request_id, request, channel } => {
                                  debug!("Received message request from {}", peer);
                                  self.handle_messaging_request(peer, request_id, request, channel).await;
                              }
                              request_response::Message::Response { request_id: _, response: _ } => {
                                  debug!("Received message response from {}", peer);
                                  // Handle response (e.g., update message delivery status)
                              }
                          }
                      }
          
                      _ => {}
                  }
              }
          
              async fn handle_identity_request(
                  &mut self,
                  _peer: PeerId,
                  _request_id: request_response::InboundRequestId,
                  _request: IdentityExchangeRequest,
                  channel: ResponseChannel<IdentityExchangeResponse>,
              ) {
                  // Get our libp2p peer ID (this is what other peers see us as)
                  let local_peer_id = *self.swarm.local_peer_id();
          
                  // Get our identity info to respond with
                  match self.identity_service.get_identity_info() {
                      Ok(Some(info)) => {
                          // Sign the response using the libp2p peer ID
                          let timestamp = chrono::Utc::now().timestamp();
                          let signature = match self.identity_service.sign_raw(
                              format!("{}:{}:{}", local_peer_id, info.display_name, timestamp).as_bytes()
                          ) {
                              Ok(sig) => sig,
                              Err(e) => {
                                  warn!("Failed to sign identity response: {}", e);
                                  return;
                              }
                          };
          
                          // Decode base64 public keys to bytes for the network protocol
                          let engine = base64::engine::general_purpose::STANDARD;
                          let public_key = match engine.decode(&info.public_key) {
                              Ok(bytes) => bytes,
                              Err(e) => {
                                  warn!("Failed to decode public key: {}", e);
                                  return;
                              }
                          };
                          let x25519_public = match engine.decode(&info.x25519_public) {
                              Ok(bytes) => bytes,
                              Err(e) => {
                                  warn!("Failed to decode x25519 public key: {}", e);
                                  return;
                              }
                          };
          
                          let response = IdentityExchangeResponse {
                              // Use the libp2p peer ID, not the stored Harbor peer_id
                              peer_id: local_peer_id.to_string(),
                              public_key,
                              x25519_public,
                              display_name: info.display_name,
                              avatar_hash: info.avatar_hash,
                              bio: info.bio,
                              timestamp,
                              signature,
                          };
          
                          if let Err(e) = self.swarm.behaviour_mut().identity_exchange.send_response(channel, response) {
                              warn!("Failed to send identity response: {:?}", e);
                          }
                      }
                      Ok(None) => {
                          warn!("No identity configured, cannot respond to identity request");
                      }
                      Err(e) => {
                          warn!("Failed to get identity info: {}", e);
                      }
                  }
              }
          
              async fn handle_identity_response(
                  &mut self,
                  peer: PeerId,
                  _request_id: request_response::OutboundRequestId,
                  response: IdentityExchangeResponse,
              ) {
                  info!(
                      "Got identity from {}: {} ({})",
                      peer, response.display_name, response.peer_id
                  );
          
                  // Store in contacts database if we have the contacts service
                  if let Some(ref contacts_service) = self.contacts_service {
                      // Verify the response peer ID matches the peer we received from
                      if response.peer_id != peer.to_string() {
                          warn!("Identity response peer ID mismatch: expected {}, got {}", peer, response.peer_id);
                          return;
                      }
          
                      // TODO: Verify signature on the response
                      // For now, we trust the identity since we're getting it from a direct connection
          
                      match contacts_service.add_contact(
                          &response.peer_id,
                          &response.public_key,
                          &response.x25519_public,
                          &response.display_name,
                          response.avatar_hash.as_deref(),
                          response.bio.as_deref(),
                      ) {
                          Ok(contact_id) => {
                              info!("Added contact {} with ID {}", response.display_name, contact_id);
          
                              // Grant chat permission to the new contact
                              if let Some(ref permissions_service) = self.permissions_service {
                                  match permissions_service.create_permission_grant(
                                      &response.peer_id,
                                      Capability::Chat,
                                      None, // No expiration
                                  ) {
                                      Ok(_) => {
                                          info!("Granted chat permission to {}", response.peer_id);
                                      }
                                      Err(e) => {
                                          warn!("Failed to grant chat permission: {}", e);
                                      }
                                  }
                              }
          
                              // Emit event to notify frontend
                              let _ = self.event_tx.send(NetworkEvent::ContactAdded {
                                  peer_id: response.peer_id.clone(),
                                  display_name: response.display_name.clone(),
                              });
                          }
                          Err(e) => {
                              warn!("Failed to add contact: {}", e);
                          }
                      }
                  } else {
                      warn!("No contacts service configured, cannot store identity");
                  }
              }
          
              async fn handle_messaging_request(
                  &mut self,
                  peer: PeerId,
                  _request_id: request_response::InboundRequestId,
                  request: MessagingRequest,
                  channel: ResponseChannel<MessagingResponse>,
              ) {
                  // Decode the message payload
                  let msg_result = MessagingCodec::decode(&request.payload);
          
                  let (success, message_id, error) = match msg_result {
                      Ok(MessagingMessage::Message(direct_msg)) => {
                          info!("Received direct message {} from {}", direct_msg.message_id, peer);
          
                          // Process the message if we have a messaging service
                          if let Some(ref messaging_service) = self.messaging_service {
                              match messaging_service.process_incoming_message(
                                  &direct_msg.message_id,
                                  &direct_msg.conversation_id,
                                  &direct_msg.sender_peer_id,
                                  &direct_msg.recipient_peer_id,
                                  &direct_msg.content_encrypted,
                                  &direct_msg.content_type,
                                  direct_msg.reply_to.as_deref(),
                                  direct_msg.nonce_counter,
                                  direct_msg.lamport_clock,
                                  direct_msg.timestamp,
                                  &direct_msg.signature,
                              ) {
                                  Ok(_) => {
                                      info!("Message {} processed successfully", direct_msg.message_id);
                                      (true, Some(direct_msg.message_id.clone()), None)
                                  }
                                  Err(e) => {
                                      warn!("Failed to process message {}: {}", direct_msg.message_id, e);
                                      (false, Some(direct_msg.message_id.clone()), Some(e.to_string()))
                                  }
                              }
                          } else {
                              warn!("No messaging service configured, cannot process message");
                              (false, Some(direct_msg.message_id), Some("Messaging service not available".to_string()))
                          }
                      }
                      Ok(MessagingMessage::Ack(ack)) => {
                          info!("Received message ack for {} from {}", ack.message_id, peer);
                          // TODO: Process acknowledgment (update message status)
                          (true, Some(ack.message_id), None)
                      }
                      Err(e) => {
                          warn!("Failed to decode messaging payload: {}", e);
                          (false, None, Some(format!("Failed to decode: {}", e)))
                      }
                  };
          
                  // Send response
                  let response = MessagingResponse {
                      success,
                      message_id,
                      error,
                  };
          
                  if let Err(e) = self.swarm.behaviour_mut().messaging.send_response(channel, response) {
                      warn!("Failed to send messaging response: {:?}", e);
                  }
          
                  // Emit event for the application layer (for UI updates)
                  let _ = self.event_tx.send(NetworkEvent::MessageReceived {
                      peer_id: peer.to_string(),
                      protocol: "messaging".to_string(),
                      payload: request.payload,
                  }).await;
              }
          
              async fn handle_command(&mut self, command: NetworkCommand) -> NetworkResponse {
                  match command {
                      NetworkCommand::Dial { peer_id, addresses } => {
                          for addr in addresses {
                              self.swarm.behaviour_mut().kademlia.add_address(&peer_id, addr.clone());
                          }
                          match self.swarm.dial(peer_id) {
                              Ok(_) => NetworkResponse::Ok,
                              Err(e) => NetworkResponse::Error(format!("Failed to dial: {}", e)),
                          }
                      }
          
                      NetworkCommand::Disconnect { peer_id } => {
                          match self.swarm.disconnect_peer_id(peer_id) {
                              Ok(_) => NetworkResponse::Ok,
                              Err(e) => NetworkResponse::Error(format!("Failed to disconnect: {:?}", e)),
                          }
                      }
          
                      NetworkCommand::SendMessage { peer_id, protocol, payload } => {
                          let request = MessagingRequest {
                              message_type: protocol,
                              payload,
                          };
                          self.swarm.behaviour_mut().messaging.send_request(&peer_id, request);
                          NetworkResponse::Ok
                      }
          
                      NetworkCommand::RequestIdentity { peer_id } => {
                          // Create identity request
                          match self.create_identity_request() {
                              Ok(request) => {
                                  self.swarm.behaviour_mut().identity_exchange.send_request(&peer_id, request);
                                  NetworkResponse::Ok
                              }
                              Err(e) => NetworkResponse::Error(format!("Failed to create identity request: {}", e)),
                          }
                      }
          
                      NetworkCommand::GetStats => {
                          let mut stats = self.stats.clone();
                          stats.uptime_seconds = self.start_time.elapsed().as_secs();
                          NetworkResponse::Stats(stats)
                      }
          
                      NetworkCommand::GetConnectedPeers => {
                          let peers: Vec<PeerInfo> = self.connected_peers.values().cloned().collect();
                          NetworkResponse::Peers(peers)
                      }
          
                      NetworkCommand::Bootstrap => {
                          if let Err(e) = self.swarm.behaviour_mut().kademlia.bootstrap() {
                              NetworkResponse::Error(format!("Bootstrap failed: {:?}", e))
                          } else {
                              NetworkResponse::Ok
                          }
                      }
          
                      NetworkCommand::Shutdown => {
                          NetworkResponse::Ok
                      }
                  }
              }
          }
          ```

        - ğŸ“ **protocols/**
          - ğŸ“„ **identity_exchange.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\p2p\protocols\identity_exchange.rs`
            *Size*: 3547 bytes | *Modified*: 2026-01-16 17:37:57

            ```
            use serde::{Deserialize, Serialize};
            
            /// Request for identity information from a peer
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct IdentityRequest {
                /// The peer ID of the requester
                pub requester_peer_id: String,
                /// Timestamp of the request
                pub timestamp: i64,
                /// Signature over (requester_peer_id, timestamp) using requester's Ed25519 key
                pub signature: Vec<u8>,
            }
            
            /// Response containing identity information
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct IdentityResponse {
                /// The peer ID (derived from public key)
                pub peer_id: String,
                /// Ed25519 public key
                pub public_key: Vec<u8>,
                /// X25519 public key for key agreement
                pub x25519_public: Vec<u8>,
                /// Display name
                pub display_name: String,
                /// Avatar hash (SHA-256 of avatar image)
                pub avatar_hash: Option<String>,
                /// Bio/description
                pub bio: Option<String>,
                /// Timestamp
                pub timestamp: i64,
                /// Signature over all fields above
                pub signature: Vec<u8>,
            }
            
            /// Codec for identity exchange protocol
            #[derive(Debug, Clone, Default)]
            pub struct IdentityCodec;
            
            impl IdentityCodec {
                /// Encode an identity request to CBOR bytes
                pub fn encode_request(request: &IdentityRequest) -> Result<Vec<u8>, ciborium::ser::Error<std::io::Error>> {
                    let mut bytes = Vec::new();
                    ciborium::into_writer(request, &mut bytes)?;
                    Ok(bytes)
                }
            
                /// Decode an identity request from CBOR bytes
                pub fn decode_request(bytes: &[u8]) -> Result<IdentityRequest, ciborium::de::Error<std::io::Error>> {
                    ciborium::from_reader(bytes)
                }
            
                /// Encode an identity response to CBOR bytes
                pub fn encode_response(response: &IdentityResponse) -> Result<Vec<u8>, ciborium::ser::Error<std::io::Error>> {
                    let mut bytes = Vec::new();
                    ciborium::into_writer(response, &mut bytes)?;
                    Ok(bytes)
                }
            
                /// Decode an identity response from CBOR bytes
                pub fn decode_response(bytes: &[u8]) -> Result<IdentityResponse, ciborium::de::Error<std::io::Error>> {
                    ciborium::from_reader(bytes)
                }
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
            
                #[test]
                fn test_identity_request_roundtrip() {
                    let request = IdentityRequest {
                        requester_peer_id: "12D3KooWTestPeerId".to_string(),
                        timestamp: 1234567890,
                        signature: vec![1, 2, 3, 4],
                    };
            
                    let encoded = IdentityCodec::encode_request(&request).unwrap();
                    let decoded = IdentityCodec::decode_request(&encoded).unwrap();
            
                    assert_eq!(decoded.requester_peer_id, request.requester_peer_id);
                    assert_eq!(decoded.timestamp, request.timestamp);
                    assert_eq!(decoded.signature, request.signature);
                }
            
                #[test]
                fn test_identity_response_roundtrip() {
                    let response = IdentityResponse {
                        peer_id: "12D3KooWTestPeerId".to_string(),
                        public_key: vec![1, 2, 3],
                        x25519_public: vec![4, 5, 6],
                        display_name: "Test User".to_string(),
                        avatar_hash: Some("abc123".to_string()),
                        bio: Some("A test bio".to_string()),
                        timestamp: 1234567890,
                        signature: vec![7, 8, 9],
                    };
            
                    let encoded = IdentityCodec::encode_response(&response).unwrap();
                    let decoded = IdentityCodec::decode_response(&encoded).unwrap();
            
                    assert_eq!(decoded.peer_id, response.peer_id);
                    assert_eq!(decoded.display_name, response.display_name);
                    assert_eq!(decoded.bio, response.bio);
                }
            }
            ```

          - ğŸ“„ **messaging.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\p2p\protocols\messaging.rs`
            *Size*: 6170 bytes | *Modified*: 2026-01-16 18:23:48

            ```
            use serde::{Deserialize, Serialize};
            
            /// A direct message between two peers
            ///
            /// # Nonce Counter & Replay Protection
            ///
            /// The `nonce_counter` field is critical for AES-256-GCM encryption security.
            /// It must be:
            /// - Unique per message within a conversation
            /// - Monotonically increasing for the sender
            ///
            /// ## Sender Rules:
            /// 1. Get next counter via `Database::next_send_counter(conversation_id)`
            /// 2. Use counter for AES-GCM nonce generation
            /// 3. Include counter in this message (signed)
            ///
            /// ## Receiver Rules:
            /// 1. BEFORE decrypting, call `Database::check_and_record_nonce()`
            /// 2. If returns `false` (replay detected), reject the entire message
            /// 3. If returns `true`, proceed with decryption
            /// 4. The nonce is permanently recorded to prevent future replay
            ///
            /// This prevents attackers from re-sending captured messages.
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct DirectMessage {
                /// Unique message ID (UUID v4)
                pub message_id: String,
                /// Conversation ID (derived from sorted peer IDs)
                pub conversation_id: String,
                /// Sender's peer ID
                pub sender_peer_id: String,
                /// Recipient's peer ID
                pub recipient_peer_id: String,
                /// Encrypted message content (AES-256-GCM with counter-based nonce)
                pub content_encrypted: Vec<u8>,
                /// Content type (text, image, etc.)
                pub content_type: String,
                /// ID of message being replied to (optional)
                pub reply_to: Option<String>,
                /// Counter used for AES-GCM nonce generation (for replay protection)
                /// Must be unique per sender per conversation
                pub nonce_counter: u64,
                /// Lamport timestamp for ordering
                pub lamport_clock: u64,
                /// Unix timestamp when message was created
                pub timestamp: i64,
                /// Signature over all fields above (excluding signature itself)
                pub signature: Vec<u8>,
            }
            
            /// Acknowledgment of message delivery/read
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct MessageAck {
                /// ID of the message being acknowledged
                pub message_id: String,
                /// Conversation ID
                pub conversation_id: String,
                /// Peer ID of the one sending the ack
                pub peer_id: String,
                /// Status: delivered or read
                pub status: AckStatus,
                /// Unix timestamp
                pub timestamp: i64,
                /// Signature over all fields above
                pub signature: Vec<u8>,
            }
            
            /// Message acknowledgment status
            #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
            #[serde(rename_all = "snake_case")]
            pub enum AckStatus {
                Delivered,
                Read,
            }
            
            /// Request/response wrapper for messaging protocol
            #[derive(Debug, Clone, Serialize, Deserialize)]
            #[serde(tag = "type", rename_all = "snake_case")]
            pub enum MessagingMessage {
                /// A direct message
                Message(DirectMessage),
                /// An acknowledgment
                Ack(MessageAck),
            }
            
            /// Codec for messaging protocol
            #[derive(Debug, Clone, Default)]
            pub struct MessagingCodec;
            
            impl MessagingCodec {
                /// Encode a messaging message to CBOR bytes
                pub fn encode(msg: &MessagingMessage) -> Result<Vec<u8>, ciborium::ser::Error<std::io::Error>> {
                    let mut bytes = Vec::new();
                    ciborium::into_writer(msg, &mut bytes)?;
                    Ok(bytes)
                }
            
                /// Decode a messaging message from CBOR bytes
                pub fn decode(bytes: &[u8]) -> Result<MessagingMessage, ciborium::de::Error<std::io::Error>> {
                    ciborium::from_reader(bytes)
                }
            }
            
            /// Helper to derive conversation ID from two peer IDs
            pub fn derive_conversation_id(peer_a: &str, peer_b: &str) -> String {
                use sha2::{Sha256, Digest};
            
                // Sort peer IDs to ensure consistent conversation ID regardless of direction
                let (first, second) = if peer_a < peer_b {
                    (peer_a, peer_b)
                } else {
                    (peer_b, peer_a)
                };
            
                let mut hasher = Sha256::new();
                hasher.update(first.as_bytes());
                hasher.update(b":");
                hasher.update(second.as_bytes());
                let result = hasher.finalize();
            
                hex::encode(&result[..16]) // First 16 bytes = 32 hex chars
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
            
                #[test]
                fn test_direct_message_roundtrip() {
                    let msg = DirectMessage {
                        message_id: "msg-123".to_string(),
                        conversation_id: "conv-456".to_string(),
                        sender_peer_id: "peer-a".to_string(),
                        recipient_peer_id: "peer-b".to_string(),
                        content_encrypted: vec![1, 2, 3, 4],
                        content_type: "text".to_string(),
                        reply_to: None,
                        nonce_counter: 1,
                        lamport_clock: 1,
                        timestamp: 1234567890,
                        signature: vec![5, 6, 7, 8],
                    };
            
                    let wrapped = MessagingMessage::Message(msg.clone());
                    let encoded = MessagingCodec::encode(&wrapped).unwrap();
                    let decoded = MessagingCodec::decode(&encoded).unwrap();
            
                    if let MessagingMessage::Message(decoded_msg) = decoded {
                        assert_eq!(decoded_msg.message_id, msg.message_id);
                        assert_eq!(decoded_msg.content_encrypted, msg.content_encrypted);
                    } else {
                        panic!("Expected Message variant");
                    }
                }
            
                #[test]
                fn test_message_ack_roundtrip() {
                    let ack = MessageAck {
                        message_id: "msg-123".to_string(),
                        conversation_id: "conv-456".to_string(),
                        peer_id: "peer-b".to_string(),
                        status: AckStatus::Delivered,
                        timestamp: 1234567890,
                        signature: vec![1, 2, 3],
                    };
            
                    let wrapped = MessagingMessage::Ack(ack.clone());
                    let encoded = MessagingCodec::encode(&wrapped).unwrap();
                    let decoded = MessagingCodec::decode(&encoded).unwrap();
            
                    if let MessagingMessage::Ack(decoded_ack) = decoded {
                        assert_eq!(decoded_ack.message_id, ack.message_id);
                        assert_eq!(decoded_ack.status, AckStatus::Delivered);
                    } else {
                        panic!("Expected Ack variant");
                    }
                }
            
                #[test]
                fn test_conversation_id_deterministic() {
                    let id1 = derive_conversation_id("peer-a", "peer-b");
                    let id2 = derive_conversation_id("peer-b", "peer-a");
            
                    assert_eq!(id1, id2, "Conversation ID should be the same regardless of order");
                }
            }
            ```

          - ğŸ“„ **mod.rs**

            ğŸ“„ *File Path*: `.\src-tauri\src\p2p\protocols\mod.rs`
            *Size*: 563 bytes | *Modified*: 2026-01-16 22:06:03

            ```
            pub mod identity_exchange;
            pub mod messaging;
            
            pub use identity_exchange::*;
            pub use messaging::*;
            
            /// Protocol version string for identity exchange
            pub const IDENTITY_PROTOCOL: &str = "/harbor/identity/1.0.0";
            
            /// Protocol version string for direct messaging
            pub const MESSAGING_PROTOCOL: &str = "/harbor/messaging/1.0.0";
            
            /// Protocol version string for content sync
            pub const CONTENT_SYNC_PROTOCOL: &str = "/harbor/content-sync/1.0.0";
            
            /// Protocol version string for signaling (voice calls)
            pub const SIGNALING_PROTOCOL: &str = "/harbor/signaling/1.0.0";
            ```

        - ğŸ“„ **swarm.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\p2p\swarm.rs`
          *Size*: 2449 bytes | *Modified*: 2026-01-16 17:41:44

          ```
          use libp2p::{
              identity::Keypair,
              noise, tcp, yamux, PeerId, Swarm, SwarmBuilder,
          };
          use tracing::info;
          
          use super::behaviour::ChatBehaviour;
          use super::config::NetworkConfig;
          use crate::error::{AppError, Result};
          
          /// Build a libp2p swarm with all configured protocols
          pub fn build_swarm(
              keypair: Keypair,
              config: &NetworkConfig,
          ) -> Result<Swarm<ChatBehaviour>> {
              let local_peer_id = PeerId::from(keypair.public());
          
              info!("Building swarm with peer ID: {}", local_peer_id);
          
              let swarm = SwarmBuilder::with_existing_identity(keypair)
                  .with_tokio()
                  .with_tcp(
                      tcp::Config::default().nodelay(true),
                      noise::Config::new,
                      yamux::Config::default,
                  )
                  .map_err(|e| AppError::Network(format!("TCP transport error: {}", e)))?
                  .with_quic()
                  .with_relay_client(noise::Config::new, yamux::Config::default)
                  .map_err(|e| AppError::Network(format!("Relay client error: {}", e)))?
                  .with_behaviour(|keypair, relay_behaviour| {
                      Ok(ChatBehaviour::new(
                          PeerId::from(keypair.public()),
                          keypair.public(),
                          relay_behaviour,
                      ))
                  })
                  .map_err(|e| AppError::Network(format!("Behaviour error: {}", e)))?
                  .with_swarm_config(|cfg| {
                      cfg.with_idle_connection_timeout(config.idle_connection_timeout)
                  })
                  .build();
          
              Ok(swarm)
          }
          
          /// Convert our application's Ed25519 keypair to a libp2p Keypair
          pub fn ed25519_to_libp2p_keypair(ed25519_bytes: &[u8; 32]) -> Result<Keypair> {
              let secret = libp2p::identity::ed25519::SecretKey::try_from_bytes(ed25519_bytes.to_vec())
                  .map_err(|e| crate::error::AppError::Crypto(format!("Invalid Ed25519 key: {}", e)))?;
              let keypair = libp2p::identity::ed25519::Keypair::from(secret);
              Ok(Keypair::from(keypair))
          }
          
          #[cfg(test)]
          mod tests {
              use super::*;
          
              #[test]
              fn test_keypair_conversion() {
                  // Generate a random Ed25519 keypair
                  use ed25519_dalek::SigningKey;
                  use rand::rngs::OsRng;
          
                  let signing_key = SigningKey::generate(&mut OsRng);
                  let bytes = signing_key.to_bytes();
          
                  let libp2p_keypair = ed25519_to_libp2p_keypair(&bytes).unwrap();
                  let peer_id = PeerId::from(libp2p_keypair.public());
          
                  // Peer ID should start with "12D3KooW"
                  assert!(peer_id.to_string().starts_with("12D3KooW"));
              }
          }
          ```

        - ğŸ“„ **types.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\p2p\types.rs`
          *Size*: 2726 bytes | *Modified*: 2026-01-17 13:38:46

          ```
          use libp2p::{Multiaddr, PeerId};
          use serde::{Deserialize, Serialize};
          
          /// Network connection status
          #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
          #[serde(rename_all = "snake_case")]
          pub enum ConnectionStatus {
              Disconnected,
              Connecting,
              Connected,
          }
          
          /// Information about a discovered or connected peer
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct PeerInfo {
              pub peer_id: String,
              pub addresses: Vec<String>,
              pub protocol_version: Option<String>,
              pub agent_version: Option<String>,
              pub is_connected: bool,
              pub last_seen: Option<i64>,
          }
          
          /// Network statistics
          #[derive(Debug, Clone, Default, Serialize, Deserialize)]
          #[serde(rename_all = "camelCase")]
          pub struct NetworkStats {
              pub connected_peers: usize,
              pub total_bytes_in: u64,
              pub total_bytes_out: u64,
              pub uptime_seconds: u64,
          }
          
          /// Events emitted by the network layer to the application
          #[derive(Debug, Clone, Serialize, Deserialize)]
          #[serde(tag = "type", rename_all = "snake_case")]
          pub enum NetworkEvent {
              /// A new peer was discovered (e.g., via mDNS)
              PeerDiscovered { peer_id: String },
              /// A peer went offline/expired
              PeerExpired { peer_id: String },
              /// Successfully connected to a peer
              PeerConnected { peer_id: String },
              /// Disconnected from a peer
              PeerDisconnected { peer_id: String },
              /// Our external address was discovered
              ExternalAddressDiscovered { address: String },
              /// Listening on a new address
              ListeningOn { address: String },
              /// An incoming message was received
              MessageReceived {
                  peer_id: String,
                  protocol: String,
                  payload: Vec<u8>,
              },
              /// Network status changed
              StatusChanged { status: ConnectionStatus },
              /// A contact was added via identity exchange
              ContactAdded {
                  peer_id: String,
                  display_name: String,
              },
          }
          
          /// Commands that can be sent to the network service
          #[derive(Debug)]
          pub enum NetworkCommand {
              /// Connect to a specific peer
              Dial { peer_id: PeerId, addresses: Vec<Multiaddr> },
              /// Disconnect from a peer
              Disconnect { peer_id: PeerId },
              /// Send a message to a peer
              SendMessage { peer_id: PeerId, protocol: String, payload: Vec<u8> },
              /// Request identity from a peer
              RequestIdentity { peer_id: PeerId },
              /// Get current network stats
              GetStats,
              /// Get list of connected peers
              GetConnectedPeers,
              /// Bootstrap the DHT
              Bootstrap,
              /// Shutdown the network
              Shutdown,
          }
          
          /// Response to network commands
          #[derive(Debug)]
          pub enum NetworkResponse {
              Ok,
              Stats(NetworkStats),
              Peers(Vec<PeerInfo>),
              Error(String),
          }
          ```

      - ğŸ“ **services/**
        - ğŸ“„ **calling_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\calling_service.rs`
          *Size*: 13088 bytes | *Modified*: 2026-01-17 04:25:07

          ```
          //! Voice calling service using WebRTC signaling
          
          use std::sync::Arc;
          use uuid::Uuid;
          use ed25519_dalek::VerifyingKey;
          
          use crate::db::{Database, Capability};
          use crate::error::{AppError, Result};
          use crate::services::{
              ContactsService, IdentityService, PermissionsService,
              verify,
              SignableSignalingOffer, SignableSignalingAnswer, SignableSignalingIce, SignableSignalingHangup,
          };
          
          /// Call state
          #[derive(Debug, Clone, Copy, PartialEq, Eq)]
          pub enum CallState {
              /// Outgoing call, waiting for answer
              Ringing,
              /// Incoming call, not yet answered
              Incoming,
              /// Call is connected
              Connected,
              /// Call ended
              Ended,
          }
          
          impl CallState {
              pub fn as_str(&self) -> &'static str {
                  match self {
                      CallState::Ringing => "ringing",
                      CallState::Incoming => "incoming",
                      CallState::Connected => "connected",
                      CallState::Ended => "ended",
                  }
              }
          }
          
          /// An active call
          #[derive(Debug, Clone)]
          pub struct Call {
              pub call_id: String,
              pub caller_peer_id: String,
              pub callee_peer_id: String,
              pub state: CallState,
              pub started_at: i64,
              pub ended_at: Option<i64>,
              pub end_reason: Option<String>,
          }
          
          /// Service for managing voice calls
          pub struct CallingService {
              #[allow(dead_code)]
              db: Arc<Database>, // Reserved for future call history storage
              identity_service: Arc<IdentityService>,
              contacts_service: Arc<ContactsService>,
              permissions_service: Arc<PermissionsService>,
          }
          
          /// An outgoing signaling offer
          #[derive(Debug, Clone)]
          pub struct OutgoingOffer {
              pub call_id: String,
              pub caller_peer_id: String,
              pub callee_peer_id: String,
              pub sdp: String,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// An outgoing signaling answer
          #[derive(Debug, Clone)]
          pub struct OutgoingAnswer {
              pub call_id: String,
              pub caller_peer_id: String,
              pub callee_peer_id: String,
              pub sdp: String,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// An outgoing ICE candidate
          #[derive(Debug, Clone)]
          pub struct OutgoingIce {
              pub call_id: String,
              pub sender_peer_id: String,
              pub candidate: String,
              pub sdp_mid: Option<String>,
              pub sdp_mline_index: Option<u32>,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// An outgoing hangup
          #[derive(Debug, Clone)]
          pub struct OutgoingHangup {
              pub call_id: String,
              pub sender_peer_id: String,
              pub reason: String,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          impl CallingService {
              /// Create a new calling service
              pub fn new(
                  db: Arc<Database>,
                  identity_service: Arc<IdentityService>,
                  contacts_service: Arc<ContactsService>,
                  permissions_service: Arc<PermissionsService>,
              ) -> Self {
                  Self {
                      db,
                      identity_service,
                      contacts_service,
                      permissions_service,
                  }
              }
          
              /// Start a call to a peer
              pub fn create_offer(&self, callee_peer_id: &str, sdp: &str) -> Result<OutgoingOffer> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Check we have call permission with this peer
                  if !self.permissions_service.peer_has_capability(callee_peer_id, Capability::Call)? {
                      return Err(AppError::PermissionDenied(
                          "No call permission with this peer".to_string()
                      ));
                  }
          
                  let call_id = Uuid::new_v4().to_string();
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignableSignalingOffer {
                      call_id: call_id.clone(),
                      caller_peer_id: identity.peer_id.clone(),
                      callee_peer_id: callee_peer_id.to_string(),
                      sdp: sdp.to_string(),
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  Ok(OutgoingOffer {
                      call_id,
                      caller_peer_id: identity.peer_id,
                      callee_peer_id: callee_peer_id.to_string(),
                      sdp: sdp.to_string(),
                      timestamp,
                      signature,
                  })
              }
          
              /// Process an incoming offer
              pub fn process_incoming_offer(
                  &self,
                  call_id: &str,
                  caller_peer_id: &str,
                  callee_peer_id: &str,
                  sdp: &str,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Verify we are the callee
                  if callee_peer_id != identity.peer_id {
                      return Err(AppError::Validation("Offer not for us".to_string()));
                  }
          
                  // Verify signature
                  let caller_public_key = self.contacts_service.get_public_key(caller_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Caller not in contacts".to_string()))?;
          
                  let signable = SignableSignalingOffer {
                      call_id: call_id.to_string(),
                      caller_peer_id: caller_peer_id.to_string(),
                      callee_peer_id: callee_peer_id.to_string(),
                      sdp: sdp.to_string(),
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      caller_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid offer signature".to_string()));
                  }
          
                  // Check caller has call permission from us
                  if !self.permissions_service.we_have_capability(caller_peer_id, Capability::Call)? {
                      return Err(AppError::PermissionDenied(
                          "Caller doesn't have call permission".to_string()
                      ));
                  }
          
                  Ok(())
              }
          
              /// Answer a call
              pub fn create_answer(
                  &self,
                  call_id: &str,
                  caller_peer_id: &str,
                  sdp: &str,
              ) -> Result<OutgoingAnswer> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignableSignalingAnswer {
                      call_id: call_id.to_string(),
                      caller_peer_id: caller_peer_id.to_string(),
                      callee_peer_id: identity.peer_id.clone(),
                      sdp: sdp.to_string(),
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  Ok(OutgoingAnswer {
                      call_id: call_id.to_string(),
                      caller_peer_id: caller_peer_id.to_string(),
                      callee_peer_id: identity.peer_id,
                      sdp: sdp.to_string(),
                      timestamp,
                      signature,
                  })
              }
          
              /// Process an incoming answer
              pub fn process_incoming_answer(
                  &self,
                  call_id: &str,
                  caller_peer_id: &str,
                  callee_peer_id: &str,
                  sdp: &str,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Verify we are the caller
                  if caller_peer_id != identity.peer_id {
                      return Err(AppError::Validation("Answer not for our call".to_string()));
                  }
          
                  // Verify signature
                  let callee_public_key = self.contacts_service.get_public_key(callee_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Callee not in contacts".to_string()))?;
          
                  let signable = SignableSignalingAnswer {
                      call_id: call_id.to_string(),
                      caller_peer_id: caller_peer_id.to_string(),
                      callee_peer_id: callee_peer_id.to_string(),
                      sdp: sdp.to_string(),
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      callee_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid answer signature".to_string()));
                  }
          
                  Ok(())
              }
          
              /// Send an ICE candidate
              pub fn create_ice_candidate(
                  &self,
                  call_id: &str,
                  candidate: &str,
                  sdp_mid: Option<&str>,
                  sdp_mline_index: Option<u32>,
              ) -> Result<OutgoingIce> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignableSignalingIce {
                      call_id: call_id.to_string(),
                      sender_peer_id: identity.peer_id.clone(),
                      candidate: candidate.to_string(),
                      sdp_mid: sdp_mid.map(String::from),
                      sdp_mline_index,
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  Ok(OutgoingIce {
                      call_id: call_id.to_string(),
                      sender_peer_id: identity.peer_id,
                      candidate: candidate.to_string(),
                      sdp_mid: sdp_mid.map(String::from),
                      sdp_mline_index,
                      timestamp,
                      signature,
                  })
              }
          
              /// Process an incoming ICE candidate
              pub fn process_incoming_ice(
                  &self,
                  call_id: &str,
                  sender_peer_id: &str,
                  candidate: &str,
                  sdp_mid: Option<&str>,
                  sdp_mline_index: Option<u32>,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Verify signature
                  let sender_public_key = self.contacts_service.get_public_key(sender_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Sender not in contacts".to_string()))?;
          
                  let signable = SignableSignalingIce {
                      call_id: call_id.to_string(),
                      sender_peer_id: sender_peer_id.to_string(),
                      candidate: candidate.to_string(),
                      sdp_mid: sdp_mid.map(String::from),
                      sdp_mline_index,
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      sender_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid ICE candidate signature".to_string()));
                  }
          
                  Ok(())
              }
          
              /// Hang up a call
              pub fn create_hangup(&self, call_id: &str, reason: &str) -> Result<OutgoingHangup> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignableSignalingHangup {
                      call_id: call_id.to_string(),
                      sender_peer_id: identity.peer_id.clone(),
                      reason: reason.to_string(),
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  Ok(OutgoingHangup {
                      call_id: call_id.to_string(),
                      sender_peer_id: identity.peer_id,
                      reason: reason.to_string(),
                      timestamp,
                      signature,
                  })
              }
          
              /// Process an incoming hangup
              pub fn process_incoming_hangup(
                  &self,
                  call_id: &str,
                  sender_peer_id: &str,
                  reason: &str,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Verify signature
                  let sender_public_key = self.contacts_service.get_public_key(sender_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Sender not in contacts".to_string()))?;
          
                  let signable = SignableSignalingHangup {
                      call_id: call_id.to_string(),
                      sender_peer_id: sender_peer_id.to_string(),
                      reason: reason.to_string(),
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      sender_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid hangup signature".to_string()));
                  }
          
                  Ok(())
              }
          }
          ```

        - ğŸ“„ **contacts_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\contacts_service.rs`
          *Size*: 6975 bytes | *Modified*: 2026-01-16 21:39:31

          ```
          //! Contacts service for managing peer relationships
          
          use std::sync::Arc;
          use crate::db::{Database, ContactData, ContactsRepository, Contact};
          use crate::error::{AppError, Result};
          use crate::services::IdentityService;
          
          /// Service for managing contacts
          pub struct ContactsService {
              db: Arc<Database>,
              identity_service: Arc<IdentityService>,
          }
          
          impl ContactsService {
              /// Create a new contacts service
              pub fn new(db: Arc<Database>, identity_service: Arc<IdentityService>) -> Self {
                  Self { db, identity_service }
              }
          
              /// Add a new contact from identity exchange data
              pub fn add_contact(
                  &self,
                  peer_id: &str,
                  public_key: &[u8],
                  x25519_public: &[u8],
                  display_name: &str,
                  avatar_hash: Option<&str>,
                  bio: Option<&str>,
              ) -> Result<i64> {
                  // Don't add ourselves as a contact
                  if let Some(identity) = self.identity_service.get_identity()? {
                      if identity.peer_id == peer_id {
                          return Err(AppError::Validation("Cannot add self as contact".to_string()));
                      }
                  }
          
                  // Check if already a contact
                  if ContactsRepository::is_contact(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                  {
                      // Update existing contact info instead
                      ContactsRepository::update_contact_info(
                          &self.db,
                          peer_id,
                          display_name,
                          avatar_hash,
                          bio,
                      ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                      // Return existing contact's ID
                      let contact = ContactsRepository::get_by_peer_id(&self.db, peer_id)
                          .map_err(|e| AppError::DatabaseString(e.to_string()))?
                          .ok_or_else(|| AppError::NotFound("Contact not found".to_string()))?;
                      return Ok(contact.id);
                  }
          
                  let contact_data = ContactData {
                      peer_id: peer_id.to_string(),
                      public_key: public_key.to_vec(),
                      x25519_public: x25519_public.to_vec(),
                      display_name: display_name.to_string(),
                      avatar_hash: avatar_hash.map(String::from),
                      bio: bio.map(String::from),
                  };
          
                  ContactsRepository::add_contact(&self.db, &contact_data)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get a contact by peer ID
              pub fn get_contact(&self, peer_id: &str) -> Result<Option<Contact>> {
                  ContactsRepository::get_by_peer_id(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get all contacts
              pub fn get_all_contacts(&self) -> Result<Vec<Contact>> {
                  ContactsRepository::get_all(&self.db)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get all non-blocked contacts
              pub fn get_active_contacts(&self) -> Result<Vec<Contact>> {
                  ContactsRepository::get_active(&self.db)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Update contact info (from network)
              pub fn update_contact_info(
                  &self,
                  peer_id: &str,
                  display_name: &str,
                  avatar_hash: Option<&str>,
                  bio: Option<&str>,
              ) -> Result<bool> {
                  ContactsRepository::update_contact_info(&self.db, peer_id, display_name, avatar_hash, bio)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Update last seen timestamp for a contact
              pub fn update_last_seen(&self, peer_id: &str) -> Result<bool> {
                  ContactsRepository::update_last_seen(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Block a contact
              pub fn block_contact(&self, peer_id: &str) -> Result<bool> {
                  ContactsRepository::block_contact(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Unblock a contact
              pub fn unblock_contact(&self, peer_id: &str) -> Result<bool> {
                  ContactsRepository::unblock_contact(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Remove a contact
              pub fn remove_contact(&self, peer_id: &str) -> Result<bool> {
                  ContactsRepository::remove_contact(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Check if peer is a contact
              pub fn is_contact(&self, peer_id: &str) -> Result<bool> {
                  ContactsRepository::is_contact(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Check if peer is blocked
              pub fn is_blocked(&self, peer_id: &str) -> Result<bool> {
                  ContactsRepository::is_blocked(&self.db, peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get X25519 public key for a contact (needed for encryption)
              pub fn get_x25519_public(&self, peer_id: &str) -> Result<Option<Vec<u8>>> {
                  let contact = self.get_contact(peer_id)?;
                  Ok(contact.map(|c| c.x25519_public))
              }
          
              /// Get Ed25519 public key for a contact (needed for signature verification)
              pub fn get_public_key(&self, peer_id: &str) -> Result<Option<Vec<u8>>> {
                  let contact = self.get_contact(peer_id)?;
                  Ok(contact.map(|c| c.public_key))
              }
          }
          
          #[cfg(test)]
          mod tests {
              use super::*;
              use std::sync::Arc;
          
              fn create_test_services() -> (Arc<Database>, Arc<IdentityService>, ContactsService) {
                  let db = Arc::new(Database::in_memory().unwrap());
                  let identity_service = Arc::new(IdentityService::new(db.clone()));
                  let contacts_service = ContactsService::new(db.clone(), identity_service.clone());
                  (db, identity_service, contacts_service)
              }
          
              #[test]
              fn test_add_and_get_contact() {
                  let (_, _, service) = create_test_services();
          
                  let id = service.add_contact(
                      "12D3KooWTest",
                      &[1, 2, 3, 4],
                      &[5, 6, 7, 8],
                      "Test User",
                      None,
                      Some("Hello!"),
                  ).unwrap();
          
                  assert!(id > 0);
          
                  let contact = service.get_contact("12D3KooWTest").unwrap().unwrap();
                  assert_eq!(contact.display_name, "Test User");
                  assert_eq!(contact.bio, Some("Hello!".to_string()));
              }
          
              #[test]
              fn test_block_contact() {
                  let (_, _, service) = create_test_services();
          
                  service.add_contact(
                      "12D3KooWTest",
                      &[1, 2, 3, 4],
                      &[5, 6, 7, 8],
                      "Test User",
                      None,
                      None,
                  ).unwrap();
          
                  assert!(!service.is_blocked("12D3KooWTest").unwrap());
          
                  service.block_contact("12D3KooWTest").unwrap();
                  assert!(service.is_blocked("12D3KooWTest").unwrap());
          
                  // Blocked contacts shouldn't appear in active list
                  let active = service.get_active_contacts().unwrap();
                  assert!(active.is_empty());
              }
          }
          ```

        - ğŸ“„ **content_sync_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\content_sync_service.rs`
          *Size*: 12786 bytes | *Modified*: 2026-01-17 04:19:10

          ```
          //! Content sync service for synchronizing posts between peers
          
          use std::collections::HashMap;
          use std::sync::Arc;
          
          use ed25519_dalek::VerifyingKey;
          
          use crate::db::{Database, PostsRepository, PostData, PostVisibility, Capability};
          use crate::error::{AppError, Result};
          use crate::services::{
              ContactsService, IdentityService, PermissionsService,
              verify,
              SignableContentManifestRequest, SignableContentManifestResponse, PostSummary,
              SignablePost,
          };
          
          /// Service for syncing content between peers
          pub struct ContentSyncService {
              db: Arc<Database>,
              identity_service: Arc<IdentityService>,
              contacts_service: Arc<ContactsService>,
              permissions_service: Arc<PermissionsService>,
          }
          
          /// A request for content manifest
          #[derive(Debug, Clone)]
          pub struct OutgoingManifestRequest {
              pub requester_peer_id: String,
              pub cursor: HashMap<String, u64>,
              pub limit: u32,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// A response with content manifest
          #[derive(Debug, Clone)]
          pub struct OutgoingManifestResponse {
              pub responder_peer_id: String,
              pub posts: Vec<PostSummary>,
              pub has_more: bool,
              pub next_cursor: HashMap<String, u64>,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          impl ContentSyncService {
              /// Create a new content sync service
              pub fn new(
                  db: Arc<Database>,
                  identity_service: Arc<IdentityService>,
                  contacts_service: Arc<ContactsService>,
                  permissions_service: Arc<PermissionsService>,
              ) -> Self {
                  Self {
                      db,
                      identity_service,
                      contacts_service,
                      permissions_service,
                  }
              }
          
              /// Create a manifest request to send to a peer
              pub fn create_manifest_request(
                  &self,
                  cursor: HashMap<String, u64>,
                  limit: u32,
              ) -> Result<OutgoingManifestRequest> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignableContentManifestRequest {
                      requester_peer_id: identity.peer_id.clone(),
                      cursor: cursor.clone(),
                      limit,
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  Ok(OutgoingManifestRequest {
                      requester_peer_id: identity.peer_id,
                      cursor,
                      limit,
                      timestamp,
                      signature,
                  })
              }
          
              /// Process an incoming manifest request and create a response
              pub fn process_manifest_request(
                  &self,
                  requester_peer_id: &str,
                  cursor: &HashMap<String, u64>,
                  limit: u32,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<OutgoingManifestResponse> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Verify the requester's signature
                  let requester_public_key = self.contacts_service.get_public_key(requester_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Requester not in contacts".to_string()))?;
          
                  let signable = SignableContentManifestRequest {
                      requester_peer_id: requester_peer_id.to_string(),
                      cursor: cursor.clone(),
                      limit,
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      requester_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid manifest request signature".to_string()));
                  }
          
                  // Check if the requester has WallRead permission from us
                  if !self.permissions_service.peer_has_capability(requester_peer_id, Capability::WallRead)? {
                      return Err(AppError::PermissionDenied(
                          "Requester doesn't have WallRead permission".to_string()
                      ));
                  }
          
                  // Get our posts that the requester hasn't seen yet
                  // The cursor maps our peer_id to the highest lamport clock they've seen
                  let our_cursor = cursor.get(&identity.peer_id).copied().unwrap_or(0);
          
                  // Get posts newer than the cursor
                  let posts = self.get_posts_after_cursor(&identity.peer_id, our_cursor, limit)?;
          
                  // Build post summaries
                  let post_summaries: Vec<PostSummary> = posts
                      .iter()
                      .map(|post| {
                          let media_hashes = PostsRepository::get_media_hashes(&self.db, &post.post_id)
                              .unwrap_or_default();
          
                          PostSummary {
                              post_id: post.post_id.clone(),
                              author_peer_id: post.author_peer_id.clone(),
                              lamport_clock: post.lamport_clock as u64,
                              content_type: post.content_type.clone(),
                              has_media: !media_hashes.is_empty(),
                              media_hashes,
                              created_at: post.created_at,
                          }
                      })
                      .collect();
          
                  // Calculate next cursor
                  let mut next_cursor = cursor.clone();
                  if let Some(last_post) = posts.last() {
                      next_cursor.insert(identity.peer_id.clone(), last_post.lamport_clock as u64);
                  }
          
                  let has_more = posts.len() as u32 >= limit;
          
                  let response_timestamp = chrono::Utc::now().timestamp();
          
                  let response_signable = SignableContentManifestResponse {
                      responder_peer_id: identity.peer_id.clone(),
                      posts: post_summaries.clone(),
                      has_more,
                      next_cursor: next_cursor.clone(),
                      timestamp: response_timestamp,
                  };
          
                  let response_signature = self.identity_service.sign(&response_signable)?;
          
                  Ok(OutgoingManifestResponse {
                      responder_peer_id: identity.peer_id,
                      posts: post_summaries,
                      has_more,
                      next_cursor,
                      timestamp: response_timestamp,
                      signature: response_signature,
                  })
              }
          
              /// Process an incoming manifest response
              pub fn process_manifest_response(
                  &self,
                  responder_peer_id: &str,
                  posts: &[PostSummary],
                  has_more: bool,
                  next_cursor: &HashMap<String, u64>,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<Vec<String>> {
                  // Verify the responder's signature
                  let responder_public_key = self.contacts_service.get_public_key(responder_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Responder not in contacts".to_string()))?;
          
                  let signable = SignableContentManifestResponse {
                      responder_peer_id: responder_peer_id.to_string(),
                      posts: posts.to_vec(),
                      has_more,
                      next_cursor: next_cursor.clone(),
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      responder_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid manifest response signature".to_string()));
                  }
          
                  // Return list of post IDs we need to fetch
                  let mut posts_to_fetch = Vec::new();
          
                  for summary in posts {
                      // Check if we already have this post with the same or newer lamport clock
                      if let Some(existing) = PostsRepository::get_by_post_id(&self.db, &summary.post_id)
                          .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      {
                          if existing.lamport_clock as u64 >= summary.lamport_clock {
                              continue; // We have a newer or same version
                          }
                      }
                      posts_to_fetch.push(summary.post_id.clone());
                  }
          
                  // Store the cursor for future requests
                  self.store_sync_cursor(responder_peer_id, next_cursor)?;
          
                  Ok(posts_to_fetch)
              }
          
              /// Store a post received from a peer
              pub fn store_remote_post(
                  &self,
                  post_id: &str,
                  author_peer_id: &str,
                  content_type: &str,
                  content_text: Option<&str>,
                  visibility: &str,
                  lamport_clock: u64,
                  created_at: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Verify the signature
                  let author_public_key = self.contacts_service.get_public_key(author_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Author not in contacts".to_string()))?;
          
                  let signable = SignablePost {
                      post_id: post_id.to_string(),
                      author_peer_id: author_peer_id.to_string(),
                      content_type: content_type.to_string(),
                      content_text: content_text.map(String::from),
                      media_hashes: Vec::new(), // Will be added separately
                      visibility: visibility.to_string(),
                      lamport_clock,
                      created_at,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      author_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid post signature".to_string()));
                  }
          
                  // Check for existing post
                  if let Some(existing) = PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                  {
                      if existing.lamport_clock as u64 >= lamport_clock {
                          return Ok(()); // We have a newer or same version
                      }
                      // Update existing post
                      PostsRepository::update_post(
                          &self.db,
                          post_id,
                          content_text,
                          created_at,
                          lamport_clock as i64,
                      ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
                  } else {
                      // Insert new post
                      let vis = PostVisibility::from_str(visibility)
                          .unwrap_or(PostVisibility::Contacts);
          
                      let post_data = PostData {
                          post_id: post_id.to_string(),
                          author_peer_id: author_peer_id.to_string(),
                          content_type: content_type.to_string(),
                          content_text: content_text.map(String::from),
                          visibility: vis,
                          lamport_clock: lamport_clock as i64,
                          created_at,
                          signature: signature.to_vec(),
                      };
          
                      PostsRepository::insert_remote_post(&self.db, &post_data)
                          .map_err(|e| AppError::DatabaseString(e.to_string()))?;
                  }
          
                  // Update lamport clock
                  self.db.update_lamport_clock(author_peer_id, lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(())
              }
          
              /// Get posts after a certain lamport clock cursor
              fn get_posts_after_cursor(
                  &self,
                  author_peer_id: &str,
                  cursor: u64,
                  limit: u32,
              ) -> Result<Vec<crate::db::Post>> {
                  // For now, just get posts and filter by lamport clock
                  // TODO: Add a more efficient query
                  let posts = PostsRepository::get_by_author(&self.db, author_peer_id, 1000, None)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  let filtered: Vec<_> = posts
                      .into_iter()
                      .filter(|p| p.lamport_clock as u64 > cursor)
                      .take(limit as usize)
                      .collect();
          
                  Ok(filtered)
              }
          
              /// Store sync cursor for a peer
              fn store_sync_cursor(&self, _peer_id: &str, _cursor: &HashMap<String, u64>) -> Result<()> {
                  // For now, we don't persist the cursor - it's ephemeral
                  // TODO: Persist cursor to database for resumable syncs
                  Ok(())
              }
          
              /// Get stored sync cursor for a peer
              pub fn get_sync_cursor(&self, _peer_id: &str) -> Result<HashMap<String, u64>> {
                  // For now, return empty cursor
                  // TODO: Load from database
                  Ok(HashMap::new())
              }
          }
          ```

        - ğŸ“„ **crypto_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\crypto_service.rs`
          *Size*: 22208 bytes | *Modified*: 2026-01-18 09:47:16

          ```
          use crate::error::{AppError, Result};
          use crate::models::EncryptedKeys;
          
          use aes_gcm::{
              aead::{Aead, KeyInit, OsRng},
              Aes256Gcm, Nonce,
          };
          use argon2::{password_hash::SaltString, Argon2, PasswordHasher};
          use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
          use rand::RngCore;
          use sha2::{Sha256, Digest};
          use x25519_dalek::{StaticSecret as X25519Secret, PublicKey as X25519Public};
          
          /// Cryptographic operations service
          pub struct CryptoService;
          
          impl CryptoService {
              /// Generate a new Ed25519 keypair for signing
              pub fn generate_ed25519_keypair() -> (SigningKey, VerifyingKey) {
                  let signing_key = SigningKey::generate(&mut OsRng);
                  let verifying_key = signing_key.verifying_key();
                  (signing_key, verifying_key)
              }
          
              /// Generate a new X25519 keypair for key agreement
              pub fn generate_x25519_keypair() -> (X25519Secret, X25519Public) {
                  let secret = X25519Secret::random_from_rng(OsRng);
                  let public = X25519Public::from(&secret);
                  (secret, public)
              }
          
              /// Derive a peer ID from an Ed25519 signing key
              /// Uses libp2p's actual PeerId derivation for compatibility with the network layer
              pub fn derive_peer_id_from_signing_key(signing_key: &SigningKey) -> String {
                  // Convert our ed25519_dalek SigningKey to libp2p's format
                  let secret = libp2p::identity::ed25519::SecretKey::try_from_bytes(signing_key.to_bytes().to_vec())
                      .expect("Valid Ed25519 key");
                  let libp2p_keypair = libp2p::identity::ed25519::Keypair::from(secret);
                  let libp2p_keypair = libp2p::identity::Keypair::from(libp2p_keypair);
                  let peer_id = libp2p::PeerId::from(libp2p_keypair.public());
                  peer_id.to_string()
              }
          
              /// Derive a peer ID from an Ed25519 public key (DEPRECATED - use derive_peer_id_from_signing_key)
              /// This uses a simplified hash-based approach that is NOT compatible with libp2p
              #[deprecated(note = "Use derive_peer_id_from_signing_key instead for libp2p compatibility")]
              pub fn derive_peer_id(public_key: &VerifyingKey) -> String {
                  let mut hasher = Sha256::new();
                  hasher.update(public_key.as_bytes());
                  let hash = hasher.finalize();
          
                  // Format as base58-like string with "12D3KooW" prefix (simplified)
                  // WARNING: This is NOT the same as libp2p's PeerId format!
                  format!("12D3KooW{}", hex::encode(&hash[..16]))
              }
          
              /// Encrypt private keys using a passphrase
              pub fn encrypt_keys(
                  ed25519_private: &[u8],
                  x25519_private: &[u8],
                  passphrase: &str,
              ) -> Result<Vec<u8>> {
                  // Derive encryption key from passphrase using Argon2id
                  let salt = SaltString::generate(&mut OsRng);
                  let argon2 = Argon2::default();
          
                  let password_hash = argon2
                      .hash_password(passphrase.as_bytes(), &salt)
                      .map_err(|e| AppError::Crypto(format!("Failed to hash passphrase: {}", e)))?;
          
                  let hash_bytes = password_hash.hash.ok_or_else(|| {
                      AppError::Crypto("Failed to get hash bytes".to_string())
                  })?;
          
                  // Use first 32 bytes of hash as AES key
                  let key_bytes: [u8; 32] = hash_bytes.as_bytes()[..32]
                      .try_into()
                      .map_err(|_| AppError::Crypto("Invalid key length".to_string()))?;
          
                  let cipher = Aes256Gcm::new_from_slice(&key_bytes)
                      .map_err(|e| AppError::Crypto(format!("Failed to create cipher: {}", e)))?;
          
                  // Generate random nonce
                  let mut nonce_bytes = [0u8; 12];
                  OsRng.fill_bytes(&mut nonce_bytes);
                  let nonce = Nonce::from_slice(&nonce_bytes);
          
                  // Combine keys for encryption
                  let keys = EncryptedKeys {
                      ed25519_private: ed25519_private.to_vec(),
                      x25519_private: x25519_private.to_vec(),
                  };
                  let plaintext = serde_json::to_vec(&keys)
                      .map_err(|e| AppError::Serialization(format!("Failed to serialize keys: {}", e)))?;
          
                  // Encrypt
                  let ciphertext = cipher
                      .encrypt(nonce, plaintext.as_ref())
                      .map_err(|e| AppError::Crypto(format!("Encryption failed: {}", e)))?;
          
                  // Combine: salt (22 bytes as string) + nonce (12 bytes) + ciphertext
                  let salt_bytes = salt.as_str().as_bytes();
                  let mut result = Vec::with_capacity(salt_bytes.len() + 1 + 12 + ciphertext.len());
                  result.push(salt_bytes.len() as u8);
                  result.extend_from_slice(salt_bytes);
                  result.extend_from_slice(&nonce_bytes);
                  result.extend_from_slice(&ciphertext);
          
                  Ok(result)
              }
          
              /// Decrypt private keys using a passphrase
              pub fn decrypt_keys(encrypted: &[u8], passphrase: &str) -> Result<EncryptedKeys> {
                  if encrypted.is_empty() {
                      return Err(AppError::Crypto("Empty encrypted data".to_string()));
                  }
          
                  // Parse: salt_len (1 byte) + salt + nonce (12 bytes) + ciphertext
                  let salt_len = encrypted[0] as usize;
                  if encrypted.len() < 1 + salt_len + 12 {
                      return Err(AppError::Crypto("Invalid encrypted data format".to_string()));
                  }
          
                  let salt_str = std::str::from_utf8(&encrypted[1..1 + salt_len])
                      .map_err(|e| AppError::Crypto(format!("Invalid salt: {}", e)))?;
          
                  let salt = SaltString::from_b64(salt_str)
                      .map_err(|e| AppError::Crypto(format!("Invalid salt format: {}", e)))?;
          
                  let nonce_start = 1 + salt_len;
                  let nonce_bytes: [u8; 12] = encrypted[nonce_start..nonce_start + 12]
                      .try_into()
                      .map_err(|_| AppError::Crypto("Invalid nonce length".to_string()))?;
          
                  let ciphertext = &encrypted[nonce_start + 12..];
          
                  // Derive key from passphrase
                  let argon2 = Argon2::default();
                  let password_hash = argon2
                      .hash_password(passphrase.as_bytes(), &salt)
                      .map_err(|e| AppError::Crypto(format!("Failed to hash passphrase: {}", e)))?;
          
                  let hash_bytes = password_hash.hash.ok_or_else(|| {
                      AppError::Crypto("Failed to get hash bytes".to_string())
                  })?;
          
                  let key_bytes: [u8; 32] = hash_bytes.as_bytes()[..32]
                      .try_into()
                      .map_err(|_| AppError::Crypto("Invalid key length".to_string()))?;
          
                  // Decrypt
                  let cipher = Aes256Gcm::new_from_slice(&key_bytes)
                      .map_err(|e| AppError::Crypto(format!("Failed to create cipher: {}", e)))?;
          
                  let nonce = Nonce::from_slice(&nonce_bytes);
          
                  let plaintext = cipher
                      .decrypt(nonce, ciphertext)
                      .map_err(|_| AppError::Crypto("Decryption failed - wrong passphrase?".to_string()))?;
          
                  let keys: EncryptedKeys = serde_json::from_slice(&plaintext)
                      .map_err(|e| AppError::Serialization(format!("Failed to deserialize keys: {}", e)))?;
          
                  Ok(keys)
              }
          
              /// Sign data using Ed25519
              pub fn sign(signing_key: &SigningKey, data: &[u8]) -> Signature {
                  signing_key.sign(data)
              }
          
              /// Verify an Ed25519 signature
              pub fn verify(verifying_key: &VerifyingKey, data: &[u8], signature: &Signature) -> bool {
                  verifying_key.verify(data, signature).is_ok()
              }
          
              /// Perform X25519 Diffie-Hellman key exchange
              pub fn x25519_dh(our_secret: &X25519Secret, their_public: &X25519Public) -> [u8; 32] {
                  our_secret.diffie_hellman(their_public).to_bytes()
              }
          
              /// Derive a symmetric key from shared secret using HKDF
              ///
              /// DEPRECATED: Use `derive_conversation_key` instead for conversation encryption.
              /// This function is kept for backwards compatibility only.
              pub fn derive_symmetric_key(shared_secret: &[u8], context: &[u8]) -> [u8; 32] {
                  use hkdf::Hkdf;
          
                  let hk = Hkdf::<Sha256>::new(Some(context), shared_secret);
                  let mut key = [0u8; 32];
                  hk.expand(b"harbor-v1", &mut key).expect("HKDF expand failed");
                  key
              }
          
              /// Derive a conversation encryption key from X25519 shared secret
              ///
              /// The salt includes:
              /// - Protocol version prefix for domain separation
              /// - Conversation ID (deterministic from peer IDs)
              /// - Both peer IDs in sorted order (for consistency regardless of who initiates)
              ///
              /// This hardening prevents accidental cross-context key reuse.
              pub fn derive_conversation_key(
                  shared_secret: &[u8; 32],
                  conversation_id: &str,
                  peer_a: &str,
                  peer_b: &str,
              ) -> [u8; 32] {
                  use hkdf::Hkdf;
          
                  // Sort peer IDs for consistent salt regardless of direction
                  let (first, second) = if peer_a < peer_b {
                      (peer_a, peer_b)
                  } else {
                      (peer_b, peer_a)
                  };
          
                  // Build salt with full context
                  let salt = format!(
                      "harbor:v1:conv:{}:{}:{}",
                      conversation_id, first, second
                  );
          
                  let hk = Hkdf::<Sha256>::new(Some(salt.as_bytes()), shared_secret);
                  let mut key = [0u8; 32];
                  hk.expand(b"conversation-key", &mut key).expect("HKDF expand failed");
                  key
              }
          
              /// Encrypt a message using AES-256-GCM
              pub fn encrypt_message(key: &[u8; 32], plaintext: &[u8]) -> Result<Vec<u8>> {
                  let cipher = Aes256Gcm::new_from_slice(key)
                      .map_err(|e| AppError::Crypto(format!("Failed to create cipher: {}", e)))?;
          
                  let mut nonce_bytes = [0u8; 12];
                  OsRng.fill_bytes(&mut nonce_bytes);
                  let nonce = Nonce::from_slice(&nonce_bytes);
          
                  let ciphertext = cipher
                      .encrypt(nonce, plaintext)
                      .map_err(|e| AppError::Crypto(format!("Encryption failed: {}", e)))?;
          
                  // Combine nonce + ciphertext
                  let mut result = Vec::with_capacity(12 + ciphertext.len());
                  result.extend_from_slice(&nonce_bytes);
                  result.extend_from_slice(&ciphertext);
          
                  Ok(result)
              }
          
              /// Decrypt a message using AES-256-GCM
              pub fn decrypt_message(key: &[u8; 32], encrypted: &[u8]) -> Result<Vec<u8>> {
                  if encrypted.len() < 12 {
                      return Err(AppError::Crypto("Invalid encrypted message".to_string()));
                  }
          
                  let nonce = Nonce::from_slice(&encrypted[..12]);
                  let ciphertext = &encrypted[12..];
          
                  let cipher = Aes256Gcm::new_from_slice(key)
                      .map_err(|e| AppError::Crypto(format!("Failed to create cipher: {}", e)))?;
          
                  let plaintext = cipher
                      .decrypt(nonce, ciphertext)
                      .map_err(|_| AppError::Crypto("Decryption failed".to_string()))?;
          
                  Ok(plaintext)
              }
          
              /// Hash data using SHA-256
              pub fn sha256(data: &[u8]) -> [u8; 32] {
                  let mut hasher = Sha256::new();
                  hasher.update(data);
                  hasher.finalize().into()
              }
          
              // ============================================================
              // Counter-based Nonce Functions (for conversation encryption)
              // ============================================================
          
              /// Generate a deterministic nonce from a send counter
              ///
              /// The nonce is 12 bytes (96 bits) for AES-GCM:
              /// - First 4 bytes: 0x00 (reserved for future use/direction flag)
              /// - Next 8 bytes: counter as big-endian u64
              ///
              /// This ensures unique nonces as long as:
              /// 1. Counter is never reused for the same conversation
              /// 2. Counter increases monotonically
              pub fn nonce_from_counter(counter: u64) -> [u8; 12] {
                  let mut nonce = [0u8; 12];
                  // First 4 bytes are zero (can use for direction flag later)
                  // Last 8 bytes are the counter
                  nonce[4..12].copy_from_slice(&counter.to_be_bytes());
                  nonce
              }
          
              /// Encrypt a message using AES-256-GCM with a counter-based nonce
              ///
              /// IMPORTANT: The counter MUST be unique for each message in a conversation.
              /// Use `Database::next_send_counter()` to get the next counter value.
              pub fn encrypt_message_with_counter(
                  key: &[u8; 32],
                  plaintext: &[u8],
                  counter: u64,
              ) -> Result<Vec<u8>> {
                  let cipher = Aes256Gcm::new_from_slice(key)
                      .map_err(|e| AppError::Crypto(format!("Failed to create cipher: {}", e)))?;
          
                  let nonce_bytes = Self::nonce_from_counter(counter);
                  let nonce = Nonce::from_slice(&nonce_bytes);
          
                  let ciphertext = cipher
                      .encrypt(nonce, plaintext)
                      .map_err(|e| AppError::Crypto(format!("Encryption failed: {}", e)))?;
          
                  // Return only ciphertext - counter is sent separately in message header
                  Ok(ciphertext)
              }
          
              /// Decrypt a message using AES-256-GCM with a counter-based nonce
              ///
              /// IMPORTANT: Before calling this, verify the counter hasn't been used before
              /// using `Database::check_and_record_nonce()`.
              pub fn decrypt_message_with_counter(
                  key: &[u8; 32],
                  ciphertext: &[u8],
                  counter: u64,
              ) -> Result<Vec<u8>> {
                  let cipher = Aes256Gcm::new_from_slice(key)
                      .map_err(|e| AppError::Crypto(format!("Failed to create cipher: {}", e)))?;
          
                  let nonce_bytes = Self::nonce_from_counter(counter);
                  let nonce = Nonce::from_slice(&nonce_bytes);
          
                  let plaintext = cipher
                      .decrypt(nonce, ciphertext)
                      .map_err(|_| AppError::Crypto("Decryption failed".to_string()))?;
          
                  Ok(plaintext)
              }
          }
          
          #[cfg(test)]
          mod tests {
              use super::*;
          
              #[test]
              fn test_ed25519_keypair_generation() {
                  let (signing_key, verifying_key) = CryptoService::generate_ed25519_keypair();
          
                  // Sign and verify
                  let message = b"Hello, World!";
                  let signature = CryptoService::sign(&signing_key, message);
                  assert!(CryptoService::verify(&verifying_key, message, &signature));
          
                  // Wrong message should fail
                  assert!(!CryptoService::verify(&verifying_key, b"Wrong message", &signature));
              }
          
              #[test]
              fn test_x25519_key_exchange() {
                  let (alice_secret, alice_public) = CryptoService::generate_x25519_keypair();
                  let (bob_secret, bob_public) = CryptoService::generate_x25519_keypair();
          
                  let alice_shared = CryptoService::x25519_dh(&alice_secret, &bob_public);
                  let bob_shared = CryptoService::x25519_dh(&bob_secret, &alice_public);
          
                  assert_eq!(alice_shared, bob_shared);
              }
          
              #[test]
              fn test_key_encryption_decryption() {
                  let ed25519_private = [1u8; 32];
                  let x25519_private = [2u8; 32];
                  let passphrase = "test-passphrase-123";
          
                  let encrypted = CryptoService::encrypt_keys(
                      &ed25519_private,
                      &x25519_private,
                      passphrase,
                  ).unwrap();
          
                  let decrypted = CryptoService::decrypt_keys(&encrypted, passphrase).unwrap();
          
                  assert_eq!(decrypted.ed25519_private, ed25519_private);
                  assert_eq!(decrypted.x25519_private, x25519_private);
              }
          
              #[test]
              fn test_key_decryption_wrong_passphrase() {
                  let ed25519_private = [1u8; 32];
                  let x25519_private = [2u8; 32];
          
                  let encrypted = CryptoService::encrypt_keys(
                      &ed25519_private,
                      &x25519_private,
                      "correct-passphrase",
                  ).unwrap();
          
                  let result = CryptoService::decrypt_keys(&encrypted, "wrong-passphrase");
                  assert!(result.is_err());
              }
          
              #[test]
              fn test_message_encryption() {
                  let key = [0u8; 32];
                  let message = b"Secret message";
          
                  let encrypted = CryptoService::encrypt_message(&key, message).unwrap();
                  let decrypted = CryptoService::decrypt_message(&key, &encrypted).unwrap();
          
                  assert_eq!(decrypted, message);
              }
          
              #[test]
              fn test_peer_id_derivation_libp2p() {
                  let (signing_key, _) = CryptoService::generate_ed25519_keypair();
                  let peer_id = CryptoService::derive_peer_id_from_signing_key(&signing_key);
          
                  // libp2p peer IDs start with "12D3KooW" and are longer (base58 encoded)
                  assert!(peer_id.starts_with("12D3KooW"));
                  // Full libp2p peer ID is typically 52 characters
                  assert!(peer_id.len() >= 50, "Peer ID should be a full libp2p PeerId: {}", peer_id);
              }
          
              #[test]
              fn test_peer_id_matches_network_keypair() {
                  // This test verifies that derive_peer_id_from_signing_key produces the same
                  // peer ID as the network layer would when using ed25519_to_libp2p_keypair
                  let (signing_key, _) = CryptoService::generate_ed25519_keypair();
          
                  // Method 1: Our derive_peer_id_from_signing_key function
                  let derived_peer_id = CryptoService::derive_peer_id_from_signing_key(&signing_key);
          
                  // Method 2: The same way the network layer derives it
                  let bytes = signing_key.to_bytes();
                  let secret = libp2p::identity::ed25519::SecretKey::try_from_bytes(bytes.to_vec())
                      .expect("Valid Ed25519 key");
                  let keypair = libp2p::identity::ed25519::Keypair::from(secret);
                  let libp2p_keypair = libp2p::identity::Keypair::from(keypair);
                  let network_peer_id = libp2p::PeerId::from(libp2p_keypair.public()).to_string();
          
                  assert_eq!(
                      derived_peer_id, network_peer_id,
                      "Peer ID mismatch! Identity service: {} vs Network: {}",
                      derived_peer_id, network_peer_id
                  );
              }
          
              #[test]
              #[allow(deprecated)]
              fn test_peer_id_derivation_legacy() {
                  let (_, verifying_key) = CryptoService::generate_ed25519_keypair();
                  let peer_id = CryptoService::derive_peer_id(&verifying_key);
          
                  assert!(peer_id.starts_with("12D3KooW"));
                  assert_eq!(peer_id.len(), 8 + 32); // prefix + hex
              }
          
              #[test]
              fn test_nonce_from_counter() {
                  let nonce1 = CryptoService::nonce_from_counter(1);
                  let nonce2 = CryptoService::nonce_from_counter(2);
                  let nonce_max = CryptoService::nonce_from_counter(u64::MAX);
          
                  // Nonces should be different
                  assert_ne!(nonce1, nonce2);
          
                  // First 4 bytes should be zero
                  assert_eq!(&nonce1[0..4], &[0, 0, 0, 0]);
                  assert_eq!(&nonce_max[0..4], &[0, 0, 0, 0]);
          
                  // Counter should be in last 8 bytes as big-endian
                  assert_eq!(&nonce1[4..12], &1u64.to_be_bytes());
                  assert_eq!(&nonce2[4..12], &2u64.to_be_bytes());
              }
          
              #[test]
              fn test_counter_based_encryption() {
                  let key = [42u8; 32];
                  let message = b"Secret message with counter";
          
                  // Encrypt with counter 1
                  let ciphertext = CryptoService::encrypt_message_with_counter(&key, message, 1).unwrap();
          
                  // Decrypt with same counter
                  let decrypted = CryptoService::decrypt_message_with_counter(&key, &ciphertext, 1).unwrap();
                  assert_eq!(decrypted, message);
          
                  // Decrypt with wrong counter should fail
                  let result = CryptoService::decrypt_message_with_counter(&key, &ciphertext, 2);
                  assert!(result.is_err());
              }
          
              #[test]
              fn test_same_message_different_counters() {
                  let key = [42u8; 32];
                  let message = b"Same message";
          
                  let ciphertext1 = CryptoService::encrypt_message_with_counter(&key, message, 1).unwrap();
                  let ciphertext2 = CryptoService::encrypt_message_with_counter(&key, message, 2).unwrap();
          
                  // Same plaintext with different counters produces different ciphertext
                  assert_ne!(ciphertext1, ciphertext2);
          
                  // Both decrypt correctly with their respective counters
                  let decrypted1 = CryptoService::decrypt_message_with_counter(&key, &ciphertext1, 1).unwrap();
                  let decrypted2 = CryptoService::decrypt_message_with_counter(&key, &ciphertext2, 2).unwrap();
                  assert_eq!(decrypted1, message);
                  assert_eq!(decrypted2, message);
              }
          
              #[test]
              fn test_derive_conversation_key_deterministic() {
                  let shared_secret = [0x42u8; 32];
                  let conv_id = "conv-123";
                  let peer_a = "12D3KooWAlice";
                  let peer_b = "12D3KooWBob";
          
                  let key1 = CryptoService::derive_conversation_key(&shared_secret, conv_id, peer_a, peer_b);
                  let key2 = CryptoService::derive_conversation_key(&shared_secret, conv_id, peer_a, peer_b);
          
                  assert_eq!(key1, key2, "Same inputs should produce same key");
              }
          
              #[test]
              fn test_derive_conversation_key_order_independent() {
                  let shared_secret = [0x42u8; 32];
                  let conv_id = "conv-123";
                  let peer_a = "12D3KooWAlice";
                  let peer_b = "12D3KooWBob";
          
                  // Order of peer IDs shouldn't matter
                  let key_ab = CryptoService::derive_conversation_key(&shared_secret, conv_id, peer_a, peer_b);
                  let key_ba = CryptoService::derive_conversation_key(&shared_secret, conv_id, peer_b, peer_a);
          
                  assert_eq!(key_ab, key_ba, "Peer order should not affect key derivation");
              }
          
              #[test]
              fn test_derive_conversation_key_different_conversations() {
                  let shared_secret = [0x42u8; 32];
                  let peer_a = "12D3KooWAlice";
                  let peer_b = "12D3KooWBob";
          
                  let key1 = CryptoService::derive_conversation_key(&shared_secret, "conv-1", peer_a, peer_b);
                  let key2 = CryptoService::derive_conversation_key(&shared_secret, "conv-2", peer_a, peer_b);
          
                  assert_ne!(key1, key2, "Different conversations should have different keys");
              }
          
              #[test]
              fn test_derive_conversation_key_different_peers() {
                  let shared_secret = [0x42u8; 32];
                  let conv_id = "conv-123";
          
                  let key1 = CryptoService::derive_conversation_key(
                      &shared_secret, conv_id, "12D3KooWAlice", "12D3KooWBob"
                  );
                  let key2 = CryptoService::derive_conversation_key(
                      &shared_secret, conv_id, "12D3KooWAlice", "12D3KooWCharlie"
                  );
          
                  assert_ne!(key1, key2, "Different peer combinations should have different keys");
              }
          
              #[test]
              fn test_derive_conversation_key_different_secrets() {
                  let secret1 = [0x42u8; 32];
                  let secret2 = [0x43u8; 32];
                  let conv_id = "conv-123";
                  let peer_a = "12D3KooWAlice";
                  let peer_b = "12D3KooWBob";
          
                  let key1 = CryptoService::derive_conversation_key(&secret1, conv_id, peer_a, peer_b);
                  let key2 = CryptoService::derive_conversation_key(&secret2, conv_id, peer_a, peer_b);
          
                  assert_ne!(key1, key2, "Different shared secrets should produce different keys");
              }
          }
          ```

        - ğŸ“„ **feed_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\feed_service.rs`
          *Size*: 5453 bytes | *Modified*: 2026-01-17 04:18:14

          ```
          //! Feed service for aggregating posts from contacts
          
          use std::sync::Arc;
          
          use crate::db::{Database, Capability, PostsRepository, Post, PostVisibility};
          use crate::error::{AppError, Result};
          use crate::services::{IdentityService, PermissionsService};
          
          /// Service for managing the user's feed
          pub struct FeedService {
              db: Arc<Database>,
              identity_service: Arc<IdentityService>,
              permissions_service: Arc<PermissionsService>,
          }
          
          /// A feed item (post with additional context)
          #[derive(Debug, Clone)]
          pub struct FeedItem {
              pub post: Post,
              pub author_display_name: Option<String>,
          }
          
          impl FeedService {
              /// Create a new feed service
              pub fn new(
                  db: Arc<Database>,
                  identity_service: Arc<IdentityService>,
                  permissions_service: Arc<PermissionsService>,
              ) -> Self {
                  Self {
                      db,
                      identity_service,
                      permissions_service,
                  }
              }
          
              /// Get the user's feed (posts from contacts who granted us WallRead)
              ///
              /// The feed includes:
              /// - Our own posts (always visible)
              /// - Posts from contacts who granted us WallRead permission
              /// - Only non-deleted posts
              /// - Sorted by creation time, newest first
              pub fn get_feed(&self, limit: i64, before_timestamp: Option<i64>) -> Result<Vec<FeedItem>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Get all peer IDs who granted us WallRead
                  let permissions = self.permissions_service.get_received_permissions()?;
                  let mut allowed_authors: Vec<String> = permissions
                      .iter()
                      .filter(|p| p.capability == "wall_read" && p.revoked_at.is_none())
                      .map(|p| p.issuer_peer_id.clone())
                      .collect();
          
                  // Always include our own posts
                  allowed_authors.push(identity.peer_id.clone());
          
                  // Deduplicate
                  allowed_authors.sort();
                  allowed_authors.dedup();
          
                  // Get posts from all allowed authors
                  let mut all_posts = Vec::new();
                  for author in &allowed_authors {
                      let posts = PostsRepository::get_by_author(&self.db, author, limit, before_timestamp)
                          .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                      // Filter: if it's not our own post and visibility is "contacts",
                      // make sure we have permission (we already checked above)
                      for post in posts {
                          if post.author_peer_id == identity.peer_id {
                              // Our own posts are always visible
                              all_posts.push(post);
                          } else if post.visibility == PostVisibility::Public {
                              // Public posts are always visible
                              all_posts.push(post);
                          } else if post.visibility == PostVisibility::Contacts {
                              // Contacts-only posts require WallRead permission (already verified above)
                              all_posts.push(post);
                          }
                      }
                  }
          
                  // Sort by created_at descending
                  all_posts.sort_by(|a, b| b.created_at.cmp(&a.created_at));
          
                  // Apply limit
                  all_posts.truncate(limit as usize);
          
                  // Convert to FeedItems
                  let feed_items: Vec<FeedItem> = all_posts
                      .into_iter()
                      .map(|post| {
                          // TODO: Look up display name from contacts
                          FeedItem {
                              post,
                              author_display_name: None,
                          }
                      })
                      .collect();
          
                  Ok(feed_items)
              }
          
              /// Get posts from a specific author (their wall)
              /// Requires WallRead permission if not our own posts
              pub fn get_wall(&self, author_peer_id: &str, limit: i64, before_timestamp: Option<i64>) -> Result<Vec<FeedItem>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Check permission if not our own wall
                  if author_peer_id != identity.peer_id {
                      if !self.permissions_service.we_have_capability(author_peer_id, Capability::WallRead)? {
                          return Err(AppError::PermissionDenied(
                              "No permission to view this wall".to_string()
                          ));
                      }
                  }
          
                  let posts = PostsRepository::get_by_author(&self.db, author_peer_id, limit, before_timestamp)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Filter by visibility
                  let visible_posts: Vec<Post> = posts
                      .into_iter()
                      .filter(|post| {
                          if post.author_peer_id == identity.peer_id {
                              true // Our own posts
                          } else if post.visibility == PostVisibility::Public {
                              true // Public posts
                          } else {
                              // Contacts-only posts require permission (verified above)
                              true
                          }
                      })
                      .collect();
          
                  let feed_items: Vec<FeedItem> = visible_posts
                      .into_iter()
                      .map(|post| FeedItem {
                          post,
                          author_display_name: None,
                      })
                      .collect();
          
                  Ok(feed_items)
              }
          }
          ```

        - ğŸ“„ **identity_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\identity_service.rs`
          *Size*: 9874 bytes | *Modified*: 2026-01-18 09:33:35

          ```
          use crate::db::Database;
          use crate::db::repositories::IdentityRepository;
          use crate::error::{AppError, Result};
          use crate::models::{CreateIdentityRequest, IdentityInfo, LocalIdentity};
          use crate::services::{CryptoService, Signable, sign as signing_sign};
          
          use ed25519_dalek::SigningKey;
          use std::sync::{Arc, RwLock};
          use tracing::info;
          use x25519_dalek::StaticSecret as X25519Secret;
          
          /// Service for managing the local user's identity
          pub struct IdentityService {
              db: Arc<Database>,
              /// Cached unlocked keys (only available after unlock)
              unlocked_keys: Arc<RwLock<Option<UnlockedKeys>>>,
          }
          
          /// Keys that are available after unlocking with passphrase
          #[derive(Clone)]
          pub struct UnlockedKeys {
              pub ed25519_signing: SigningKey,
              pub x25519_secret: X25519Secret,
          }
          
          impl IdentityService {
              pub fn new(db: Arc<Database>) -> Self {
                  Self {
                      db,
                      unlocked_keys: Arc::new(RwLock::new(None)),
                  }
              }
          
              /// Check if an identity has been created
              pub fn has_identity(&self) -> Result<bool> {
                  let repo = IdentityRepository::new(&self.db);
                  repo.exists().map_err(Into::into)
              }
          
              /// Check if the identity is currently unlocked
              pub fn is_unlocked(&self) -> bool {
                  self.unlocked_keys.read().unwrap().is_some()
              }
          
              /// Get identity info (public data only)
              pub fn get_identity_info(&self) -> Result<Option<IdentityInfo>> {
                  let repo = IdentityRepository::new(&self.db);
                  match repo.get()? {
                      Some(identity) => Ok(Some(identity.into())),
                      None => Ok(None),
                  }
              }
          
              /// Create a new identity with the given display name and passphrase
              pub fn create_identity(&self, request: CreateIdentityRequest) -> Result<IdentityInfo> {
                  let repo = IdentityRepository::new(&self.db);
          
                  // Check if identity already exists
                  if repo.exists()? {
                      return Err(AppError::AlreadyExists("Identity already exists".to_string()));
                  }
          
                  // Generate Ed25519 keypair for signing
                  let (ed25519_signing, ed25519_verifying) = CryptoService::generate_ed25519_keypair();
          
                  // Generate X25519 keypair for key agreement
                  let (x25519_secret, x25519_public) = CryptoService::generate_x25519_keypair();
          
                  // Derive peer ID using libp2p's format for network compatibility
                  let peer_id = CryptoService::derive_peer_id_from_signing_key(&ed25519_signing);
                  info!("Derived peer ID from signing key: {} (length: {})", peer_id, peer_id.len());
          
                  // Encrypt private keys
                  let encrypted_keys = CryptoService::encrypt_keys(
                      ed25519_signing.to_bytes().as_ref(),
                      x25519_secret.as_bytes(),
                      &request.passphrase,
                  )?;
          
                  let now = chrono::Utc::now().timestamp();
          
                  let identity = LocalIdentity {
                      peer_id: peer_id.clone(),
                      public_key: ed25519_verifying.to_bytes().to_vec(),
                      x25519_public: x25519_public.to_bytes().to_vec(),
                      private_key_encrypted: encrypted_keys,
                      display_name: request.display_name,
                      avatar_hash: None,
                      bio: request.bio,
                      created_at: now,
                      updated_at: now,
                  };
          
                  repo.create(&identity)?;
          
                  // Auto-unlock after creation
                  {
                      let mut unlocked = self.unlocked_keys.write().unwrap();
                      *unlocked = Some(UnlockedKeys {
                          ed25519_signing,
                          x25519_secret,
                      });
                  }
          
                  info!("Created new identity: {}", peer_id);
                  Ok(identity.into())
              }
          
              /// Unlock the identity with the passphrase
              pub fn unlock(&self, passphrase: &str) -> Result<IdentityInfo> {
                  let repo = IdentityRepository::new(&self.db);
          
                  let identity = repo.get()?.ok_or_else(|| {
                      AppError::NotFound("No identity found".to_string())
                  })?;
          
                  // Decrypt private keys
                  let keys = CryptoService::decrypt_keys(&identity.private_key_encrypted, passphrase)?;
          
                  // Reconstruct signing key
                  let ed25519_bytes: [u8; 32] = keys.ed25519_private.try_into()
                      .map_err(|_| AppError::Crypto("Invalid Ed25519 key length".to_string()))?;
                  let ed25519_signing = SigningKey::from_bytes(&ed25519_bytes);
          
                  // Reconstruct X25519 secret
                  let x25519_bytes: [u8; 32] = keys.x25519_private.try_into()
                      .map_err(|_| AppError::Crypto("Invalid X25519 key length".to_string()))?;
                  let x25519_secret = X25519Secret::from(x25519_bytes);
          
                  // Store unlocked keys
                  {
                      let mut unlocked = self.unlocked_keys.write().unwrap();
                      *unlocked = Some(UnlockedKeys {
                          ed25519_signing,
                          x25519_secret,
                      });
                  }
          
                  info!("Identity unlocked: {}", identity.peer_id);
                  Ok(identity.into())
              }
          
              /// Lock the identity (clear unlocked keys from memory)
              pub fn lock(&self) {
                  let mut unlocked = self.unlocked_keys.write().unwrap();
                  *unlocked = None;
                  info!("Identity locked");
              }
          
              /// Get the unlocked keys (for signing/encryption operations)
              pub fn get_unlocked_keys(&self) -> Result<UnlockedKeys> {
                  let unlocked = self.unlocked_keys.read().unwrap();
                  unlocked.clone().ok_or_else(|| {
                      AppError::PermissionDenied("Identity is locked".to_string())
                  })
              }
          
              /// Sign raw data using the unlocked Ed25519 key
              pub fn sign_raw(&self, data: &[u8]) -> Result<Vec<u8>> {
                  let keys = self.get_unlocked_keys()?;
                  let signature = CryptoService::sign(&keys.ed25519_signing, data);
                  Ok(signature.to_bytes().to_vec())
              }
          
              /// Sign a Signable object using canonical CBOR encoding
              pub fn sign<T: Signable>(&self, signable: &T) -> Result<Vec<u8>> {
                  let keys = self.get_unlocked_keys()?;
                  signing_sign(&keys.ed25519_signing, signable)
              }
          
              /// Get the full identity (for internal use)
              pub fn get_identity(&self) -> Result<Option<LocalIdentity>> {
                  let repo = IdentityRepository::new(&self.db);
                  repo.get().map_err(Into::into)
              }
          
              /// Update display name
              pub fn update_display_name(&self, display_name: &str) -> Result<()> {
                  let repo = IdentityRepository::new(&self.db);
                  repo.update_display_name(display_name)?;
                  Ok(())
              }
          
              /// Update bio
              pub fn update_bio(&self, bio: Option<&str>) -> Result<()> {
                  let repo = IdentityRepository::new(&self.db);
                  repo.update_bio(bio)?;
                  Ok(())
              }
          
              /// Get the local peer ID
              pub fn get_peer_id(&self) -> Result<String> {
                  let repo = IdentityRepository::new(&self.db);
                  let identity = repo.get()?.ok_or_else(|| {
                      AppError::NotFound("No identity found".to_string())
                  })?;
                  Ok(identity.peer_id)
              }
          }
          
          impl Clone for IdentityService {
              fn clone(&self) -> Self {
                  Self {
                      db: Arc::clone(&self.db),
                      unlocked_keys: Arc::clone(&self.unlocked_keys),
                  }
              }
          }
          
          #[cfg(test)]
          mod tests {
              use super::*;
          
              fn create_test_service() -> IdentityService {
                  let db = Arc::new(Database::in_memory().unwrap());
                  IdentityService::new(db)
              }
          
              #[test]
              fn test_no_identity_initially() {
                  let service = create_test_service();
                  assert!(!service.has_identity().unwrap());
                  assert!(!service.is_unlocked());
              }
          
              #[test]
              fn test_create_identity() {
                  let service = create_test_service();
          
                  let request = CreateIdentityRequest {
                      display_name: "Test User".to_string(),
                      passphrase: "test-passphrase".to_string(),
                      bio: Some("Test bio".to_string()),
                  };
          
                  let info = service.create_identity(request).unwrap();
          
                  assert!(info.peer_id.starts_with("12D3KooW"));
                  assert_eq!(info.display_name, "Test User");
                  assert_eq!(info.bio, Some("Test bio".to_string()));
          
                  // Should be auto-unlocked after creation
                  assert!(service.is_unlocked());
                  assert!(service.has_identity().unwrap());
              }
          
              #[test]
              fn test_lock_unlock() {
                  let service = create_test_service();
          
                  let request = CreateIdentityRequest {
                      display_name: "Test User".to_string(),
                      passphrase: "test-passphrase".to_string(),
                      bio: None,
                  };
          
                  service.create_identity(request).unwrap();
                  assert!(service.is_unlocked());
          
                  // Lock
                  service.lock();
                  assert!(!service.is_unlocked());
          
                  // Unlock with correct passphrase
                  service.unlock("test-passphrase").unwrap();
                  assert!(service.is_unlocked());
              }
          
              #[test]
              fn test_wrong_passphrase() {
                  let service = create_test_service();
          
                  let request = CreateIdentityRequest {
                      display_name: "Test User".to_string(),
                      passphrase: "correct-passphrase".to_string(),
                      bio: None,
                  };
          
                  service.create_identity(request).unwrap();
                  service.lock();
          
                  // Wrong passphrase should fail
                  let result = service.unlock("wrong-passphrase");
                  assert!(result.is_err());
              }
          
              #[test]
              fn test_sign_requires_unlock() {
                  let service = create_test_service();
          
                  let request = CreateIdentityRequest {
                      display_name: "Test User".to_string(),
                      passphrase: "test-passphrase".to_string(),
                      bio: None,
                  };
          
                  service.create_identity(request).unwrap();
          
                  // Can sign when unlocked
                  let signature = service.sign_raw(b"test data").unwrap();
                  assert!(!signature.is_empty());
          
                  // Lock
                  service.lock();
          
                  // Cannot sign when locked
                  let result = service.sign_raw(b"test data");
                  assert!(result.is_err());
              }
          }
          ```

        - ğŸ“„ **messaging_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\messaging_service.rs`
          *Size*: 20294 bytes | *Modified*: 2026-01-18 09:35:19

          ```
          //! Messaging service for sending and receiving direct messages
          
          use std::sync::Arc;
          use uuid::Uuid;
          use ed25519_dalek::VerifyingKey;
          use x25519_dalek::PublicKey as X25519Public;
          
          use crate::db::{
              Database, Capability, MessagesRepository, MessageData, MessageStatus, Conversation,
          };
          use crate::error::{AppError, Result};
          use crate::p2p::protocols::messaging::derive_conversation_id;
          use crate::services::{
              ContactsService, CryptoService, IdentityService, PermissionsService,
              verify, Signable, SignableDirectMessage, SignableMessageAck,
          };
          
          /// Service for managing direct messages
          pub struct MessagingService {
              db: Arc<Database>,
              identity_service: Arc<IdentityService>,
              contacts_service: Arc<ContactsService>,
              permissions_service: Arc<PermissionsService>,
          }
          
          /// A decrypted message for the UI
          #[derive(Debug, Clone)]
          pub struct DecryptedMessage {
              pub message_id: String,
              pub conversation_id: String,
              pub sender_peer_id: String,
              pub recipient_peer_id: String,
              pub content: String,
              pub content_type: String,
              pub reply_to_message_id: Option<String>,
              pub sent_at: i64,
              pub delivered_at: Option<i64>,
              pub read_at: Option<i64>,
              pub status: String,
              pub is_outgoing: bool,
          }
          
          /// A message ready to be sent over the network
          #[derive(Debug, Clone)]
          pub struct OutgoingMessage {
              pub message_id: String,
              pub conversation_id: String,
              pub sender_peer_id: String,
              pub recipient_peer_id: String,
              pub content_encrypted: Vec<u8>,
              pub content_type: String,
              pub reply_to: Option<String>,
              pub nonce_counter: u64,
              pub lamport_clock: u64,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          impl MessagingService {
              /// Create a new messaging service
              pub fn new(
                  db: Arc<Database>,
                  identity_service: Arc<IdentityService>,
                  contacts_service: Arc<ContactsService>,
                  permissions_service: Arc<PermissionsService>,
              ) -> Self {
                  Self {
                      db,
                      identity_service,
                      contacts_service,
                      permissions_service,
                  }
              }
          
              /// Send a new message to a peer
              pub fn send_message(
                  &self,
                  recipient_peer_id: &str,
                  content: &str,
                  content_type: &str,
                  reply_to: Option<&str>,
              ) -> Result<OutgoingMessage> {
                  // Get our identity
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Check we have chat permission with this peer
                  if !self.permissions_service.peer_has_capability(recipient_peer_id, Capability::Chat)? {
                      return Err(AppError::PermissionDenied(
                          "No chat permission with this peer".to_string()
                      ));
                  }
          
                  // Get recipient's X25519 public key for encryption
                  let x25519_public = self.contacts_service.get_x25519_public(recipient_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Contact not found".to_string()))?;
          
                  // Get our X25519 keys
                  let our_keys = self.identity_service.get_unlocked_keys()?;
          
                  // Derive conversation ID and encryption key
                  let conversation_id = derive_conversation_id(&identity.peer_id, recipient_peer_id);
                  let their_public = X25519Public::from(
                      <[u8; 32]>::try_from(x25519_public.as_slice())
                          .map_err(|_| AppError::Crypto("Invalid X25519 key".to_string()))?
                  );
                  let shared_secret = CryptoService::x25519_dh(&our_keys.x25519_secret, &their_public);
                  let conv_key = CryptoService::derive_conversation_key(
                      &shared_secret,
                      &conversation_id,
                      &identity.peer_id,
                      recipient_peer_id,
                  );
          
                  // Get next nonce counter
                  let nonce_counter = self.db.next_send_counter(&conversation_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Encrypt content
                  let content_encrypted = CryptoService::encrypt_message_with_counter(
                      &conv_key,
                      content.as_bytes(),
                      nonce_counter,
                  )?;
          
                  // Create message
                  let message_id = Uuid::new_v4().to_string();
                  let lamport_clock = self.db.next_lamport_clock(&identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))? as u64;
                  let timestamp = chrono::Utc::now().timestamp();
          
                  // Create signable and sign
                  tracing::info!(
                      "MESSAGE SEND - sender_peer_id: {} (len={}), recipient_peer_id: {} (len={})",
                      identity.peer_id,
                      identity.peer_id.len(),
                      recipient_peer_id,
                      recipient_peer_id.len()
                  );
                  let signable = SignableDirectMessage {
                      message_id: message_id.clone(),
                      conversation_id: conversation_id.clone(),
                      sender_peer_id: identity.peer_id.clone(),
                      recipient_peer_id: recipient_peer_id.to_string(),
                      content_encrypted: content_encrypted.clone(),
                      content_type: content_type.to_string(),
                      reply_to: reply_to.map(String::from),
                      nonce_counter,
                      lamport_clock,
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  // Store locally
                  let msg_data = MessageData {
                      message_id: message_id.clone(),
                      conversation_id: conversation_id.clone(),
                      sender_peer_id: identity.peer_id.clone(),
                      recipient_peer_id: recipient_peer_id.to_string(),
                      content_encrypted: content_encrypted.clone(),
                      content_type: content_type.to_string(),
                      reply_to_message_id: reply_to.map(String::from),
                      nonce_counter,
                      lamport_clock: lamport_clock as i64,
                      sent_at: timestamp,
                      received_at: None,
                      status: MessageStatus::Pending,
                  };
          
                  MessagesRepository::insert_message(&self.db, &msg_data)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = format!("sent:{}", message_id);
                  let payload_cbor = signable.signable_bytes()?;
                  MessagesRepository::record_message_event(
                      &self.db,
                      &event_id,
                      "sent",
                      &message_id,
                      &conversation_id,
                      &identity.peer_id,
                      recipient_peer_id,
                      lamport_clock as i64,
                      timestamp,
                      &payload_cbor,
                      &signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(OutgoingMessage {
                      message_id,
                      conversation_id,
                      sender_peer_id: identity.peer_id,
                      recipient_peer_id: recipient_peer_id.to_string(),
                      content_encrypted,
                      content_type: content_type.to_string(),
                      reply_to: reply_to.map(String::from),
                      nonce_counter,
                      lamport_clock,
                      timestamp,
                      signature,
                  })
              }
          
              /// Process an incoming message from the network
              pub fn process_incoming_message(
                  &self,
                  message_id: &str,
                  conversation_id: &str,
                  sender_peer_id: &str,
                  recipient_peer_id: &str,
                  content_encrypted: &[u8],
                  content_type: &str,
                  reply_to: Option<&str>,
                  nonce_counter: u64,
                  lamport_clock: u64,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Verify we are the recipient
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  tracing::info!(
                      "MESSAGE RECEIVE - recipient in msg: {} (len={}) vs our identity: {} (len={})",
                      recipient_peer_id,
                      recipient_peer_id.len(),
                      identity.peer_id,
                      identity.peer_id.len()
                  );
          
                  if recipient_peer_id != identity.peer_id {
                      tracing::error!(
                          "MESSAGE REJECTED - peer ID mismatch. Message for {} but we are {}",
                          recipient_peer_id,
                          identity.peer_id
                      );
                      return Err(AppError::Validation("Message not for us".to_string()));
                  }
          
                  // Check for replay (BEFORE decryption)
                  if !self.db.check_and_record_nonce(conversation_id, sender_peer_id, nonce_counter)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                  {
                      return Err(AppError::Crypto("Replay attack detected".to_string()));
                  }
          
                  // Get sender's public key for verification
                  tracing::info!(
                      "Looking up sender {} in contacts",
                      sender_peer_id
                  );
                  let sender_public_key = self.contacts_service.get_public_key(sender_peer_id)?
                      .ok_or_else(|| {
                          tracing::error!(
                              "CONTACT LOOKUP FAILED - sender_peer_id {} not found in contacts",
                              sender_peer_id
                          );
                          AppError::NotFound("Sender not in contacts".to_string())
                      })?;
          
                  // Verify signature
                  let signable = SignableDirectMessage {
                      message_id: message_id.to_string(),
                      conversation_id: conversation_id.to_string(),
                      sender_peer_id: sender_peer_id.to_string(),
                      recipient_peer_id: recipient_peer_id.to_string(),
                      content_encrypted: content_encrypted.to_vec(),
                      content_type: content_type.to_string(),
                      reply_to: reply_to.map(String::from),
                      nonce_counter,
                      lamport_clock,
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      sender_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid message signature".to_string()));
                  }
          
                  // Check for deduplication
                  if MessagesRepository::message_exists(&self.db, message_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                  {
                      return Ok(()); // Already processed
                  }
          
                  // Update lamport clock
                  self.db.update_lamport_clock(sender_peer_id, lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Store message
                  let received_at = chrono::Utc::now().timestamp();
                  let msg_data = MessageData {
                      message_id: message_id.to_string(),
                      conversation_id: conversation_id.to_string(),
                      sender_peer_id: sender_peer_id.to_string(),
                      recipient_peer_id: recipient_peer_id.to_string(),
                      content_encrypted: content_encrypted.to_vec(),
                      content_type: content_type.to_string(),
                      reply_to_message_id: reply_to.map(String::from),
                      nonce_counter,
                      lamport_clock: lamport_clock as i64,
                      sent_at: timestamp,
                      received_at: Some(received_at),
                      status: MessageStatus::Delivered,
                  };
          
                  MessagesRepository::insert_message(&self.db, &msg_data)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = format!("received:{}", message_id);
                  let payload_cbor = signable.signable_bytes()?;
                  MessagesRepository::record_message_event(
                      &self.db,
                      &event_id,
                      "received",
                      message_id,
                      conversation_id,
                      sender_peer_id,
                      recipient_peer_id,
                      lamport_clock as i64,
                      timestamp,
                      &payload_cbor,
                      signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(())
              }
          
              /// Create a delivery acknowledgment
              pub fn create_delivery_ack(&self, message_id: &str) -> Result<(SignableMessageAck, Vec<u8>)> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let message = MessagesRepository::get_by_message_id(&self.db, message_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      .ok_or_else(|| AppError::NotFound("Message not found".to_string()))?;
          
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignableMessageAck {
                      message_id: message_id.to_string(),
                      conversation_id: message.conversation_id.clone(),
                      ack_sender_peer_id: identity.peer_id.clone(),
                      status: "delivered".to_string(),
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  Ok((signable, signature))
              }
          
              /// Create a read acknowledgment
              pub fn create_read_ack(&self, message_id: &str) -> Result<(SignableMessageAck, Vec<u8>)> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let message = MessagesRepository::get_by_message_id(&self.db, message_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      .ok_or_else(|| AppError::NotFound("Message not found".to_string()))?;
          
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignableMessageAck {
                      message_id: message_id.to_string(),
                      conversation_id: message.conversation_id.clone(),
                      ack_sender_peer_id: identity.peer_id.clone(),
                      status: "read".to_string(),
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  // Mark as read locally
                  MessagesRepository::mark_read(&self.db, message_id, timestamp)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok((signable, signature))
              }
          
              /// Process an incoming acknowledgment
              pub fn process_incoming_ack(
                  &self,
                  message_id: &str,
                  conversation_id: &str,
                  ack_sender_peer_id: &str,
                  status: &str,
                  timestamp: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Get the ack sender's public key
                  let sender_public_key = self.contacts_service.get_public_key(ack_sender_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Ack sender not in contacts".to_string()))?;
          
                  // Verify signature
                  let signable = SignableMessageAck {
                      message_id: message_id.to_string(),
                      conversation_id: conversation_id.to_string(),
                      ack_sender_peer_id: ack_sender_peer_id.to_string(),
                      status: status.to_string(),
                      timestamp,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      sender_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid ack signature".to_string()));
                  }
          
                  // Update message status
                  match status {
                      "delivered" => {
                          MessagesRepository::mark_delivered(&self.db, message_id, timestamp)
                              .map_err(|e| AppError::DatabaseString(e.to_string()))?;
                      }
                      "read" => {
                          MessagesRepository::mark_read(&self.db, message_id, timestamp)
                              .map_err(|e| AppError::DatabaseString(e.to_string()))?;
                      }
                      _ => {
                          return Err(AppError::Validation(format!("Invalid ack status: {}", status)));
                      }
                  }
          
                  Ok(())
              }
          
              /// Get messages for a conversation, decrypted
              pub fn get_conversation_messages(
                  &self,
                  peer_id: &str,
                  limit: i64,
                  before_timestamp: Option<i64>,
              ) -> Result<Vec<DecryptedMessage>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let conversation_id = derive_conversation_id(&identity.peer_id, peer_id);
          
                  // Get encrypted messages
                  let messages = MessagesRepository::get_conversation_messages(
                      &self.db,
                      &conversation_id,
                      limit,
                      before_timestamp,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Get peer's X25519 key for decryption
                  let x25519_public = self.contacts_service.get_x25519_public(peer_id)?
                      .ok_or_else(|| AppError::NotFound("Contact not found".to_string()))?;
          
                  let our_keys = self.identity_service.get_unlocked_keys()?;
          
                  // Derive conversation key
                  let their_public = X25519Public::from(
                      <[u8; 32]>::try_from(x25519_public.as_slice())
                          .map_err(|_| AppError::Crypto("Invalid X25519 key".to_string()))?
                  );
                  let shared_secret = CryptoService::x25519_dh(&our_keys.x25519_secret, &their_public);
                  let conv_key = CryptoService::derive_conversation_key(
                      &shared_secret,
                      &conversation_id,
                      &identity.peer_id,
                      peer_id,
                  );
          
                  // Decrypt messages
                  let mut decrypted = Vec::new();
                  for msg in messages {
                      let content = match CryptoService::decrypt_message_with_counter(
                          &conv_key,
                          &msg.content_encrypted,
                          msg.nonce_counter,
                      ) {
                          Ok(bytes) => String::from_utf8_lossy(&bytes).to_string(),
                          Err(_) => "[Decryption failed]".to_string(),
                      };
          
                      decrypted.push(DecryptedMessage {
                          message_id: msg.message_id,
                          conversation_id: msg.conversation_id,
                          sender_peer_id: msg.sender_peer_id.clone(),
                          recipient_peer_id: msg.recipient_peer_id,
                          content,
                          content_type: msg.content_type,
                          reply_to_message_id: msg.reply_to_message_id,
                          sent_at: msg.sent_at,
                          delivered_at: msg.delivered_at,
                          read_at: msg.read_at,
                          status: msg.status,
                          is_outgoing: msg.sender_peer_id == identity.peer_id,
                      });
                  }
          
                  Ok(decrypted)
              }
          
              /// Get all conversations
              pub fn get_conversations(&self) -> Result<Vec<Conversation>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  MessagesRepository::get_conversations(&self.db, &identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Mark a conversation as read
              pub fn mark_conversation_read(&self, peer_id: &str) -> Result<i64> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let conversation_id = derive_conversation_id(&identity.peer_id, peer_id);
                  let timestamp = chrono::Utc::now().timestamp();
          
                  MessagesRepository::mark_conversation_read(
                      &self.db,
                      &conversation_id,
                      &identity.peer_id,
                      timestamp,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get unread count for a conversation
              pub fn get_unread_count(&self, peer_id: &str) -> Result<i64> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let conversation_id = derive_conversation_id(&identity.peer_id, peer_id);
          
                  MessagesRepository::get_unread_count(&self.db, &conversation_id, &identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Update message status (for network events)
              pub fn update_message_status(&self, message_id: &str, status: MessageStatus) -> Result<bool> {
                  MessagesRepository::update_status(&self.db, message_id, status)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          }
          ```

        - ğŸ“„ **mod.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\mod.rs`
          *Size*: 1604 bytes | *Modified*: 2026-01-17 04:22:40

          ```
          pub mod calling_service;
          pub mod contacts_service;
          pub mod content_sync_service;
          pub mod crypto_service;
          pub mod feed_service;
          pub mod identity_service;
          pub mod messaging_service;
          pub mod permissions_service;
          pub mod posts_service;
          pub mod signing;
          
          pub use calling_service::{CallingService, CallState, Call, OutgoingOffer, OutgoingAnswer, OutgoingIce, OutgoingHangup};
          pub use contacts_service::ContactsService;
          pub use content_sync_service::{ContentSyncService, OutgoingManifestRequest, OutgoingManifestResponse};
          pub use crypto_service::CryptoService;
          pub use feed_service::{FeedService, FeedItem};
          pub use identity_service::IdentityService;
          pub use messaging_service::{MessagingService, DecryptedMessage, OutgoingMessage};
          pub use permissions_service::{
              PermissionsService, PermissionRequestMessage, PermissionGrantMessage, PermissionRevokeMessage,
          };
          pub use posts_service::{PostsService, OutgoingPost, OutgoingPostUpdate, OutgoingPostDelete};
          pub use signing::{
              Signable, sign, verify,
              // Identity messages
              SignableIdentityRequest, SignableIdentityResponse,
              // Permission messages
              SignablePermissionRequest, SignablePermissionGrant, SignablePermissionRevoke,
              // Direct messages
              SignableDirectMessage, SignableMessageAck,
              // Post messages
              SignablePost, SignablePostUpdate, SignablePostDelete,
              // Signaling messages (voice calls)
              SignableSignalingOffer, SignableSignalingAnswer, SignableSignalingIce, SignableSignalingHangup,
              // Content sync
              SignableContentManifestRequest, SignableContentManifestResponse, PostSummary,
              PermissionProof,
          };
          ```

        - ğŸ“„ **permissions_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\permissions_service.rs`
          *Size*: 19163 bytes | *Modified*: 2026-01-16 21:40:46

          ```
          //! Permissions service for managing capability grants
          
          use std::sync::Arc;
          use uuid::Uuid;
          use ed25519_dalek::VerifyingKey;
          
          use crate::db::{Database, Capability, GrantData, Permission, PermissionsRepository};
          use crate::error::{AppError, Result};
          use crate::services::{
              IdentityService, verify, Signable,
              SignablePermissionRequest, SignablePermissionGrant, SignablePermissionRevoke,
          };
          
          /// Service for managing permissions
          pub struct PermissionsService {
              db: Arc<Database>,
              identity_service: Arc<IdentityService>,
          }
          
          /// A permission request to send to another peer
          #[derive(Debug, Clone)]
          pub struct PermissionRequestMessage {
              pub request_id: String,
              pub requester_peer_id: String,
              pub capability: String,
              pub message: Option<String>,
              pub lamport_clock: u64,
              pub timestamp: i64,
              pub signature: Vec<u8>,
          }
          
          /// A permission grant message
          #[derive(Debug, Clone)]
          pub struct PermissionGrantMessage {
              pub grant_id: String,
              pub issuer_peer_id: String,
              pub subject_peer_id: String,
              pub capability: String,
              pub scope: Option<serde_json::Value>,
              pub lamport_clock: u64,
              pub issued_at: i64,
              pub expires_at: Option<i64>,
              pub signature: Vec<u8>,
              pub payload_cbor: Vec<u8>,
          }
          
          /// A permission revoke message
          #[derive(Debug, Clone)]
          pub struct PermissionRevokeMessage {
              pub grant_id: String,
              pub issuer_peer_id: String,
              pub lamport_clock: u64,
              pub revoked_at: i64,
              pub signature: Vec<u8>,
          }
          
          impl PermissionsService {
              /// Create a new permissions service
              pub fn new(db: Arc<Database>, identity_service: Arc<IdentityService>) -> Self {
                  Self { db, identity_service }
              }
          
              // ============================================================
              // Creating Requests/Grants/Revokes (for sending)
              // ============================================================
          
              /// Create a permission request to send to another peer
              pub fn create_permission_request(
                  &self,
                  capability: Capability,
                  message: Option<&str>,
              ) -> Result<PermissionRequestMessage> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let request_id = Uuid::new_v4().to_string();
                  let lamport_clock = self.db.next_lamport_clock(&identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))? as u64;
                  let timestamp = chrono::Utc::now().timestamp();
          
                  let signable = SignablePermissionRequest {
                      request_id: request_id.clone(),
                      requester_peer_id: identity.peer_id.clone(),
                      capability: capability.as_str().to_string(),
                      message: message.map(String::from),
                      lamport_clock,
                      timestamp,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  Ok(PermissionRequestMessage {
                      request_id,
                      requester_peer_id: identity.peer_id,
                      capability: capability.as_str().to_string(),
                      message: message.map(String::from),
                      lamport_clock,
                      timestamp,
                      signature,
                  })
              }
          
              /// Create a permission grant for another peer
              pub fn create_permission_grant(
                  &self,
                  subject_peer_id: &str,
                  capability: Capability,
                  expires_in_seconds: Option<i64>,
              ) -> Result<PermissionGrantMessage> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let grant_id = Uuid::new_v4().to_string();
                  let lamport_clock = self.db.next_lamport_clock(&identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))? as u64;
                  let issued_at = chrono::Utc::now().timestamp();
                  let expires_at = expires_in_seconds.map(|s| issued_at + s);
          
                  let signable = SignablePermissionGrant {
                      grant_id: grant_id.clone(),
                      issuer_peer_id: identity.peer_id.clone(),
                      subject_peer_id: subject_peer_id.to_string(),
                      capability: capability.as_str().to_string(),
                      scope: None,
                      lamport_clock,
                      issued_at,
                      expires_at,
                  };
          
                  // Get CBOR payload for storage
                  let payload_cbor = signable.signable_bytes()?;
                  let signature = self.identity_service.sign(&signable)?;
          
                  // Store locally
                  let grant_data = GrantData {
                      grant_id: grant_id.clone(),
                      issuer_peer_id: identity.peer_id.clone(),
                      subject_peer_id: subject_peer_id.to_string(),
                      capability: capability.as_str().to_string(),
                      scope_json: None,
                      lamport_clock: lamport_clock as i64,
                      issued_at,
                      expires_at,
                      payload_cbor: payload_cbor.clone(),
                      signature: signature.clone(),
                  };
          
                  PermissionsRepository::upsert_grant(&self.db, &grant_data)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = Uuid::new_v4().to_string();
                  PermissionsRepository::record_event(
                      &self.db,
                      &event_id,
                      "grant",
                      &grant_id,
                      &identity.peer_id,
                      Some(&identity.peer_id),
                      subject_peer_id,
                      capability.as_str(),
                      None,
                      lamport_clock as i64,
                      Some(issued_at),
                      expires_at,
                      &payload_cbor,
                      &signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(PermissionGrantMessage {
                      grant_id,
                      issuer_peer_id: identity.peer_id,
                      subject_peer_id: subject_peer_id.to_string(),
                      capability: capability.as_str().to_string(),
                      scope: None,
                      lamport_clock,
                      issued_at,
                      expires_at,
                      signature,
                      payload_cbor,
                  })
              }
          
              /// Revoke a previously granted permission
              pub fn revoke_permission(&self, grant_id: &str) -> Result<PermissionRevokeMessage> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Verify we issued this grant
                  let grant = PermissionsRepository::get_by_grant_id(&self.db, grant_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      .ok_or_else(|| AppError::NotFound("Grant not found".to_string()))?;
          
                  if grant.issuer_peer_id != identity.peer_id {
                      return Err(AppError::Unauthorized("Not the issuer of this grant".to_string()));
                  }
          
                  let lamport_clock = self.db.next_lamport_clock(&identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))? as u64;
                  let revoked_at = chrono::Utc::now().timestamp();
          
                  let signable = SignablePermissionRevoke {
                      grant_id: grant_id.to_string(),
                      issuer_peer_id: identity.peer_id.clone(),
                      lamport_clock,
                      revoked_at,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
                  let payload_cbor = signable.signable_bytes()?;
          
                  // Mark as revoked locally
                  PermissionsRepository::revoke_grant(&self.db, grant_id, revoked_at)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = Uuid::new_v4().to_string();
                  PermissionsRepository::record_event(
                      &self.db,
                      &event_id,
                      "revoke",
                      grant_id,
                      &identity.peer_id,
                      Some(&identity.peer_id),
                      &grant.subject_peer_id,
                      &grant.capability,
                      None,
                      lamport_clock as i64,
                      None,
                      None,
                      &payload_cbor,
                      &signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(PermissionRevokeMessage {
                      grant_id: grant_id.to_string(),
                      issuer_peer_id: identity.peer_id,
                      lamport_clock,
                      revoked_at,
                      signature,
                  })
              }
          
              // ============================================================
              // Processing Incoming Messages
              // ============================================================
          
              /// Verify and store a permission grant from the network
              pub fn process_incoming_grant(
                  &self,
                  grant: &PermissionGrantMessage,
                  issuer_public_key: &[u8],
              ) -> Result<()> {
                  // Verify signature
                  let signable = SignablePermissionGrant {
                      grant_id: grant.grant_id.clone(),
                      issuer_peer_id: grant.issuer_peer_id.clone(),
                      subject_peer_id: grant.subject_peer_id.clone(),
                      capability: grant.capability.clone(),
                      scope: grant.scope.clone(),
                      lamport_clock: grant.lamport_clock,
                      issued_at: grant.issued_at,
                      expires_at: grant.expires_at,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      issuer_public_key.try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, &grant.signature)? {
                      return Err(AppError::Crypto("Invalid grant signature".to_string()));
                  }
          
                  // Check for deduplication
                  let event_id = format!("grant:{}", grant.grant_id);
                  if PermissionsRepository::event_exists(&self.db, &event_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                  {
                      return Ok(()); // Already processed
                  }
          
                  // Update lamport clock
                  self.db.update_lamport_clock(&grant.issuer_peer_id, grant.lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Store grant
                  let grant_data = GrantData {
                      grant_id: grant.grant_id.clone(),
                      issuer_peer_id: grant.issuer_peer_id.clone(),
                      subject_peer_id: grant.subject_peer_id.clone(),
                      capability: grant.capability.clone(),
                      scope_json: grant.scope.as_ref().map(|s| s.to_string()),
                      lamport_clock: grant.lamport_clock as i64,
                      issued_at: grant.issued_at,
                      expires_at: grant.expires_at,
                      payload_cbor: grant.payload_cbor.clone(),
                      signature: grant.signature.clone(),
                  };
          
                  PermissionsRepository::upsert_grant(&self.db, &grant_data)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  PermissionsRepository::record_event(
                      &self.db,
                      &event_id,
                      "grant",
                      &grant.grant_id,
                      &grant.issuer_peer_id,
                      Some(&grant.issuer_peer_id),
                      &grant.subject_peer_id,
                      &grant.capability,
                      grant.scope.as_ref().map(|s| s.to_string()).as_deref(),
                      grant.lamport_clock as i64,
                      Some(grant.issued_at),
                      grant.expires_at,
                      &grant.payload_cbor,
                      &grant.signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(())
              }
          
              /// Verify and process a permission revocation from the network
              pub fn process_incoming_revoke(
                  &self,
                  revoke: &PermissionRevokeMessage,
                  issuer_public_key: &[u8],
              ) -> Result<()> {
                  // Verify signature
                  let signable = SignablePermissionRevoke {
                      grant_id: revoke.grant_id.clone(),
                      issuer_peer_id: revoke.issuer_peer_id.clone(),
                      lamport_clock: revoke.lamport_clock,
                      revoked_at: revoke.revoked_at,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      issuer_public_key.try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, &revoke.signature)? {
                      return Err(AppError::Crypto("Invalid revoke signature".to_string()));
                  }
          
                  // Check for deduplication
                  let event_id = format!("revoke:{}:{}", revoke.grant_id, revoke.lamport_clock);
                  if PermissionsRepository::event_exists(&self.db, &event_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                  {
                      return Ok(()); // Already processed
                  }
          
                  // Update lamport clock
                  self.db.update_lamport_clock(&revoke.issuer_peer_id, revoke.lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Apply revocation
                  PermissionsRepository::revoke_grant(&self.db, &revoke.grant_id, revoke.revoked_at)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event (get grant details for event record)
                  let grant = PermissionsRepository::get_by_grant_id(&self.db, &revoke.grant_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  let payload_cbor = signable.signable_bytes()?;
          
                  if let Some(grant) = grant {
                      PermissionsRepository::record_event(
                          &self.db,
                          &event_id,
                          "revoke",
                          &revoke.grant_id,
                          &revoke.issuer_peer_id,
                          Some(&revoke.issuer_peer_id),
                          &grant.subject_peer_id,
                          &grant.capability,
                          None,
                          revoke.lamport_clock as i64,
                          None,
                          None,
                          &payload_cbor,
                          &revoke.signature,
                      ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
                  }
          
                  Ok(())
              }
          
              // ============================================================
              // Query Methods
              // ============================================================
          
              /// Check if a peer has a specific capability from us
              pub fn peer_has_capability(&self, subject_peer_id: &str, capability: Capability) -> Result<bool> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  PermissionsRepository::has_capability(
                      &self.db,
                      &identity.peer_id,
                      subject_peer_id,
                      capability.as_str(),
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Check if we have a capability from another peer
              pub fn we_have_capability(&self, issuer_peer_id: &str, capability: Capability) -> Result<bool> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  PermissionsRepository::has_capability(
                      &self.db,
                      issuer_peer_id,
                      &identity.peer_id,
                      capability.as_str(),
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get all permissions we've granted
              pub fn get_granted_permissions(&self) -> Result<Vec<Permission>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  PermissionsRepository::get_permissions_by_issuer(&self.db, &identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get all permissions granted to us
              pub fn get_received_permissions(&self) -> Result<Vec<Permission>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  PermissionsRepository::get_permissions_for_subject(&self.db, &identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get all peers we can chat with (we granted them chat)
              pub fn get_chat_peers(&self) -> Result<Vec<String>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  PermissionsRepository::get_chat_contacts(&self.db, &identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get the grant for a specific permission (for proof generation)
              pub fn get_capability_grant(
                  &self,
                  issuer_peer_id: &str,
                  capability: Capability,
              ) -> Result<Option<Permission>> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  PermissionsRepository::get_capability_grant(
                      &self.db,
                      issuer_peer_id,
                      &identity.peer_id,
                      capability.as_str(),
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          }
          
          #[cfg(test)]
          mod tests {
              use super::*;
              use crate::models::CreateIdentityRequest;
          
              fn create_test_service() -> (Arc<Database>, Arc<IdentityService>, PermissionsService) {
                  let db = Arc::new(Database::in_memory().unwrap());
                  let identity_service = Arc::new(IdentityService::new(db.clone()));
                  let permissions_service = PermissionsService::new(db.clone(), identity_service.clone());
                  (db, identity_service, permissions_service)
              }
          
              #[test]
              fn test_create_grant() {
                  let (_, identity_service, permissions_service) = create_test_service();
          
                  // Create identity first
                  identity_service.create_identity(CreateIdentityRequest {
                      display_name: "Test User".to_string(),
                      passphrase: "password123".to_string(),
                      bio: None,
                  }).unwrap();
                  identity_service.unlock("password123").unwrap();
          
                  // Create a grant
                  let grant = permissions_service.create_permission_grant(
                      "12D3KooWSubject",
                      Capability::Chat,
                      None,
                  ).unwrap();
          
                  assert!(!grant.grant_id.is_empty());
                  assert_eq!(grant.capability, "chat");
          
                  // Verify it's stored
                  assert!(permissions_service.peer_has_capability("12D3KooWSubject", Capability::Chat).unwrap());
              }
          
              #[test]
              fn test_revoke_grant() {
                  let (_, identity_service, permissions_service) = create_test_service();
          
                  identity_service.create_identity(CreateIdentityRequest {
                      display_name: "Test User".to_string(),
                      passphrase: "password123".to_string(),
                      bio: None,
                  }).unwrap();
                  identity_service.unlock("password123").unwrap();
          
                  let grant = permissions_service.create_permission_grant(
                      "12D3KooWSubject",
                      Capability::Chat,
                      None,
                  ).unwrap();
          
                  // Verify capability exists
                  assert!(permissions_service.peer_has_capability("12D3KooWSubject", Capability::Chat).unwrap());
          
                  // Revoke
                  permissions_service.revoke_permission(&grant.grant_id).unwrap();
          
                  // Verify capability is gone
                  assert!(!permissions_service.peer_has_capability("12D3KooWSubject", Capability::Chat).unwrap());
              }
          }
          ```

        - ğŸ“„ **posts_service.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\posts_service.rs`
          *Size*: 20693 bytes | *Modified*: 2026-01-16 23:47:53

          ```
          //! Posts service for managing wall/blog posts
          
          use std::sync::Arc;
          use uuid::Uuid;
          use ed25519_dalek::VerifyingKey;
          
          use crate::db::{
              Database, Capability, PostsRepository, PostData, PostMediaData, PostVisibility, Post, PostMedia,
          };
          use crate::error::{AppError, Result};
          use crate::services::{
              ContactsService, IdentityService, PermissionsService,
              verify, Signable, SignablePost, SignablePostUpdate, SignablePostDelete,
          };
          
          /// Service for managing wall/blog posts
          pub struct PostsService {
              db: Arc<Database>,
              identity_service: Arc<IdentityService>,
              contacts_service: Arc<ContactsService>,
              permissions_service: Arc<PermissionsService>,
          }
          
          /// A post ready to be synced over the network
          #[derive(Debug, Clone)]
          pub struct OutgoingPost {
              pub post_id: String,
              pub author_peer_id: String,
              pub content_type: String,
              pub content_text: Option<String>,
              pub media_hashes: Vec<String>,
              pub visibility: String,
              pub lamport_clock: u64,
              pub created_at: i64,
              pub signature: Vec<u8>,
          }
          
          /// A post update ready to be synced
          #[derive(Debug, Clone)]
          pub struct OutgoingPostUpdate {
              pub post_id: String,
              pub author_peer_id: String,
              pub content_text: Option<String>,
              pub lamport_clock: u64,
              pub updated_at: i64,
              pub signature: Vec<u8>,
          }
          
          /// A post delete ready to be synced
          #[derive(Debug, Clone)]
          pub struct OutgoingPostDelete {
              pub post_id: String,
              pub author_peer_id: String,
              pub lamport_clock: u64,
              pub deleted_at: i64,
              pub signature: Vec<u8>,
          }
          
          impl PostsService {
              /// Create a new posts service
              pub fn new(
                  db: Arc<Database>,
                  identity_service: Arc<IdentityService>,
                  contacts_service: Arc<ContactsService>,
                  permissions_service: Arc<PermissionsService>,
              ) -> Self {
                  Self {
                      db,
                      identity_service,
                      contacts_service,
                      permissions_service,
                  }
              }
          
              /// Create a new post
              pub fn create_post(
                  &self,
                  content_type: &str,
                  content_text: Option<&str>,
                  visibility: PostVisibility,
              ) -> Result<OutgoingPost> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  let post_id = Uuid::new_v4().to_string();
                  let lamport_clock = self.db.next_lamport_clock(&identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))? as u64;
                  let created_at = chrono::Utc::now().timestamp();
          
                  // Create signable
                  let signable = SignablePost {
                      post_id: post_id.clone(),
                      author_peer_id: identity.peer_id.clone(),
                      content_type: content_type.to_string(),
                      content_text: content_text.map(String::from),
                      media_hashes: Vec::new(), // Media added separately
                      visibility: visibility.to_string(),
                      lamport_clock,
                      created_at,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  // Store locally
                  let post_data = PostData {
                      post_id: post_id.clone(),
                      author_peer_id: identity.peer_id.clone(),
                      content_type: content_type.to_string(),
                      content_text: content_text.map(String::from),
                      visibility: visibility.clone(),
                      lamport_clock: lamport_clock as i64,
                      created_at,
                      signature: signature.clone(),
                  };
          
                  PostsRepository::insert_post(&self.db, &post_data)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = format!("created:{}", post_id);
                  let payload_cbor = signable.signable_bytes()?;
                  PostsRepository::record_post_event(
                      &self.db,
                      &event_id,
                      "created",
                      &post_id,
                      &identity.peer_id,
                      lamport_clock as i64,
                      created_at,
                      &payload_cbor,
                      &signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(OutgoingPost {
                      post_id,
                      author_peer_id: identity.peer_id,
                      content_type: content_type.to_string(),
                      content_text: content_text.map(String::from),
                      media_hashes: Vec::new(),
                      visibility: visibility.to_string(),
                      lamport_clock,
                      created_at,
                      signature,
                  })
              }
          
              /// Update a post's content
              pub fn update_post(&self, post_id: &str, content_text: Option<&str>) -> Result<OutgoingPostUpdate> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Verify we own the post
                  let post = PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      .ok_or_else(|| AppError::NotFound("Post not found".to_string()))?;
          
                  if post.author_peer_id != identity.peer_id {
                      return Err(AppError::PermissionDenied("Cannot update another user's post".to_string()));
                  }
          
                  let lamport_clock = self.db.next_lamport_clock(&identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))? as u64;
                  let updated_at = chrono::Utc::now().timestamp();
          
                  // Create signable
                  let signable = SignablePostUpdate {
                      post_id: post_id.to_string(),
                      author_peer_id: identity.peer_id.clone(),
                      content_text: content_text.map(String::from),
                      lamport_clock,
                      updated_at,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  // Update locally
                  PostsRepository::update_post(&self.db, post_id, content_text, updated_at, lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = format!("updated:{}:{}", post_id, lamport_clock);
                  let payload_cbor = signable.signable_bytes()?;
                  PostsRepository::record_post_event(
                      &self.db,
                      &event_id,
                      "updated",
                      post_id,
                      &identity.peer_id,
                      lamport_clock as i64,
                      updated_at,
                      &payload_cbor,
                      &signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(OutgoingPostUpdate {
                      post_id: post_id.to_string(),
                      author_peer_id: identity.peer_id,
                      content_text: content_text.map(String::from),
                      lamport_clock,
                      updated_at,
                      signature,
                  })
              }
          
              /// Delete a post (soft delete)
              pub fn delete_post(&self, post_id: &str) -> Result<OutgoingPostDelete> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Verify we own the post
                  let post = PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      .ok_or_else(|| AppError::NotFound("Post not found".to_string()))?;
          
                  if post.author_peer_id != identity.peer_id {
                      return Err(AppError::PermissionDenied("Cannot delete another user's post".to_string()));
                  }
          
                  let lamport_clock = self.db.next_lamport_clock(&identity.peer_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))? as u64;
                  let deleted_at = chrono::Utc::now().timestamp();
          
                  // Create signable
                  let signable = SignablePostDelete {
                      post_id: post_id.to_string(),
                      author_peer_id: identity.peer_id.clone(),
                      lamport_clock,
                      deleted_at,
                  };
          
                  let signature = self.identity_service.sign(&signable)?;
          
                  // Delete locally
                  PostsRepository::delete_post(&self.db, post_id, deleted_at)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = format!("deleted:{}", post_id);
                  let payload_cbor = signable.signable_bytes()?;
                  PostsRepository::record_post_event(
                      &self.db,
                      &event_id,
                      "deleted",
                      post_id,
                      &identity.peer_id,
                      lamport_clock as i64,
                      deleted_at,
                      &payload_cbor,
                      &signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(OutgoingPostDelete {
                      post_id: post_id.to_string(),
                      author_peer_id: identity.peer_id,
                      lamport_clock,
                      deleted_at,
                      signature,
                  })
              }
          
              /// Add media to a post
              pub fn add_media_to_post(
                  &self,
                  post_id: &str,
                  media_hash: &str,
                  media_type: &str,
                  mime_type: &str,
                  file_name: &str,
                  file_size: i64,
                  width: Option<i32>,
                  height: Option<i32>,
                  duration_seconds: Option<i32>,
                  sort_order: i32,
              ) -> Result<()> {
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  // Verify we own the post
                  let post = PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      .ok_or_else(|| AppError::NotFound("Post not found".to_string()))?;
          
                  if post.author_peer_id != identity.peer_id {
                      return Err(AppError::PermissionDenied("Cannot add media to another user's post".to_string()));
                  }
          
                  let media_data = PostMediaData {
                      post_id: post_id.to_string(),
                      media_hash: media_hash.to_string(),
                      media_type: media_type.to_string(),
                      mime_type: mime_type.to_string(),
                      file_name: file_name.to_string(),
                      file_size,
                      width,
                      height,
                      duration_seconds,
                      sort_order,
                  };
          
                  PostsRepository::add_media(&self.db, &media_data)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get media for a post
              pub fn get_post_media(&self, post_id: &str) -> Result<Vec<PostMedia>> {
                  PostsRepository::get_post_media(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get a post by ID
              pub fn get_post(&self, post_id: &str) -> Result<Option<Post>> {
                  PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get local user's posts (their wall)
              pub fn get_my_posts(&self, limit: i64, before_timestamp: Option<i64>) -> Result<Vec<Post>> {
                  // Verify identity exists
                  let _identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  PostsRepository::get_local_posts(&self.db, limit, before_timestamp)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Get posts by a specific author (for viewing their wall)
              pub fn get_posts_by_author(&self, author_peer_id: &str, limit: i64, before_timestamp: Option<i64>) -> Result<Vec<Post>> {
                  // If not our posts, check we have WallRead permission
                  let identity = self.identity_service.get_identity()?
                      .ok_or_else(|| AppError::NotFound("No identity".to_string()))?;
          
                  if author_peer_id != identity.peer_id {
                      // Check if they've granted us WallRead permission
                      if !self.permissions_service.we_have_capability(author_peer_id, Capability::WallRead)? {
                          return Err(AppError::PermissionDenied(
                              "No permission to view this user's wall".to_string()
                          ));
                      }
                  }
          
                  PostsRepository::get_by_author(&self.db, author_peer_id, limit, before_timestamp)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))
              }
          
              /// Process an incoming post from the network
              pub fn process_incoming_post(
                  &self,
                  post_id: &str,
                  author_peer_id: &str,
                  content_type: &str,
                  content_text: Option<&str>,
                  media_hashes: &[String],
                  visibility: &str,
                  lamport_clock: u64,
                  created_at: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Get author's public key for verification
                  let author_public_key = self.contacts_service.get_public_key(author_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Author not in contacts".to_string()))?;
          
                  // Verify signature
                  let signable = SignablePost {
                      post_id: post_id.to_string(),
                      author_peer_id: author_peer_id.to_string(),
                      content_type: content_type.to_string(),
                      content_text: content_text.map(String::from),
                      media_hashes: media_hashes.to_vec(),
                      visibility: visibility.to_string(),
                      lamport_clock,
                      created_at,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      author_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid post signature".to_string()));
                  }
          
                  // Check if we already have this post
                  if let Some(existing) = PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                  {
                      // Accept if higher lamport clock
                      if lamport_clock <= existing.lamport_clock as u64 {
                          return Ok(()); // Already have newer or same version
                      }
                  }
          
                  // Update lamport clock
                  self.db.update_lamport_clock(author_peer_id, lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Parse visibility
                  let vis = match visibility {
                      "contacts" => PostVisibility::Contacts,
                      "public" => PostVisibility::Public,
                      _ => return Err(AppError::Validation(format!("Invalid visibility: {}", visibility))),
                  };
          
                  // Store post
                  let post_data = PostData {
                      post_id: post_id.to_string(),
                      author_peer_id: author_peer_id.to_string(),
                      content_type: content_type.to_string(),
                      content_text: content_text.map(String::from),
                      visibility: vis,
                      lamport_clock: lamport_clock as i64,
                      created_at,
                      signature: signature.to_vec(),
                  };
          
                  // Use upsert behavior
                  if PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?.is_some()
                  {
                      // Update existing - use update_post but with full content
                      PostsRepository::update_post(&self.db, post_id, content_text, created_at, lamport_clock as i64)
                          .map_err(|e| AppError::DatabaseString(e.to_string()))?;
                  } else {
                      PostsRepository::insert_post(&self.db, &post_data)
                          .map_err(|e| AppError::DatabaseString(e.to_string()))?;
                  }
          
                  // Record event
                  let event_id = format!("received:{}:{}", post_id, lamport_clock);
                  let payload_cbor = signable.signable_bytes()?;
                  PostsRepository::record_post_event(
                      &self.db,
                      &event_id,
                      "received",
                      post_id,
                      author_peer_id,
                      lamport_clock as i64,
                      created_at,
                      &payload_cbor,
                      signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(())
              }
          
              /// Process an incoming post update
              pub fn process_incoming_post_update(
                  &self,
                  post_id: &str,
                  author_peer_id: &str,
                  content_text: Option<&str>,
                  lamport_clock: u64,
                  updated_at: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Get author's public key
                  let author_public_key = self.contacts_service.get_public_key(author_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Author not in contacts".to_string()))?;
          
                  // Verify signature
                  let signable = SignablePostUpdate {
                      post_id: post_id.to_string(),
                      author_peer_id: author_peer_id.to_string(),
                      content_text: content_text.map(String::from),
                      lamport_clock,
                      updated_at,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      author_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid post update signature".to_string()));
                  }
          
                  // Check we have the post and it's older
                  let existing = PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?
                      .ok_or_else(|| AppError::NotFound("Post not found".to_string()))?;
          
                  if lamport_clock <= existing.lamport_clock as u64 {
                      return Ok(()); // Already have newer or same version
                  }
          
                  // Update lamport clock
                  self.db.update_lamport_clock(author_peer_id, lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Update post
                  PostsRepository::update_post(&self.db, post_id, content_text, updated_at, lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = format!("updated:{}:{}", post_id, lamport_clock);
                  let payload_cbor = signable.signable_bytes()?;
                  PostsRepository::record_post_event(
                      &self.db,
                      &event_id,
                      "updated",
                      post_id,
                      author_peer_id,
                      lamport_clock as i64,
                      updated_at,
                      &payload_cbor,
                      signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(())
              }
          
              /// Process an incoming post delete
              pub fn process_incoming_post_delete(
                  &self,
                  post_id: &str,
                  author_peer_id: &str,
                  lamport_clock: u64,
                  deleted_at: i64,
                  signature: &[u8],
              ) -> Result<()> {
                  // Get author's public key
                  let author_public_key = self.contacts_service.get_public_key(author_peer_id)?
                      .ok_or_else(|| AppError::NotFound("Author not in contacts".to_string()))?;
          
                  // Verify signature
                  let signable = SignablePostDelete {
                      post_id: post_id.to_string(),
                      author_peer_id: author_peer_id.to_string(),
                      lamport_clock,
                      deleted_at,
                  };
          
                  let verifying_key = VerifyingKey::from_bytes(
                      author_public_key.as_slice().try_into()
                          .map_err(|_| AppError::Crypto("Invalid public key length".to_string()))?
                  ).map_err(|e| AppError::Crypto(format!("Invalid public key: {}", e)))?;
          
                  if !verify(&verifying_key, &signable, signature)? {
                      return Err(AppError::Crypto("Invalid post delete signature".to_string()));
                  }
          
                  // Check we have the post
                  let existing = PostsRepository::get_by_post_id(&self.db, post_id)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  if let Some(post) = existing {
                      if lamport_clock <= post.lamport_clock as u64 {
                          return Ok(()); // Already have newer or same version
                      }
                  }
          
                  // Update lamport clock
                  self.db.update_lamport_clock(author_peer_id, lamport_clock as i64)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Delete post
                  PostsRepository::delete_post(&self.db, post_id, deleted_at)
                      .map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  // Record event
                  let event_id = format!("deleted:{}", post_id);
                  let payload_cbor = signable.signable_bytes()?;
                  PostsRepository::record_post_event(
                      &self.db,
                      &event_id,
                      "deleted",
                      post_id,
                      author_peer_id,
                      lamport_clock as i64,
                      deleted_at,
                      &payload_cbor,
                      signature,
                  ).map_err(|e| AppError::DatabaseString(e.to_string()))?;
          
                  Ok(())
              }
          }
          ```

        - ğŸ“„ **signing.rs**

          ğŸ“„ *File Path*: `.\src-tauri\src\services\signing.rs`
          *Size*: 13266 bytes | *Modified*: 2026-01-16 18:24:21

          ```
          //! Canonical Signing Rules
          //!
          //! This module defines exactly how data is signed and verified in the chat application.
          //! Following these rules strictly prevents subtle security bugs.
          //!
          //! ## Key Principles
          //!
          //! 1. **Signature is NEVER part of signed bytes**: The signature field is excluded from
          //!    the data being signed. We sign the payload, then attach the signature.
          //!
          //! 2. **CBOR encoding is deterministic**: We use RFC 8949 canonical CBOR encoding
          //!    (sorted keys, minimal encoding) via ciborium.
          //!
          //! 3. **All signable structs have a `Signable` variant**: For each protocol message,
          //!    we define a version without the signature field for signing.
          //!
          //! ## Signing Process
          //!
          //! 1. Create the signable payload (struct without signature)
          //! 2. CBOR-encode with canonical encoding
          //! 3. Sign the raw bytes with Ed25519
          //! 4. Create the final message with payload + signature
          //!
          //! ## Verification Process
          //!
          //! 1. Extract signature from message
          //! 2. Create signable payload from message fields (excluding signature)
          //! 3. CBOR-encode with canonical encoding
          //! 4. Verify signature against raw bytes
          
          use ed25519_dalek::{Signature, Signer, SigningKey, Verifier, VerifyingKey};
          use serde::{Deserialize, Serialize};
          use crate::error::{AppError, Result};
          
          /// Trait for types that can be canonically signed
          pub trait Signable: Serialize {
              /// Get the bytes to be signed (canonical CBOR encoding)
              fn signable_bytes(&self) -> Result<Vec<u8>> {
                  let mut bytes = Vec::new();
                  ciborium::into_writer(self, &mut bytes)
                      .map_err(|e| AppError::Serialization(format!("CBOR encoding failed: {}", e)))?;
                  Ok(bytes)
              }
          }
          
          /// Sign data with an Ed25519 key
          pub fn sign(signing_key: &SigningKey, signable: &impl Signable) -> Result<Vec<u8>> {
              let bytes = signable.signable_bytes()?;
              let signature = signing_key.sign(&bytes);
              Ok(signature.to_bytes().to_vec())
          }
          
          /// Verify a signature against signable data
          pub fn verify(
              verifying_key: &VerifyingKey,
              signable: &impl Signable,
              signature_bytes: &[u8],
          ) -> Result<bool> {
              let bytes = signable.signable_bytes()?;
          
              let signature = Signature::from_slice(signature_bytes)
                  .map_err(|e| AppError::Crypto(format!("Invalid signature format: {}", e)))?;
          
              Ok(verifying_key.verify(&bytes, &signature).is_ok())
          }
          
          // ============================================================
          // IDENTITY MESSAGES
          // ============================================================
          
          /// Signable version of IdentityRequest (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableIdentityRequest {
              pub requester_peer_id: String,
              pub timestamp: i64,
          }
          
          impl Signable for SignableIdentityRequest {}
          
          /// Signable version of IdentityResponse (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableIdentityResponse {
              pub peer_id: String,
              pub public_key: Vec<u8>,
              pub x25519_public: Vec<u8>,
              pub display_name: String,
              pub avatar_hash: Option<String>,
              pub bio: Option<String>,
              pub identity_version: String,  // hash for caching
              pub timestamp: i64,
          }
          
          impl Signable for SignableIdentityResponse {}
          
          // ============================================================
          // PERMISSION MESSAGES
          // ============================================================
          
          /// Signable version of PermissionRequest
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignablePermissionRequest {
              pub request_id: String,
              pub requester_peer_id: String,
              pub capability: String,
              pub message: Option<String>,
              pub lamport_clock: u64,
              pub timestamp: i64,
          }
          
          impl Signable for SignablePermissionRequest {}
          
          /// Signable version of PermissionGrant
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignablePermissionGrant {
              pub grant_id: String,
              pub issuer_peer_id: String,
              pub subject_peer_id: String,
              pub capability: String,
              pub scope: Option<serde_json::Value>,
              pub lamport_clock: u64,
              pub issued_at: i64,
              pub expires_at: Option<i64>,
          }
          
          impl Signable for SignablePermissionGrant {}
          
          /// Signable version of PermissionRevoke
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignablePermissionRevoke {
              pub grant_id: String,
              pub issuer_peer_id: String,
              pub lamport_clock: u64,
              pub revoked_at: i64,
          }
          
          impl Signable for SignablePermissionRevoke {}
          
          // ============================================================
          // MESSAGE TYPES
          // ============================================================
          
          /// Signable version of DirectMessage (excludes signature)
          ///
          /// # Nonce Counter Field
          ///
          /// The `nonce_counter` is included in the signed payload, which means:
          /// - Attacker cannot modify the counter without invalidating signature
          /// - Each message has a cryptographically bound nonce
          /// - Replay of exact message is detected via `check_and_record_nonce()`
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableDirectMessage {
              pub message_id: String,
              pub conversation_id: String,
              pub sender_peer_id: String,
              pub recipient_peer_id: String,
              pub content_encrypted: Vec<u8>,
              pub content_type: String,
              pub reply_to: Option<String>,
              pub nonce_counter: u64,  // For replay protection - bound to signature
              pub lamport_clock: u64,
              pub timestamp: i64,
          }
          
          impl Signable for SignableDirectMessage {}
          
          /// Signable version of MessageAck (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableMessageAck {
              pub message_id: String,
              pub conversation_id: String,
              pub ack_sender_peer_id: String,
              pub status: String,  // "delivered" or "read"
              pub timestamp: i64,
          }
          
          impl Signable for SignableMessageAck {}
          
          // ============================================================
          // POST MESSAGES
          // ============================================================
          
          /// Signable version of Post (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignablePost {
              pub post_id: String,
              pub author_peer_id: String,
              pub content_type: String,
              pub content_text: Option<String>,
              pub media_hashes: Vec<String>,
              pub visibility: String,
              pub lamport_clock: u64,
              pub created_at: i64,
          }
          
          impl Signable for SignablePost {}
          
          /// Signable version of PostUpdate (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignablePostUpdate {
              pub post_id: String,
              pub author_peer_id: String,
              pub content_text: Option<String>,
              pub lamport_clock: u64,
              pub updated_at: i64,
          }
          
          impl Signable for SignablePostUpdate {}
          
          /// Signable version of PostDelete (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignablePostDelete {
              pub post_id: String,
              pub author_peer_id: String,
              pub lamport_clock: u64,
              pub deleted_at: i64,
          }
          
          impl Signable for SignablePostDelete {}
          
          // ============================================================
          // SIGNALING (Voice Calls)
          // ============================================================
          
          /// Signable version of SignalingOffer (excludes signature)
          ///
          /// The SDP (Session Description Protocol) blob contains WebRTC parameters.
          /// Signing prevents MITM from modifying the offer during relay.
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableSignalingOffer {
              pub call_id: String,
              pub caller_peer_id: String,
              pub callee_peer_id: String,
              pub sdp: String,
              pub timestamp: i64,
          }
          
          impl Signable for SignableSignalingOffer {}
          
          /// Signable version of SignalingAnswer (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableSignalingAnswer {
              pub call_id: String,
              pub caller_peer_id: String,
              pub callee_peer_id: String,
              pub sdp: String,
              pub timestamp: i64,
          }
          
          impl Signable for SignableSignalingAnswer {}
          
          /// Signable version of SignalingIce (excludes signature)
          ///
          /// ICE candidates are signed to prevent injection attacks
          /// where an attacker could redirect media streams.
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableSignalingIce {
              pub call_id: String,
              pub sender_peer_id: String,
              pub candidate: String,
              pub sdp_mid: Option<String>,
              pub sdp_mline_index: Option<u32>,
              pub timestamp: i64,
          }
          
          impl Signable for SignableSignalingIce {}
          
          /// Signable version of SignalingHangup (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableSignalingHangup {
              pub call_id: String,
              pub sender_peer_id: String,
              pub reason: String,  // "normal", "busy", "declined", "error"
              pub timestamp: i64,
          }
          
          impl Signable for SignableSignalingHangup {}
          
          // ============================================================
          // CONTENT SYNC
          // ============================================================
          
          /// Signable version of ContentManifestRequest (excludes signature)
          ///
          /// The `cursor` is a map of author_peer_id -> last_seen_lamport_clock.
          /// This replaces timestamp-based sync with lamport-based sync, ensuring
          /// no events are missed due to clock skew.
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableContentManifestRequest {
              pub requester_peer_id: String,
              /// Map of author_peer_id -> highest lamport clock seen from that author
              /// Empty map means "give me everything"
              pub cursor: std::collections::HashMap<String, u64>,
              pub limit: u32,
              pub timestamp: i64,
          }
          
          impl Signable for SignableContentManifestRequest {}
          
          /// Signable version of ContentManifestResponse (excludes signature)
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct SignableContentManifestResponse {
              pub responder_peer_id: String,
              /// Posts included in this response
              pub posts: Vec<PostSummary>,
              /// Whether there are more posts to fetch
              pub has_more: bool,
              /// Updated cursor for next request (author_peer_id -> lamport_clock)
              pub next_cursor: std::collections::HashMap<String, u64>,
              pub timestamp: i64,
          }
          
          impl Signable for SignableContentManifestResponse {}
          
          /// Summary of a post for manifest responses
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct PostSummary {
              pub post_id: String,
              pub author_peer_id: String,
              pub lamport_clock: u64,
              pub content_type: String,
              pub has_media: bool,
              pub media_hashes: Vec<String>,
              pub created_at: i64,
          }
          
          /// Permission proof for content requests
          /// This is what gets sent to prove you have access
          #[derive(Debug, Clone, Serialize, Deserialize)]
          pub struct PermissionProof {
              /// The signed grant object (CBOR bytes)
              pub grant_cbor: Vec<u8>,
              /// Signature over the grant
              pub grant_signature: Vec<u8>,
              /// Optional: latest known revocation timestamp (if any)
              pub latest_revoke_check: Option<i64>,
          }
          
          #[cfg(test)]
          mod tests {
              use super::*;
              use rand::rngs::OsRng;
          
              #[test]
              fn test_sign_and_verify() {
                  let signing_key = SigningKey::generate(&mut OsRng);
                  let verifying_key = signing_key.verifying_key();
          
                  let request = SignableIdentityRequest {
                      requester_peer_id: "12D3KooWTest".to_string(),
                      timestamp: 1234567890,
                  };
          
                  let signature = sign(&signing_key, &request).unwrap();
                  assert!(verify(&verifying_key, &request, &signature).unwrap());
              }
          
              #[test]
              fn test_modified_data_fails_verification() {
                  let signing_key = SigningKey::generate(&mut OsRng);
                  let verifying_key = signing_key.verifying_key();
          
                  let request = SignableIdentityRequest {
                      requester_peer_id: "12D3KooWTest".to_string(),
                      timestamp: 1234567890,
                  };
          
                  let signature = sign(&signing_key, &request).unwrap();
          
                  // Modify the data
                  let modified_request = SignableIdentityRequest {
                      requester_peer_id: "12D3KooWTest".to_string(),
                      timestamp: 1234567891, // Different timestamp
                  };
          
                  // Verification should fail
                  assert!(!verify(&verifying_key, &modified_request, &signature).unwrap());
              }
          
              #[test]
              fn test_wrong_key_fails_verification() {
                  let signing_key = SigningKey::generate(&mut OsRng);
                  let wrong_key = SigningKey::generate(&mut OsRng);
                  let wrong_verifying_key = wrong_key.verifying_key();
          
                  let request = SignableIdentityRequest {
                      requester_peer_id: "12D3KooWTest".to_string(),
                      timestamp: 1234567890,
                  };
          
                  let signature = sign(&signing_key, &request).unwrap();
          
                  // Verification with wrong key should fail
                  assert!(!verify(&wrong_verifying_key, &request, &signature).unwrap());
              }
          
              #[test]
              fn test_canonical_cbor_deterministic() {
                  let request1 = SignableIdentityRequest {
                      requester_peer_id: "12D3KooWTest".to_string(),
                      timestamp: 1234567890,
                  };
          
                  let request2 = SignableIdentityRequest {
                      requester_peer_id: "12D3KooWTest".to_string(),
                      timestamp: 1234567890,
                  };
          
                  let bytes1 = request1.signable_bytes().unwrap();
                  let bytes2 = request2.signable_bytes().unwrap();
          
                  assert_eq!(bytes1, bytes2, "Same data should produce same bytes");
              }
          }
          ```

    - ğŸ“„ **tauri.bob.json**

      ğŸ“„ *File Path*: `.\src-tauri\tauri.bob.json`
      *Size*: 804 bytes | *Modified*: 2026-01-18 00:08:16

      ```
      {
        "$schema": "https://schema.tauri.app/config/2",
        "productName": "Harbor - Bob",
        "version": "0.1.0",
        "identifier": "io.harbor.app.bob",
        "build": {
          "beforeDevCommand": "npm run dev -- --port 1421",
          "devUrl": "http://localhost:1421",
          "beforeBuildCommand": "npm run build",
          "frontendDist": "../dist"
        },
        "app": {
          "windows": [
            {
              "title": "Harbor - Bob",
              "width": 1200,
              "height": 800,
              "minWidth": 800,
              "minHeight": 600
            }
          ],
          "security": {
            "csp": null
          }
        },
        "bundle": {
          "active": true,
          "targets": "all",
          "icon": [
            "icons/32x32.png",
            "icons/128x128.png",
            "icons/128x128@2x.png",
            "icons/icon.icns",
            "icons/icon.ico"
          ]
        }
      }
      ```

    - ğŸ“„ **tauri.conf.json**

      ğŸ“„ *File Path*: `.\src-tauri\tauri.conf.json`
      *Size*: 773 bytes | *Modified*: 2026-01-16 22:04:22

      ```
      {
        "$schema": "https://schema.tauri.app/config/2",
        "productName": "Harbor",
        "version": "0.1.0",
        "identifier": "io.harbor.app",
        "build": {
          "beforeDevCommand": "npm run dev",
          "devUrl": "http://localhost:1420",
          "beforeBuildCommand": "npm run build",
          "frontendDist": "../dist"
        },
        "app": {
          "windows": [
            {
              "title": "Harbor",
              "width": 1200,
              "height": 800,
              "minWidth": 800,
              "minHeight": 600
            }
          ],
          "security": {
            "csp": null
          }
        },
        "bundle": {
          "active": true,
          "targets": "all",
          "icon": [
            "icons/32x32.png",
            "icons/128x128.png",
            "icons/128x128@2x.png",
            "icons/icon.icns",
            "icons/icon.ico"
          ]
        }
      }
      ```

  - ğŸ“„ **tmpclaude-0cfe-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-0cfe-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 22:08:58

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-1c37-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-1c37-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 23:38:38

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-22d1-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-22d1-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 23:00:32

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-2cdc-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-2cdc-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 20:53:26

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-3043-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-3043-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 23:38:05

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-5d13-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-5d13-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 21:44:44

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-60c4-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-60c4-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 21:52:07

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-6746-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-6746-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 23:37:56

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-6d61-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-6d61-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 20:53:37

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-71e8-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-71e8-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 22:07:42

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-7d8a-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-7d8a-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 20:54:19

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-7e73-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-7e73-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 23:38:50

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-8e3d-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-8e3d-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 20:52:59

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-a185-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-a185-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 20:54:04

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-a1d5-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-a1d5-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 21:24:23

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-b02a-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-b02a-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 20:53:14

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-c9b3-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-c9b3-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 22:59:16

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-cb21-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-cb21-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 21:43:45

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-cd4c-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-cd4c-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 23:38:14

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-dbbd-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-dbbd-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 20:52:39

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tmpclaude-ec48-cwd**

    ğŸ“„ *File Path*: `.\tmpclaude-ec48-cwd`
    *Size*: 17 bytes | *Modified*: 2026-01-16 21:41:41

    ```
    /d/apps/chat-app
    ```

  - ğŸ“„ **tsconfig.json**

    ğŸ“„ *File Path*: `.\tsconfig.json`
    *Size*: 630 bytes | *Modified*: 2026-01-16 17:05:55

    ```
    {
      "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "module": "ESNext",
        "skipLibCheck": true,
    
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
    
        /* Linting */
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true
      },
      "include": ["src"],
      "references": [{ "path": "./tsconfig.node.json" }]
    }
    ```

  - ğŸ“„ **tsconfig.node.json**

    ğŸ“„ *File Path*: `.\tsconfig.node.json`
    *Size*: 223 bytes | *Modified*: 2026-01-16 17:05:55

    ```
    {
      "compilerOptions": {
        "composite": true,
        "skipLibCheck": true,
        "module": "ESNext",
        "moduleResolution": "bundler",
        "allowSyntheticDefaultImports": true
      },
      "include": ["vite.config.ts"]
    }
    ```

  - ğŸ“„ **vite.config.ts**

    ğŸ“„ *File Path*: `.\vite.config.ts`
    *Size*: 1024 bytes | *Modified*: 2026-01-18 00:14:55

    ```
    import { defineConfig } from "vite";
    import react from "@vitejs/plugin-react";
    import tailwindcss from "@tailwindcss/vite";
    
    // @ts-expect-error process is a nodejs global
    const host = process.env.TAURI_DEV_HOST;
    // @ts-expect-error process is a nodejs global
    const port = parseInt(process.env.VITE_PORT || "1420", 10);
    
    // https://vite.dev/config/
    export default defineConfig(async () => ({
      plugins: [react(), tailwindcss()],
    
      // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
      //
      // 1. prevent Vite from obscuring rust errors
      clearScreen: false,
      // 2. tauri expects a fixed port, fail if that port is not available
      server: {
        port: port,
        strictPort: true,
        host: host || false,
        hmr: host
          ? {
              protocol: "ws",
              host,
              port: port + 1,
            }
          : undefined,
        watch: {
          // 3. tell Vite to ignore watching `src-tauri`
          ignored: ["**/src-tauri/**"],
        },
      },
    }));
    ```

